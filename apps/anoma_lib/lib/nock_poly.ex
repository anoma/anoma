defmodule NockPoly do
  @moduledoc """
  Representations of polynomial functors in Elixir, and of Nock
  as a polynomial functor.
  """

  require Noun
  require Nock
  require Logger

  use TypedStruct

  defmodule Term do
    @moduledoc """

    I represent a term of any type which can be generated by the
    application of finitary polynomial functors -- in particular
    all finite products and coproducts.  I am a form of S-expression
    chosen to correspond to the application of polynomial functors --
    such an application produces a dependent pair of a position
    (which is effectively a constructor together with any of its
    parameters, in the context of datatypes) and a function type
    out of a type of directions (which makes the direction-type the
    index type of the fields of a record, in the context of data
    types).

    That the function from the directions is implemented as a list
    rather than a function forces each direction-type to be finite,
    which in turn means that these terms can only represent types
    generated by _finitary_ polynomial functors.

    I am is parameterized on the type of its constructor so
    that different contexts may choose different representations of
    position-types.

    I myself may be viewed as the initial algebra of a polynomial functor.
    Specifically, for a given constructor type `ctor`, the position-type of
    that functor is `ctor x Nat`, and for each position `(c, n)`, my
    direction-type is `Fin n` (finite sets of size `n`).  (In particular it
    is itself manifestly finitary.)  We call this functor `termf` below.
    """

    @typedoc "I generate a generic polynomial term parameterized on a constructor type."
    @type termf(ctor, x) :: {ctor, [x]}

    @doc "I am the morphism-map component of the functor `termf`."
    @spec termf_map((a -> b), termf(ctor, a)) :: termf(ctor, b)
          when ctor: term, a: term, b: term
    def termf_map(f, {c, children}) do
      {c, Enum.map(children, f)}
    end

    @typedoc "Type of algebras of `termf`."
    @type termalg(ctor, x) :: (termf(ctor, x) -> x)

    # A functor which generates _open_ terms -- that is, terms
    # which may contain variables drawn from a type parameter.
    @typedoc "I generate open terms:  terms of `t` potentially containing variables."
    @type termfv(ctor, v, x) :: v | termf(ctor, x)

    @doc "I am the morphism-map component of the bifunctor `termfv(ctor)`."
    @spec termfv_bimap((v -> w), (x -> y), termfv(ctor, v, x)) ::
            termfv(ctor, w, y)
          when ctor: term, v: term, w: term, x: term, y: term
    def termfv_bimap(f, g, term) do
      case term do
        {c, children} when is_list(children) ->
          termf_map(g, {c, children})

        var ->
          f.(var)
      end
    end

    # I am the carrier of the initial algebra of `termfv(ctor, v)`, which is
    # guaranteed to have one because it is polynomial.  I comprise open terms
    # terms like those of `t` but potentially containing variables drawn from
    # type `v`.
    #
    # Viewed as a type constructor, I am the free monad of `termf`.
    @typedoc "A generic open polynomial term parameterized on constructor and variable types."
    @type tv(ctor, v) :: termfv(ctor, v, tv(ctor, v))

    # I am the action of the initial algebra of `termfv(ctor, v)`.
    # My implementation is trivial; I am here only to make it explicit
    # that `tv` _is_ an algebra.
    #
    # Because `termfv` uses Elixir's union types, I can accept either
    # a constructor term or a variable term without any kind of tag.
    # The two cases each correspond to universal morphisms:
    #  - My application to a variable term is the unit of the
    #    free/forgetful adjunction between the category of algebras
    #    of `termfv` (on the left) and Elixir's base category (on the right)
    #  - My application to a constructor term is the action component
    #    of the object-map component of the left adjoint of that adjunction
    @spec in_tv(termfv(ctor, v, tv(ctor, v))) :: tv(ctor, v)
          when ctor: term, v: term
    def in_tv(x) do
      x
    end

    # I am the inverse of the action of of the initial algebra of
    # `termfv(ctor, v)`; I must exist because that initial algebra
    # is a fixed point of the application of `termfv`.  I correspond
    # to pattern-matching.  Being the inverse of an algebra, I am a coalgebra.
    #
    # My implementation is trivial; I am here only to make it explicit
    # that `in_tv` has an inverse.
    @spec out_tv(tv(ctor, v)) :: termfv(ctor, v, tv(ctor, v))
          when ctor: term, v: term
    def out_tv(x) do
      x
    end

    # I am the initial algebra of `termf`, which is guaranteed to have
    # one because it is polynomial.  (Its catamorphism is defined below.)
    # I can be equivalently generated (and that is what we do here, to minimize
    # the number of explicitly-recursive types) by applying the free monad to
    # the initial object (i.e. the empty type).
    #
    # Because I am an "open" term with variable type `none()` -- that is,
    # no variables -- I am the type of _closed_ terms.
    @typedoc "I am a generic polynomial term parameterized on a constructor type."
    @type t(ctor) :: tv(ctor, none())

    @typedoc "An open natural polynomial term with variables of type `v`."
    @type nat_tv(v) :: tv(non_neg_integer(), v)

    @typedoc "An open polynomial term with Elixir atom constructors and variables of type `v`."
    @type atom_tv(v) :: tv(atom(), v)

    @typedoc "An open polynomial term with Nock atom constructors and variables of type `v`."
    @type nock_atom_tv(v) :: tv(Noun.noun_atom(), v)

    @typedoc "An open polynomial term with Nock noun constructors and variables of type `v`."
    @type nock_noun_tv(v) :: tv(Noun.t(), v)

    @typedoc "A generic polynomial term with natural-number constructors."
    @type nat_term :: t(non_neg_integer())

    @typedoc "A generic polynomial term with Elixir atom constructors."
    @type atom_term :: t(atom())

    @typedoc "A generic polynomial term with Nock atom constructors."
    @type nock_atom_term :: t(Noun.noun_atom())

    @typedoc "A generic polynomial term with Nock noun constructors."
    @type nock_noun_term :: t(Noun.t())

    @doc """
    I am the `eval` universal morphism -- the elimination rule for a
    free monad -- out of `NockPoly.Term.tv`.

    I am the right adjunct of the free/forgetful adjunction between the
    category of algebras of `termf` (on the left) and Elixir's base
    category (on the right).

    In addition to an open term, `eval` takes an algebra of the `termf`
    functor and a "substitution" function which maps variables to the return
    type.
    """
    @spec eval(termalg(ctor, r), (v -> r), tv(ctor, v)) :: r
          when ctor: term, v: term, r: term
    def eval(algebra, subst, term) do
      case term do
        {ctor, children} when is_list(children) ->
          results = Enum.map(children, &eval(algebra, subst, &1))
          algebra.({ctor, results})

        var ->
          subst.(var)
      end
    end

    # I am the algebra used to implement `tvmap` below.
    @spec tvmap_alg(termf(ctor, tv(ctor, b))) :: tv(ctor, b)
          when ctor: term, b: term
    def tvmap_alg(x) do
      in_tv(x)
    end

    # I am the substitution used to implement `tvmap` below.
    @spec tvmap_subst((a -> b), a) :: tv(ctor, b)
          when ctor: term, a: term, b: term
    def tvmap_subst(f, x) do
      f.(x)
    end

    # I am the morphism-map component of the left adjoint of the
    # free-algebra adjunction of `termfv` (the object-map component
    # is `in_tv` above).
    @spec tvmap((a -> b), tv(ctor, a)) :: tv(ctor, b)
          when ctor: term, a: term, b: term
    def tvmap(f, x) do
      eval(&tvmap_alg(&1), &tvmap_subst(f, &1), x)
    end

    @doc """
    I am the comultiplication (or "duplicate") for the free monad `tv`.

    Given a term of type `tv(ctor, v)`, I return a term of type
    `tv(ctor, tv(ctor, v))`.
    """
    @spec tv_comult(tv(ctor, v)) :: tv(ctor, tv(ctor, v))
          when ctor: term, v: term
    def tv_comult(term) do
      tvmap(&in_tv/1, term)
    end

    @doc """
    I am the join (or multiplication) for the free monad `tv`.

    Given a term of type `tv(ctor, tv(ctor, v))`, I return a term of type
    `tv(ctor, v)` by flattening the structure.
    """
    @spec tv_mult(tv(ctor, tv(ctor, v))) :: tv(ctor, v)
          when ctor: term, v: term
    def tv_mult(term) do
      eval(
        fn {ctor, children} -> {ctor, children} end,
        &Function.identity/1,
        term
      )
    end

    defmodule Unreachable do
      @moduledoc """
      This module contains a function specifically expected to be unreachable.
      We factor it out as a module so that we can tell test coverage to ignore it.
      """

      # A helper function for the specialization of `tv` to `t` which
      # uses the `none()` variable type.  This is effectively the
      # unique possible `subst` parameter to `eval` when `v` is `none()`.
      @dialyzer {:nowarn_function, unreachable_term: 1}
      @spec unreachable_term(none()) :: no_return()
      def unreachable_term(var) do
        raise "Variable in closed term encountered: #{inspect(var)}"
      end
    end

    @doc """
    I am the catamorphism (fold) -- the universal morphism out of
    an initial algebra -- for `NockPoly.Term.t`.

    `cata(term, algebra)` recursively folds the term by applying the given
    algebra function to each constructor along with the list of results from
    folding its children.

    The algebra should be a function of type `(ctor, [r]) -> r`,
    where `ctor` is the constructor type and `r` is an arbitrary result type.
    """
    @spec cata(t(ctor), termalg(ctor, r)) :: r when ctor: term, r: term
    def cata(term, algebra) do
      eval(algebra, &Unreachable.unreachable_term/1, term)
    end

    @doc """
    I return the maximum depth of the term as a natural number.

    Depth is 1 for a term with no children, and 0 for a variable.
    """
    @spec depth(tv(ctor, v)) :: non_neg_integer() when ctor: term, v: term
    def depth(term) do
      eval(
        fn {_ctor, results} -> 1 + Enum.max([0 | results]) end,
        fn _var -> 0 end,
        term
      )
    end

    @doc """
    I return the total number of constructors in the term
    (a variable contains no constructors).
    """
    @spec size(tv(ctor, v)) :: non_neg_integer() when ctor: term, v: term
    def size(term) do
      eval(
        fn {_ctor, results} -> 1 + Enum.sum(results) end,
        fn _var -> 0 end,
        term
      )
    end
  end

  defmodule FinPolyF do
    alias Term

    @moduledoc """
    I am the simplest form that we define of finitary polynomial functor.

    This specification is parameterized on an error type `e` (interpreted as
    the type of possible typecheck errors) and on a constructor type `ctor`. It
    is represented as a function from a constructor value to an either type,
    where the `:error` variant carries an error of type `e` and the `:ok` variant
    carries a natural number (representing the arity).
    """

    @typedoc "Typecheck function for constructors. Given a constructor of type `ctor`, returns either `{:error}` (invalid) or `{:ok, non_neg_integer()}` (valid, with the returned arity)."
    @type tspec(ctor) :: (ctor ->
                            {:invalid_constructor}
                            | {:ok, non_neg_integer()})

    @typedoc "Typecheck function for variables. Given a variable of type `v`, returns either `:ok` (valid) or `{:error, [:invalid_variable]}`."
    @type vspec(v) :: (v -> {:ok} | {:invalid_variable})

    @doc "A `vspec` which always succeeds (returning `:ok`)."
    @spec vspec_ok(v) :: :ok when v: term
    def vspec_ok(_v) do
      :ok
    end

    @typedoc """
    A combined specification for open terms.
    It is a pair of:
      - a constructor specification (tspec), and
      - a variable specification (vspec).
    """
    @type spec(ctor, v) :: {tspec(ctor), vspec(v)}

    @typedoc """
    The kinds of errors that can be produced by typecheck/2.

    * `{:invalid_constructor, ctor}` – the constructor is invalid.
    * `{:invalid_arity, ctor, expected, actual}` – the number of children does not match the expected arity.
    * `{:invalid_variable}` – the variable failed its check.
    """
    @type typecheck_error(ctor, v) ::
            {:invalid_constructor, ctor}
            | {:invalid_arity, ctor, non_neg_integer(), non_neg_integer()}
            | {:invalid_variable, v}

    @typedoc """
    The result of typechecking.

    It returns:
      * `:ok` when the term passes the typecheck.
      * `{:error, errors}` when errors are produced, where errors is a list of `typecheck_error`.
    """
    @type check_result(ctor, v) ::
            :ok | {:error, nonempty_list(typecheck_error(ctor, v))}

    @doc """
    Typechecks an open term given a combined specification.

    The combined specification is a pair `{tspec, vspec}`, where:
      • `tspec` is a function from a constructor to either
          `{:error, :invalid_constructor}` (invalid constructor)
        or `{:ok, non_neg_integer()}` (valid with the expected arity).
        If the number of children does not equal the expected arity, an error
        `{:invalid_arity, ctor, expected, actual}` is produced.
      • `vspec` is a function which typechecks variable nodes, returning either
        `:ok` or `{:error, :invalid_variable}`.

    For a constructor node, errors detected at this level are concatenated with errors
    from the children. If no errors occur, `:ok` is returned; otherwise, `{:error, errors}`.
    """

    @spec typecheck_v(
            Term.tv(ctor, v),
            {tspec(ctor), vspec(v)}
          ) :: check_result(ctor, v)
          when ctor: term, v: term
    def typecheck_v(term, {tspec, vspec}) do
      Term.eval(
        fn {ctor, child_results} ->
          children_count = length(child_results)

          level_errors =
            case tspec.(ctor) do
              {:invalid_constructor} ->
                [{:invalid_constructor, ctor}]

              {:ok, expected} ->
                if children_count != expected do
                  [{:invalid_arity, ctor, expected, children_count}]
                else
                  []
                end
            end

          children_errors =
            child_results
            |> Enum.flat_map(fn
              :ok -> []
              {:error, errs} -> errs
            end)

          errors = level_errors ++ children_errors

          if errors == [] do
            :ok
          else
            {:error, errors}
          end
        end,
        # Wrap the variable checker to convert any error to a singleton list.
        fn var ->
          case vspec.(var) do
            :ok -> :ok
            {:invalid_variable} -> {:error, [{:invalid_variable, var}]}
          end
        end,
        term
      )
    end

    @doc """
    I typecheck a *closed* term by wrapping `typecheck_v/2` with a vspec
    that always returns :ok.
    """
    @spec typecheck(Term.t(ctor), tspec(ctor)) ::
            check_result(ctor, none())
          when ctor: term
    def typecheck(term, tspec) do
      typecheck_v(term, {tspec, &vspec_ok/1})
    end
  end

  defmodule NockTerms do
    @moduledoc """
    I am a polynomial specification for Nock terms.

    A Nock term is a binary tree where:
      - An atom node is represented as `{:atom, noun}` (with `noun` having
        type Noun.noun_atom()).  Atoms have arity 0.
      - A cell node is represented as `:cell`.
        Cells have arity 2.

    All constructors are always valid (any term of type `Noun.noun_atom()` is
    a valid Nock atom).
    """

    alias Noun
    alias NockPoly.FinPolyF

    @type nock_term_ctor :: {:atom, Noun.noun_atom()} | :cell
    @type nock_poly_term :: Term.t(nock_term_ctor)

    @spec nock_tspec(nock_term_ctor) :: {:ok, non_neg_integer()}
    def nock_tspec({:atom, _noun}) do
      {:ok, 0}
    end

    def nock_tspec(:cell) do
      {:ok, 2}
    end

    @spec typecheck(nock_poly_term) ::
            FinPolyF.check_result(nock_term_ctor, none())
    def typecheck(term) do
      FinPolyF.typecheck(term, &nock_tspec/1)
    end

    @doc """
    I convert a Noun.t() into a Nock polynomial term (nock_poly_term).

    If `noun` satisfies Noun.is_noun_atom/1, it is wrapped as an atom;
    otherwise it must be a cell represented as a two-element list, which is
    recursively converted. This function always succeeds and produces a term
    that passes the Nock typecheck.
    """
    @spec from_noun(Noun.t()) :: nock_poly_term
    def from_noun(noun) do
      cond do
        Noun.is_noun_atom(noun) ->
          {{:atom, noun}, []}

        Noun.is_noun_cell(noun) ->
          case noun do
            [left | right] ->
              {:cell, [from_noun(left), from_noun(right)]}
          end
      end
    end

    @spec to_noun_algebra({nock_term_ctor, [Noun.t()]}) :: Noun.t()
    defp to_noun_algebra({ctor, results}) do
      case {ctor, results} do
        {{:atom, noun}, []} ->
          noun

        {:cell, [left, right]} ->
          [left | right]
      end
    end

    @doc """
    I convert a Nock polynomial term (nock_poly_term) back into a Noun.t().

    It is assumed that the term has successfully passed the Nock typecheck.
    I use `cata/2` (the catamorphism) so that I am not directly recursive.
    """
    @spec to_noun(nock_poly_term) :: Noun.t()
    def to_noun(term) do
      Term.cata(term, &to_noun_algebra/1)
    end
  end
end
