defmodule NockPoly do
  @moduledoc """
  Representations of polynomial functors in Elixir, and of Nock
  as a polynomial functor.
  """

  require Noun
  require Nock
  require Logger

  use TypedStruct

  defmodule Term do
    @moduledoc """

    I represent a term of any type which can be generated by the
    application of finitary polynomial functors -- in particular
    all finite products and coproducts.  I am a form of S-expression
    chosen to correspond to the application of polynomial functors --
    such an application produces a dependent pair of a position
    (which is effectively a constructor together with any of its
    parameters, in the context of datatypes) and a function type
    out of a type of directions (which makes the direction-type the
    index type of the fields of a record, in the context of data
    types).

    That the function from the directions is implemented as a list
    rather than a function forces each direction-type to be finite,
    which in turn means that these terms can only represent types
    generated by _finitary_ polynomial functors.

    This type is parameterized on the type of its constructor so
    that different contexts may choose different representations of
    position-types.
    """

    @typedoc "A generic polynomial term parameterized on a constructor type."
    @type t(ctor) :: {ctor, [t(ctor)]}

    @typedoc "A generic polynomial term with natural-number constructors."
    @type nat_term :: t(non_neg_integer())

    @typedoc "A generic polynomial term with Elixir atom constructors."
    @type atom_term :: t(atom())

    @typedoc "A generic polynomial term with Nock atom constructors."
    @type nock_atom_term :: t(Noun.noun_atom())

    @typedoc "A generic polynomial term with Nock noun constructors."
    @type nock_noun_term :: t(Noun.t())
  end
end
