<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anoma - Technical Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="explore/index.html"><strong aria-hidden="true">2.</strong> Exploration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/index.html"><strong aria-hidden="true">2.1.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/overview.html"><strong aria-hidden="true">2.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="explore/design/gossip.html"><strong aria-hidden="true">2.1.2.</strong> Gossip network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent_gossip.html"><strong aria-hidden="true">2.1.2.1.</strong> Intent gossip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent.html"><strong aria-hidden="true">2.1.2.1.1.</strong> intent</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/topic.html"><strong aria-hidden="true">2.1.2.1.2.</strong> topic</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/incentive.html"><strong aria-hidden="true">2.1.2.1.3.</strong> incentive</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/matchmaker.html"><strong aria-hidden="true">2.1.2.1.4.</strong> matchmaker</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/fungible_token.html"><strong aria-hidden="true">2.1.2.1.5.</strong> fungible token</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/dkg.html"><strong aria-hidden="true">2.1.2.2.</strong> Distributed key generation gossip</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/ledger.html"><strong aria-hidden="true">2.1.3.</strong> The ledger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/ledger/parameters.html"><strong aria-hidden="true">2.1.3.1.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/epochs.html"><strong aria-hidden="true">2.1.3.2.</strong> Epochs</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/accounts.html"><strong aria-hidden="true">2.1.3.3.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/vp.html"><strong aria-hidden="true">2.1.3.4.</strong> Validity predicates</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/tx.html"><strong aria-hidden="true">2.1.3.5.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/wasm-vm.html"><strong aria-hidden="true">2.1.3.6.</strong> WASM VM</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/front-running.html"><strong aria-hidden="true">2.1.3.7.</strong> Front-running prevention</a></li><li class="chapter-item expanded "><a href="explore/design/fractal-scaling.html"><strong aria-hidden="true">2.1.3.8.</strong> Fractal scaling</a></li><li class="chapter-item expanded "><a href="explore/design/upgrade-system.html"><strong aria-hidden="true">2.1.3.9.</strong> Upgrade system</a></li><li class="chapter-item expanded "><a href="explore/design/storage.html"><strong aria-hidden="true">2.1.3.10.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/data-schema.html"><strong aria-hidden="true">2.1.3.10.1.</strong> Data schema</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="explore/design/crypto-primitives.html"><strong aria-hidden="true">2.1.4.</strong> Crypto primitives</a></li><li class="chapter-item expanded "><a href="explore/design/actors.html"><strong aria-hidden="true">2.1.5.</strong> Actors</a></li></ol></li><li class="chapter-item expanded "><a href="explore/prototypes/index.html"><strong aria-hidden="true">2.2.</strong> Prototypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/prototypes/base-ledger.html"><strong aria-hidden="true">2.2.1.</strong> Base ledger</a></li><li class="chapter-item expanded "><a href="explore/prototypes/gossip-layer.html"><strong aria-hidden="true">2.2.2.</strong> Gossip layer</a></li></ol></li><li class="chapter-item expanded "><a href="explore/libraries/index.html"><strong aria-hidden="true">2.3.</strong> Libraries &amp; Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.1.</strong> Cryptography</div></li><li class="chapter-item expanded "><a href="explore/libraries/network.html"><strong aria-hidden="true">2.3.2.</strong> network</a></li><li class="chapter-item expanded "><a href="explore/libraries/cli.html"><strong aria-hidden="true">2.3.3.</strong> Command-line interface</a></li><li class="chapter-item expanded "><a href="explore/libraries/db.html"><strong aria-hidden="true">2.3.4.</strong> Database</a></li><li class="chapter-item expanded "><a href="explore/libraries/logging.html"><strong aria-hidden="true">2.3.5.</strong> Logging</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.6.</strong> Networking</div></li><li class="chapter-item expanded "><a href="explore/libraries/packaging.html"><strong aria-hidden="true">2.3.7.</strong> Packaging</a></li><li class="chapter-item expanded "><a href="explore/libraries/serialization.html"><strong aria-hidden="true">2.3.8.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="explore/libraries/wasm.html"><strong aria-hidden="true">2.3.9.</strong> WASM runtime</a></li><li class="chapter-item expanded "><a href="explore/libraries/errors.html"><strong aria-hidden="true">2.3.10.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/glossary.html"><strong aria-hidden="true">2.4.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="explore/resources/index.html"><strong aria-hidden="true">2.5.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/resources/ide.html"><strong aria-hidden="true">2.5.1.</strong> IDE</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="specs/index.html"><strong aria-hidden="true">3.</strong> Specifications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="specs/ledger.html"><strong aria-hidden="true">3.2.</strong> The ledger</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Trade system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Intent gossip system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Fractal scaling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Upgrade system</div></li><li class="chapter-item expanded "><a href="specs/encoding.html"><strong aria-hidden="true">3.7.</strong> Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="playnet/index.html"><strong aria-hidden="true">4.</strong> Playnet</a></li><li class="chapter-item expanded "><a href="archive/index.html"><strong aria-hidden="true">5.</strong> Archive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="archive/domain-name-addresses.html"><strong aria-hidden="true">5.1.</strong> Domain name addresses</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Anoma - Technical Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is written using <a href="https://rust-lang.github.io/mdBook/">mdBook</a> with <a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a> for diagrams, it currently lives in the <a href="https://github.com/anoma/anoma">Anoma repo</a>.</p>
<p>To get started quickly, one can:</p>
<pre><code class="language-shell"># Install dependencies
make dev-deps
# This will open the book in your default browser and rebuild on changes
make serve
</code></pre>
<p>The mermaid diagrams docs can be found at <a href="https://mermaid-js.github.io/mermaid">https://mermaid-js.github.io/mermaid</a>.</p>
<p>The initial purpose of this document is twofold. One is to document the process of exploring the design and implementation space for Anoma. The other is to describe its technical specifications. These correspond to the <a href="./explore">Exploration</a> and <a href="./specs">Specifications</a> sections of this book, respectively.</p>
<p>The Exploration section is more free-form. This is largely a cross-over of both the implementation details and the design of implementation-independent specifications.</p>
<p>The Specification section will be completely independent of the implementation details.</p>
<p>Contributions to the contents and the structure of this book (nothing is set in stone) should be made via pull requests. Code changes that diverge from the spec should also update this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploration"><a class="header" href="#exploration">Exploration</a></h1>
<p>This section documents the process of exploring the design and implementation space for Anoma. Ideally, the captured information should provide an overview of the explored space and help to guide further decisions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This section covers the exploration of the possible design directions of the involved components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<ul>
<li>TODO: add high-level interaction diagram(s)</li>
</ul>
<p>The Rust crates internal dependency graph:</p>
<p><img src="explore/design/./overview/crates.svg" alt="crates" title="crates" />
<a href="https://excalidraw.com/#room=e32fc914de750ed4f5e4,6CWRFjnmCoiFR4BQ6i9K4g">https://excalidraw.com/#room=e32fc914de750ed4f5e4,6CWRFjnmCoiFR4BQ6i9K4g</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gossip-network"><a class="header" href="#the-gossip-network">The gossip network</a></h1>
<p>The gossip network runs in parallel to the ledger network and is used to
propagate off-chain information. The network is based on
<a href="https://libp2p.io/">libp2p</a> , a peer to peer network system that is implemented
in different languages, has a large user base and an active development.  It
allows us to readily implement a network to run our application.</p>
<p>The gossip network is used to propagate messages of two different applications,
intents for the intent gossip system, and message for distributed keys
generation application.</p>
<ul>
<li><a href="explore/design/./intent_gossip.html">intent gossip</a></li>
<li><a href="explore/design/./dkg_gossip.html">distributed key generation</a></li>
</ul>
<h2 id="flow-diagram-high-level-overview"><a class="header" href="#flow-diagram-high-level-overview">Flow diagram: High level overview</a></h2>
<p><img src="explore/design/./gossip_process.svg" alt="gossip process" title="gossip process" /></p>
<p><a href="https://excalidraw.com/#room=5d4a2a84ef52cf5f5f96,r4ghl40frJ9putMy-0vyOQ">exilidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-network"><a class="header" href="#intent-gossip-network">Intent gossip network</a></h1>
<p>The intent gossip network enables counterparty discovery for bartering. The
users can express any sort of intents that might be matched and transformed into
a transaction that fulfills the intents on the Anoma ledger.</p>
<p>An <a href="explore/design/intent_gossip/./intent.html">intent</a> describes the desire of a user, from asset exchange to a
green tax percent for selling shoes. These intents are picked up by a matchmaker
that composes them into transactions to send to the ledger network. A matchmaker
is optionally included in the intent gossip node.</p>
<p>Each node connects to a specified intent gossip network, either a public or a
private one. Anyone can create their own network where they decide all aspects
of it: which type of intents is propagated, which nodes can participate, the
matchmaker logic, etc. It is possible, for example, to run the intent gossip system
over bluetooth to have it off-line.</p>
<p>An intent gossip node is a peer in the intent gossip network that has the role
of propagating intents to all other connected nodes.</p>
<p>The network uses the
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
network behaviour. This system aggregates nodes around topics of interest. Each
node subscribes to a set of topics and connects to other nodes that are also
subscribed to the same topics. A topic defines a sub-network for a defined
interest, e.g. “asset_exchange”. see
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
for more information on the network topology.</p>
<p>Each node has an incentive to propagate intents and will obtain a small portion
of the fees if the intent is settled. [TODO: update when logic is found] See
<a href="explore/design/intent_gossip/./incentive.html">incentive</a> for more information.</p>
<h3 id="flow-diagram-asset-exchange"><a class="header" href="#flow-diagram-asset-exchange">Flow diagram: asset exchange</a></h3>
<p>This example shows three intents matched together by the intent gossip network.
These three intents express user desires to exchange assets.</p>
<p><img src="explore/design/intent_gossip/./example.svg" alt="intent gossip and ledger network interaction" title="intent gossip network" />
<a href="https://excalidraw.com/#room=257e44f4b4b5867bf541,XDEKyGVIpqCrfq55bRqKug">exilidraw link</a></p>
<h1 id="flow-diagram-life-cycle-of-intent-and-global-process"><a class="header" href="#flow-diagram-life-cycle-of-intent-and-global-process">Flow diagram: life cycle of intent and global process</a></h1>
<p>This diagram shows the process flow for intents, from users expressing their
desire to the ledger executing the validity predicate to check the crafted
transaction.</p>
<p><img src="explore/design/intent_gossip/./intent_life_cycle.svg" alt="intent life cycle" title="intent life
cycle" /> <a href="https://excalidraw.com/#room=7ac107b3757c64049003,cdMInfvdLtjaGWSZWEKrhw">exilidraw
link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intents"><a class="header" href="#intents">Intents</a></h1>
<p>An intent is a way of expressing a user's desire. It is defined as arbitrary
data and an optional address for a schema. The data is as arbitrary as possible
to allow the users to express any sort of intent. It could range from defining a
selling order for a specific token to offering piano lessons or even proposing a
green tax for shoes’ manufacturers.</p>
<p>An intent is written using an encoding, or data schema. The encoding exists
either on-chain or off-chain. It must be known by users that want to express
similar intents. It also must be understood by some matchmaker. Otherwise, it 
possibly won’t be  matched. The user can define its own schema and inform either 
off-chain or on-chain. Having it on-chain allows it to easily share it with other
participants. Please refer to <a href="explore/design/intent_gossip/./../data-schema.html">data schema</a> for more
information about the usage of on-chain schema.</p>
<hr />
<p>There is only a single intent type that is composed of arbitrary data and a
possible schema definition.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Intent {
    schema: Option&lt;Key&gt;,
    data: Vec&lt;u8&gt;,
    timestamp: Timestamp
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic"><a class="header" href="#topic">Topic</a></h1>
<p>A topic is string and an encoding that describes this sub-network. In a topic
all intents use the exact same encoding. That encoding is known by matchmakers
so it can decode them to find matches. Whenever a node subscribes to a new topic
it informs all connected nodes and each of them propagate it. With this it’s
easy to create new topics in the intent gossip network and inform others.</p>
<p>Other nodes can choose to subscribe to a new topic with the help of a
filter. This filter is defined as a combination of a whitelist, a regex
expression, and a maximum limit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incentive"><a class="header" href="#incentive">Incentive</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/37">Tracking Issue</a></p>
<hr />
<p>TODO</p>
<ul>
<li>describe incentive function</li>
<li>describe logic to ensure matchmaker can't cheat intent gossip service</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matchmaker"><a class="header" href="#matchmaker">Matchmaker</a></h1>
<p>The matchmaker is a specific actor in the intent gossip network that tries to
match intents together. When intents are matched together, the matchmaker crafts
a transaction from them and sends it to the ledger network.</p>
<p>A matchmaker is an intent gossip node started with additional parameters: a
ledger address and a list of sub-matchmakers. A sub-matchmaker is defined with a
topics list, a main program path, a filter program path, and a transaction code.</p>
<p>The main and filter programs are wasm compiled code. Each has a defined
entrypoint and their own set of environment functions that they can call.</p>
<p>When the matchmaker receives a new intent from the network it calls the
corresponding sub-matchmaker, the one that has the intent’s topic in their
topics list. A sub-matchmaker first checks if the intent is accepted by the
filter, before adding it to that sub-matchmaker database. Then the main program
is called with the intent and current state.</p>
<h2 id="sub-matchmaker-topics-list"><a class="header" href="#sub-matchmaker-topics-list">Sub-matchmaker topics' list</a></h2>
<p>A sub-matchmaker is defined to work with only a subset of encoding. Each intent
propagated to the corresponding topic will be process by this sub-matchmaker.</p>
<p>Having a topics list instead of a unique topic allows a matchmaker to match
intents from different encodings. For example, when an updated version of an
encoding is out, the matchmaker could match intents from both versions if they
don’t diverge too much.</p>
<h2 id="sub-matchmaker-database-and-state-name-tbd"><a class="header" href="#sub-matchmaker-database-and-state-name-tbd">Sub-matchmaker database and state (name TBD)</a></h2>
<p>Each sub-matchmaker has a database and an arbitrary state.</p>
<p>The database contains intents received by the node from the topics list that
passed the filter.</p>
<p>The state is arbitrary data that is managed by the main program. That state is
given to all calls in the main program.</p>
<p>The database is persistent but the state is not. When a node is started the
state is recovered by giving all intents from the database to the main program.
The invariant that the current state is equal to the state if the node is
restarted is not enforced and is the responsibility of the main program.</p>
<h2 id="filter-program"><a class="header" href="#filter-program">Filter program</a></h2>
<p>The filter is an optional wasm program given in parameters. This filter is used
to check each intent received by that sub-matchmaker. If it's not defined,
intents are directly passed to the main program.</p>
<p>The entrypoint <code>filter_intent</code> takes an intent and returns a boolean. The
filter has the ability to query the state of the ledger for any given key.</p>
<h2 id="main-program"><a class="header" href="#main-program">Main program</a></h2>
<p>The main program is a mandatory wasm program given in parameters. The main
program must match together intents.</p>
<p>The main program entrypoint <code>match_intent</code> takes the current state, a new intent
data and its id. The main program also has the ability to query the state of the
ledger. It also has functions <code>remove</code> and <code>get</code> to interact with the matchmaker
mempool. When a main matchmaker program finds a match it sends a transaction to
the ledger composed of the code template given in the matchmaker parameter and
the data given to this function. Finally the matchmaker must update its state so
the next run will have up to date values.</p>
<p>The main program is called on two specific occasion; when intent gossip node is
started, on all intent from database and whenever a new intent is received from
the p2p network and the RPC endpoint, if enabled.</p>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>The transaction code given in parameters is used when the main program matches a
group of intents. The main program returns arbitrary data that is attached to
the transaction which is then injected into a ledger node.</p>
<h2 id="flow-diagram-matchmaker-process"><a class="header" href="#flow-diagram-matchmaker-process">Flow diagram: Matchmaker process</a></h2>
<p><img src="explore/design/intent_gossip/./matchmaker_process.svg" alt="matchmaker process" title="matchmaker process" /></p>
<p><a href="https://excalidraw.com/#room=92b291c13cfab8fb22a4,OvHfWIrL0jeDzPI-EFZMaw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fungible-token-encoding-and-template"><a class="header" href="#fungible-token-encoding-and-template">Fungible token encoding and template</a></h1>
<p>The Heliax team implemented an intent encoding, a filter program template, and a
matchmaker program template that can be used to exchange fungible tokens between
any number of participants.</p>
<h2 id="intent-encoding"><a class="header" href="#intent-encoding">Intent encoding</a></h2>
<p>The intent encoding allows the expression of a desire to participate in an asset
exchange. The encoding is defined as follows :</p>
<pre><code class="language-protobuf">message FungibleToken {
  string address = 1;
  string token_sell = 2;
  int64 max_sell = 3;
  int64 rate_min = 4;
  string token_buy = 5;
  int64 min_buy = 6;
  google.protobuf.Timestamp expire = 7;
}
</code></pre>
<h2 id="matchmaker-program"><a class="header" href="#matchmaker-program">Matchmaker program</a></h2>
<p>The filter program attempts to decode the intent and if successful, checks
that it's not yet expired and that the account address has enough funds for the
intended token to be sold.</p>
<p>The main program can match intents for exchanging assets. It does that by
creating a graph from all intents. When a cycle is found then it removes all
intents from that cycle of the mempool and crafts a transaction based on all the
removed intents.</p>
<p><img src="explore/design/intent_gossip/matchmaker_graph.svg" alt="matchmaker" />
<a href="https://excalidraw.com/#room=1db86ba6d5f0ccb7447c,2vvRd4X2Y3HDWHihJmy9zw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-key-generation-gossip"><a class="header" href="#distributed-key-generation-gossip">Distributed key generation gossip</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger"><a class="header" href="#the-ledger">The ledger</a></h1>
<p>The ledger depends on <a href="https://github.com/tendermint/tendermint">Tendermint node</a>. Running the Anoma node will also initialize and run Tendermint node. Anoma communicates with Tendermint via the ABCI.</p>
<h2 id="tendermint-abci"><a class="header" href="#tendermint-abci">Tendermint ABCI</a></h2>
<p>We are using the Tendermint state-machine replication engine via ABCI. It provides many useful things, such as a BFT consensus protocol, P2P layer with peer exchange, block sync and mempool layer.</p>
<p>Useful resources:</p>
<ul>
<li>Tendermint ABCI <a href="https://docs.tendermint.com/master/spec/abci/">https://docs.tendermint.com/master/spec/abci/</a></li>
<li>Tendermint RPC reference <a href="https://docs.tendermint.com/master/rpc/">https://docs.tendermint.com/master/rpc/</a></li>
<li>Awesome collection <a href="https://github.com/tendermint/awesome">https://github.com/tendermint/awesome</a></li>
</ul>
<p>Rust ABCI implementations:</p>
<ul>
<li><a href="https://github.com/informalsystems/tendermint-rs">https://github.com/informalsystems/tendermint-rs</a>
<ul>
<li>the future update planned for this crate is to add async support</li>
<li>longer term the goal is to be able to <a href="https://github.com/informalsystems/tendermint-rs/issues/29#issuecomment-672444401">seamlessly switch from Go Tendermint
to Rust Tendermint</a></li>
<li>includes RPC and light-client libraries</li>
</ul>
</li>
<li><a href="https://github.com/devashishdxt/abci-rs">https://github.com/devashishdxt/abci-rs</a>
<ul>
<li>async support</li>
</ul>
</li>
<li><a href="https://github.com/tendermint/rust-abci">https://github.com/tendermint/rust-abci</a>
<ul>
<li>deprecated in favor of informalsystems/tendermint-rs</li>
</ul>
</li>
</ul>
<h3 id="abci-integration"><a class="header" href="#abci-integration">ABCI Integration</a></h3>
<p>The ledger wraps the Tendermint node inside the Anoma node. The Tendermint node
communicates with the Anoma shell via four layers as illustrated below.</p>
<pre class="mermaid">flowchart LR
    C[Client] --- R
    subgraph Anoma Node
    S((Anoma Shell))
    subgraph Tendermint ABCI
    R[RPC] === T{Tendermint}
    T --- TC[Consensus]
    T --- TM[Mempool]
    T --- TQ[Query]
    T --- TS[Snapshot]
    end
    TC --- S
    TM --- S
    TQ --- S
    TS --- S
    end
</pre>
<p>The <em>consensus</em> connection allows the shell to:</p>
<ul>
<li>initialize genesis on start-up</li>
<li>begin a block</li>
<li>apply a transaction(s) in a block</li>
<li>end a block</li>
<li>commit a block</li>
</ul>
<p>The <em>mempool</em> connection asks the shell to validate transactions before they get
stored in the mempool and broadcasted to peers. The mempool will signify that
the transaction is either new, when it has not been validated before, or to be
re-checked when it has been validated at some previous level.</p>
<p>The <em>query</em> connection is used for:</p>
<ul>
<li>the Tendermint node asks the last known state from the shell to determine if it needs to replay any blocks</li>
<li>relay client queries for some state at a given path to the shell</li>
</ul>
<p>The <em>snapshot</em> connection is used to serve state sync snapshots for other nodes and/or restore state sync snapshots to a local node being bootstrapped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<p>The parameters are used to dynamically control certain variables in the protocol. They are implemented as an internal address with a native VP. The current values are written into and read from the block storage in the parameters account's sub-space.</p>
<p>Initial parameters for a chain are set in the genesis configuration. On chain, these can be changed by 2/3 of voting power (specifics are TBA).</p>
<h2 id="epoch-duration"><a class="header" href="#epoch-duration">Epoch duration</a></h2>
<p>The parameters for <a href="explore/design/ledger/./epochs.html">epoch</a> duration are:</p>
<ul>
<li>Minimum number of blocks in an epoch</li>
<li>Minimum duration of an epoch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epochs"><a class="header" href="#epochs">Epochs</a></h1>
<p>An epoch is a range of blocks whose length is determined by the <a href="explore/design/ledger/./parameters.html#epoch-duration">epoch duration protocol parameter</a>: minimum epoch duration and minimum number of blocks in an epoch. They are identified by consecutive natural numbers starting at 0.</p>
<p>We store the current epoch in global storage and the epoch of each block in the block storage. We also store the minimum height and minimum time of a first block in the next epoch in global storage, so that changes to the epoch duration protocol parameter don't affect the current epoch, but rather apply from the following epoch. Note that protocol parameters changes may themselves be delayed.</p>
<p>The first epoch (ID 0) starts on the genesis block. The next epoch minimum start time is set to the genesis time configured for the chain + minimum duration and the next epoch minimum height is set to the height of the genesis block (typically 1) + minimum number of blocks.</p>
<p>On each block <code>BeginBlock</code> Tendermint call, we check if the current epoch is finished, in which case we move on to the next epoch. An epoch is finished when both the minimum number of blocks and minimum duration of an epoch have been created from the first block of a current epoch. When a new epoch starts, the next epoch minimum height is set to the block's height + minimum number of blocks and minimum start time time is set to block's time from the block header + minimum duration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/45">Tracking Issue</a></p>
<hr />
<p>There's only a single account type. Each account is associated with:</p>
<ul>
<li>a unique <a href="explore/design/ledger/accounts.html#addresses">address</a></li>
<li>a <a href="explore/design/ledger/./vp.html">validity predicate</a></li>
<li><a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">dynamic storage sub-space</a></li>
</ul>
<h2 id="addresses"><a class="header" href="#addresses">Addresses</a></h2>
<p>There are two main types of address: transparent and shielded.</p>
<p>The transparent addresses are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>The shielded addresses are used for private transactions and they are not directly associated with storage sub-spaces.</p>
<h3 id="transparent-addresses"><a class="header" href="#transparent-addresses">Transparent addresses</a></h3>
<p>Furthermore, there are three types of transparent addresses:</p>
<ul>
<li>&quot;implicit&quot; addresses which are derived from public keys</li>
<li>&quot;established&quot; addresses which are generated from the current address nonce and hence must be created via a request in the ledger</li>
<li>&quot;internal&quot; addresses are used for special modules integrated into the ledger such as PoS and IBC.</li>
</ul>
<p>The addresses are stored on-chain encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a> (<a href="https://github.com/zcash/zips/issues/484">not yet adopted in Zcash</a>), which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>.</p>
<p>The human-readable prefix (as specified for <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#specification">bech32</a>) in the address encoding is:</p>
<ul>
<li><code>&quot;a&quot;</code> for Anoma live network</li>
<li><code>&quot;atest&quot;</code> for test network</li>
</ul>
<h4 id="implicit-transparent-addresses"><a class="header" href="#implicit-transparent-addresses">Implicit transparent addresses</a></h4>
<p>As implied by their name, accounts for implicit addresses exist as a possibility and not as a matter of fact. These addresses allow users to interact with public keys which may or may not have a registered on-chain account, e.g. allowing to send some fungible token to an address derived from a public key. An implicit address is derived from a hash of a public key, which also helps to protect keys for which the public key has not been revealed publicly.</p>
<h4 id="established-transparent-addresses"><a class="header" href="#established-transparent-addresses">Established transparent addresses</a></h4>
<p>Established addresses are created by a ledger transaction, which can create any number of new account addresses. The users are not in control of choosing the address as it's derived from the current address nonce, which is changed after every newly established address.</p>
<h4 id="internal-transparent-addresses"><a class="header" href="#internal-transparent-addresses">Internal transparent addresses</a></h4>
<p>There will be a static set of internal addresses that integrate certain functionality into the ledger via a dedicated module, such as the proof-of-stake module and the IBC module. The internal accounts use <a href="explore/design/ledger/vp.html#native-vps">native validity predicates</a> to validate transactions that interact with their module. A native module will use the <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">dynamic storage sub-space</a> to store all the data relevant to their functionality (e.g. PoS parameters, bond pool, IBC state and proofs).</p>
<h3 id="shielded-addresses"><a class="header" href="#shielded-addresses">Shielded addresses</a></h3>
<p>Similar to <a href="https://raw.githubusercontent.com/zcash/zips/master/protocol/protocol.pdf">Zcash Sapling protocol payment addresses and keys (section 3.1)</a>, users can generate spending keys for private payments. A shielded payment address, incoming viewing key and full viewing key are derived from a spending key. In a private payment, a shielded payment address is hashed with a diversifier into a diversified transmission key. When a different diversifier function is chosen for different transactions, it prevents the transmission key from being matched across the transactions.</p>
<p>The encoding of the shielded addresses, spending and viewing keys is not yet decided, but for consistency we'll probably use a the same schema with different prefixes for anything that can use an identifier.</p>
<ul>
<li>TODO consider using a schema similar to the <a href="https://github.com/zcash/zips/issues/482">unified addresses proposed in Zcash</a>, that are designed to unify the payment addresses across different versions by encoding a typecode and the length of the payment address together with it. This may be especially useful for the protocol upgrade system and fractal scaling system.</li>
</ul>
<h2 id="dynamic-storage-sub-space"><a class="header" href="#dynamic-storage-sub-space">Dynamic storage sub-space</a></h2>
<p>Each account can have an associated dynamic account state in the storage. This
state may be comprised of keys of the built-in supported types and values of arbitrary user bytes.</p>
<p>The dynamic storage sub-space could be a unix filesystem-like tree under the
account's address key-space with <code>read, write, delete, has_key, iter_prefix</code>
(and maybe a few other convenience functions for hash-maps, hash-sets, optional values, etc.) functions parameterized with the the account's address.</p>
<p>In addition, the storage sub-space would provide:</p>
<ul>
<li>a public type/trait for storage keys and key segments:
<ul>
<li>this should allow to turn types to storage key segments, key segments back to types</li>
<li>combine key segments into keys</li>
<li>can be extended with custom types in the code in a transaction</li>
</ul>
</li>
<li>a public type/trait for storage values:
<ul>
<li>values need to implement encoding traits, e.g. <code>BorshSerialize, BorshDeserialize</code>
<ul>
<li>this allows composition of types as specified for <a href="https://borsh.io">Borsh</a></li>
<li>the Merkle tree hashing function should hash values from the encoded bytes of this trait (the encoded value may be cached, because we update the Merkle tree in-memory before we commit the finalized block to the DB)</li>
</ul>
</li>
</ul>
</li>
<li>functions to get the size of a key and an encoded value (for storage fees)</li>
<li>the updates to account storage should be immediately visible to the transaction that performed the updates
<ul>
<li>validity predicate modifications have to be handled a little differently -
the old validity predicate should be run to check that the new validity
predicate (and other state changes included in the transaction) is valid</li>
</ul>
</li>
</ul>
<h2 id="initializing-a-new-account"><a class="header" href="#initializing-a-new-account">Initializing a new account</a></h2>
<p>A new account can be initialized on-chain with a transaction:</p>
<ul>
<li>anything be written into its storage (initial parameter)</li>
<li>a validity predicate has to be provided (we can have a default out-of-band)</li>
<li>at minimum, accounts need to be enumerated on chain, this could be done with an address or a counter</li>
</ul>
<p>A newly created account should be validated by all the VPs triggered by the transaction, i.e. it should be included in the set of changed keys passed to each VP. If the VPs are not interested in the newly created account, they can choose to ignore it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validity-predicates"><a class="header" href="#validity-predicates">Validity predicates</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/44">Tracking Issue</a></p>
<hr />
<p>Each <a href="explore/design/ledger/accounts.html">account</a> is associated with exactly one validity predicate (VP).</p>
<p>Conceptually, a VP is a function from the transaction's data and the storage state prior and posterior to a transaction execution returning a boolean value. A transaction may modify any data in the <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>. Upon <a href="explore/design/ledger/tx-execution.html">execution</a>, the VPs associated with the accounts whose storage has been modified are invoked to verify the transaction. If any of them reject the transaction, all of its storage modifications are discarded.</p>
<p>There are some native VPs for <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal transparent addresses</a> that are built into the ledger. All the other VPs are implemented as <a href="explore/design/ledger/wasm-vm.html">WASM programs</a>. One can build a custom VP using the <a href="https://github.com/anoma/anoma/tree/master/vps/vp_template">VP template</a> or use one of the pre-defined VPs.</p>
<p>The VPs must implement the following interface that will be invoked by the protocol:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_tx(
    // Data of the transaction that triggered this VP call
    tx_data: Vec&lt;u8&gt;,
    // Address of this VP
    addr: Address,
    // Storage keys that have been modified by the transation, relevant to this VP
    keys_changed: HashSet&lt;storage::Key&gt;,
    // Set of all the addresses whose VP was triggered by the transaction
    verifiers: HashSet&lt;Address&gt;,
) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>The host functions available to call from inside the VP code can be found in <a href="https://anoma.github.io/anoma/rustdoc/anoma_vm_env/imports/vp/index.html#functions">docs generated from code</a>.</p>
<h2 id="native-vps"><a class="header" href="#native-vps">Native VPs</a></h2>
<p>The native VPs follow the same interface as WASM VPs and rules for how they are <a href="explore/design/ledger/tx.html#tx-execution">triggered by a transaction</a>. They can also call the same host functions as those provided in <a href="explore/design/ledger/wasm-vm.html#vps-environment">WASM VPs environment</a> and must also account any computation for gas usage.</p>
<h2 id="fungible-token-vp"><a class="header" href="#fungible-token-vp">Fungible token VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_token.wasm">fungible token VP</a> allows to associate accounts balances of a specific token under its account. </p>
<p>For illustration, users <code>Albert</code> and <code>Bertha</code> might hold some amount of token with the address <code>XAN</code>. Their balances would be stored in the <code>XAN</code>'s storage sub-space under the storage keys <code>@XAN/balance/@Albert</code> and <code>@XAN/balance/@Bertha</code>, respectively. When <code>Albert</code> or <code>Bertha</code> attempt to transact with their <code>XAN</code> tokens, its validity predicate would be triggered to check:</p>
<ul>
<li>the total supply of <code>XAN</code> token is preserved (i.e. inputs = outputs)</li>
<li>the senders (users whose balance has been deducted) are checked that their validity predicate has also been triggered</li>
</ul>
<p>Note that the fungible token VP doesn't need to know whether any of involved users accepted or rejected the transaction, because if any of the involved users rejects it, the whole transaction will be rejected.</p>
<h2 id="user-vp"><a class="header" href="#user-vp">User VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_user.wasm">user VP</a> currently provides a signature verification against a public key for sending tokens as prescribed by the fungible token VP. In this VP, a transfer of tokens doesn't have to be authorized by the receiving party. </p>
<p>It also allows arbitrary storage modifications to the user's sub-space to be performed by a transaction that has been signed by the secret key corresponding to the user's public key stored on-chain. This functionality also allows one to update their own validity predicate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/43">Tracking Issue</a></p>
<hr />
<p>There is only a single general transaction (tx) type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Transaction {
    // A wasm module with a required entrypoint
    code: Vec&lt;u8&gt;
    // Optional arbitrary data
    data: Option&lt;Vec&lt;u8&gt;&gt;,
    // A timestamp of when the transaction was created
    timestamp: Timestamp,
    gas_limit: TODO,
}
<span class="boring">}
</span></code></pre></pre>
<p>The tx allows to include arbitrary <code>data</code>, e.g zero-knowledge proofs and/or arbitrary nonce bytes to obfuscate the tx's minimum encoded size that may be used to derive some information about the tx.</p>
<p>TODO once we have DKG, we will probably want to have some kind of a wrapper transaction with submission fees, payer and signature</p>
<h2 id="tx-life-cycle"><a class="header" href="#tx-life-cycle">Tx life cycle</a></h2>
<pre class="mermaid">flowchart TD
    subgraph Node
    I[Initialize chain] --&gt; Begin
    Begin[Begin block] --&gt; Poll
    Poll[Poll mempool queue] --&gt; Apply
    Apply[Apply txs] --&gt; End
    End[End block] --&gt; Commit[Commit block]
    Commit --&gt; Begin
    Commit --&gt; Flush
      subgraph Mempool
      Validate --&gt; V{is valid?}
      V --&gt;|Yes| Add[Add to local queue]
      V --&gt;|No| Fail[Drop tx]
      Flush --&gt;|Re-validate txs not included in this block| V
      end
    end
    subgraph Client
    Submit[Submit tx] --&gt; Validate
    end
</pre>
<p>New txs are injected by the client via mempool. Before including a tx in a local mempool queue, some cheap validation may be performed. Once a tx is included in a mempool queue, it will be gossiped with the peers and may be included in a block by the block proposer. Any txs that are left in the queue after flush will be subject to re-validation before being included again.</p>
<p>The order of applying transactions within a block is fixed by the block proposer in <a href="explore/design/ledger//explore/design/ledger/front-running.html">the front-running prevention protocol</a>.</p>
<p>TODO we might want to randomize the tx order after DKG protocol is completed</p>
<h3 id="block-application"><a class="header" href="#block-application">Block application</a></h3>
<p>Within a block, each tx is applied sequentially in three steps:</p>
<pre class="mermaid">flowchart TD
    B[Begin block] --&gt; N{Has next tx and within block gas limit?}
    N --&gt; |Yes|E
    N -----&gt; |No|EB[End block]
    E[Exec tx code] --&gt;|&quot;∀ accounts with modified storage&quot;| VP[Run validity predicates in parallel]
    VP --&gt; A{all accept}
    A --&gt; |No|R[Reject tx]
    A --&gt; |Yes|C[Commit tx and state changes]
    R --&gt; N
    C --&gt; N

</pre>
<h2 id="tx-execution"><a class="header" href="#tx-execution">Tx execution</a></h2>
<p>The code is allowed to read and write anything from <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' sub-spaces</a> and to <a href="explore/design/ledger/./accounts.html#initializing-a-new-account">initialize new accounts</a>. Other data that is not in an account's subspace is read-only, e.g. chain and block metadata, account addresses and potentially keys.</p>
<p>In addition to the verifiers specified in a transaction, each account whose sub-space has been modified by the tx triggers its VP.</p>
<p>For <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal addresses</a>, we invoke their module's native VP interface directly. For other addresses, we look-up validity predicates WASM to be executed from storage.</p>
<p>The VPs are then given the prior and posterior state from the account's sub-space together with the tx to decide if it accepts the tx's state modifications.</p>
<p>Within a single tx the execution of the validity predicates will be parallelized and thus the fee for VPs execution would their maximum value (plus some portion of the fees for each of the other parallelized VPs - nothing should be &quot;free&quot;). Once any of the VPs rejects the modifications, execution is aborted, the transaction is rejected and state changes discarded. If all the VPs accept the modifications, the transaction is successful and modifications are committed to storage as the input of the next tx.</p>
<p>The transaction's API should make it possible to transfer tokens to a hash of a public key that is not revealed. This could be done by having a &quot;deposit&quot; account from which the key's owner can claim the deposited funds.</p>
<p>Should some type of token prefer not to allow to receive tokens without recipient's approval, a token account can implement logic to decline the received tokens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-vm"><a class="header" href="#wasm-vm">WASM VM</a></h1>
<p>A wasm virtual machine will be used for <a href="explore/design/ledger/./vp.html">validity predicates</a> and <a href="explore/design/ledger/./tx-execution.html">transactions code</a>. </p>
<p>The VM should provide:</p>
<ul>
<li>an interface for compiling from higher-level languages to wasm (initially only Rust)</li>
<li>a wasm compiler, unless we use <a href="explore/design/ledger//explore/libraries/wasm.html">an interpreted runtime</a></li>
<li>provide and inject <a href="explore/design/ledger/wasm-vm.html#wasm-environment">environments for higher-level languages for VPs and transactions</a></li>
<li>pre-process wasm modules
<ul>
<li>check &amp; sanitize modules</li>
<li>inject gas metering</li>
<li>inject stack height metering</li>
</ul>
</li>
<li>a runner for VPs and transaction code</li>
<li>encode/decode wasm for transfer &amp; storage</li>
<li><a href="explore/design/ledger/wasm-vm.html#wasm-memory">manage runtime memory</a></li>
<li>wasm development helpers</li>
<li>helpers to estimate gas usage</li>
<li>VM and environment versioning</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://webassembly.github.io/spec/">WebAssembly Specifications</a></li>
<li><a href="https://docs.wasmer.io/integrations/examples">wasmer examples</a></li>
<li><a href="https://github.com/webassembly/wabt/">The WebAssembly Binary Toolkit</a>
<ul>
<li>bunch of useful wasm tools (e.g. <code>wasm2wat</code> to convert from wasm binary to human-readable wat format) </li>
</ul>
</li>
<li><a href="https://github.com/rustwasm/team">Rust wasm WG</a> and <a href="https://rustwasm.github.io/book/introduction.html">wasm book</a> (some sections are JS specific)</li>
<li><a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/">A practical guide to WebAssembly memory</a> modulo JS specific details</li>
<li><a href="https://learnxinyminutes.com/docs/wasm/">Learn X in Y minutes Where X=WebAssembly</a></li>
</ul>
<h2 id="wasm-environment"><a class="header" href="#wasm-environment">Wasm environment</a></h2>
<p>The wasm environment will most likely be libraries that provide APIs for the wasm modules.</p>
<h3 id="common-environment"><a class="header" href="#common-environment">Common environment</a></h3>
<p>The common environment of VPs and transactions APIs:</p>
<ul>
<li>math &amp; crypto</li>
<li>logging</li>
<li>panics/aborts</li>
<li>gas metering</li>
<li>storage read-only API</li>
<li>context API (chain metadata such as block height)</li>
</ul>
<p>The accounts sub-space storage is described under <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>.</p>
<h3 id="vps-environment"><a class="header" href="#vps-environment">VPs environment</a></h3>
<p>Because VPs are stateless, everything that is exposed in the VPs environment should be read-only:</p>
<ul>
<li>storage API to account sub-space the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
<li>transaction API</li>
</ul>
<h3 id="transactions-environment"><a class="header" href="#transactions-environment">Transactions environment</a></h3>
<ul>
<li>storage write access for all public state via the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
</ul>
<p>Some exceptions as to what can be written are given under <a href="explore/design/ledger/./tx.html#tx-execution">transaction execution</a>.</p>
<h2 id="wasm-memory"><a class="header" href="#wasm-memory">Wasm memory</a></h2>
<p>The wasm memory allows to share data bi-directionally between the host (Rust shell) and the guest (wasm) through a <a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-meminst">wasm linear memory instance</a>.</p>
<p>Because <a href="https://webassembly.github.io/spec/core/syntax/types.html">wasm currently only supports basic types</a>, we need to choose how to represent more sophisticated data in memory.</p>
<p>The options on how the data can be passed through the memory are:</p>
<ul>
<li>using <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc">&quot;C&quot; structures</a> (probably too invasive because everything in memory would have to use C repr)</li>
<li>(de)serializing the data with some encoding (JSON, binary, ...?)</li>
<li>currently very unstable: <a href="https://developer.mozilla.org/en-US/docs/Glossary/WebIDL">WebIDL</a> / <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">Interface Types</a> / <a href="https://github.com/WebAssembly/reference-types">Reference types</a></li>
</ul>
<p>The choice should allow for easy usage in wasm for users (e.g. in Rust a bindgen macro on data structures, similar to <a href="https://github.com/rustwasm/wasm-bindgen">wasm_bindgen used for JS &lt;-&gt; wasm</a>).</p>
<p>Related <a href="https://github.com/wasmerio/wasmer/issues/315">wasmer issue</a>.</p>
<p>We're currently using borsh for storage serialization, which is also a good option for wasm memory. </p>
<ul>
<li>it's easy for users (can be derived)</li>
<li>because borsh encoding is safe and consistent, the encoded bytes can also be used for Merkle tree hashing</li>
<li>good performance, although it's not clear at this point if that may be negligible anyway</li>
</ul>
<h3 id="the-data"><a class="header" href="#the-data">The data</a></h3>
<p>The data being passed between the host and the guest in the order of the execution:</p>
<ul>
<li>For transactions:
<ul>
<li>host-to-guest: pass tx.data to tx.code call</li>
<li>guest-to-host: parameters of environment functions calls, including storage modifications (pending on storage API)</li>
<li>host-to-guest: return results for host calls</li>
</ul>
</li>
<li>For validity predicates:
<ul>
<li>host-to-guest: pass tx.data, prior and posterior account storage sub-space state and/or storage modifications (i.e. a write log) for the account</li>
<li>guest-to-host: parameters of environment function calls</li>
<li>host-to-guest: return results for host calls</li>
<li><del>guest-to-host</del>: the VP result (<code>bool</code>) can be passed directly from the call</li>
</ul>
</li>
</ul>
<h3 id="storage-write-log"><a class="header" href="#storage-write-log">Storage write log</a></h3>
<p>The storage write log gathers any storage updates (<code>write</code>/<code>delete</code>s) performed by transactions. For each transaction, the write log changes must be accepted by all the validity predicates that were triggered by these changes.</p>
<p>A validity predicate can read its prior state directly from storage as it is not changed by the transaction directly. For the posterior state, we first try to look-up the keys in the write log to try to find a new value if the key has been modified or deleted. If the key is not present in the write log, it means that the value has not changed and we can read it from storage.</p>
<p>The write log of each transaction included in a block and accepted by VPs is accumulated into the block write log. Once the block is committed, we apply the storage changes from the block write log to the persistent storage.</p>
<p><img src="explore/design/ledger/./wasm-vm/storage-write-log.svg" alt="write log" title="storage write log" />
<a href="https://excalidraw.com/new#room=333e1db689b083669c80,Y0i8yhvIAZCFICs753CSuA">https://excalidraw.com/new#room=333e1db689b083669c80,Y0i8yhvIAZCFICs753CSuA</a></p>
<h2 id="gas-metering"><a class="header" href="#gas-metering">Gas metering</a></h2>
<p>The two main options for implementing gas metering within wasm using wasmer are:</p>
<ul>
<li>a <a href="https://github.com/wasmerio/wasmer/tree/72d47336cc1461d63baa2322b38c4cb5f67bb72a/lib/middlewares">gas metering middleware included in wasmer</a>.</li>
<li><a href="https://crates.io/crates/pwasm-utils">https://crates.io/crates/pwasm-utils</a></li>
</ul>
<p>Both of these allow us to assign a gas cost for each wasm operation.</p>
<p><code>wasmer</code> gas middleware is more recent, so probably more risky. It injects the gas metering code into the wasm code, which is more efficient than host calls to a gas meter.</p>
<p><code>pwasm-utils</code> divides the wasm code into metered blocks. It performs host call with the gas cost of each block before it is executed. The gas metering injection is linear to the code size.</p>
<p>The <code>pwasm-utils</code> seems like a safer option to begin with (and we'll probably need to use it for <a href="explore/design/ledger/wasm-vm.html#stack-height-metering">stack height metering</a> too). We can look into switching to <code>wasmer</code> middleware at later point.</p>
<h2 id="stack-height-metering"><a class="header" href="#stack-height-metering">Stack height metering</a></h2>
<p>For safety, we need to limit the stack height in wasm code. Similarly to gas metering, we can also use <code>wasmer</code> middleware or <code>pwasm-utils</code>.</p>
<p>We have to use <code>pwasm-utils</code>, because <code>wasmer</code>'s stack limiter is currently non-deterministic (platform specific). This is to be fixed in this PR: <a href="https://github.com/wasmerio/wasmer/pull/1037">https://github.com/wasmerio/wasmer/pull/1037</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="front-running-prevention"><a class="header" href="#front-running-prevention">Front-running prevention</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/42">Tracking Issue</a></p>
<hr />
<p>This page should describe how DKG can be integrated for front-running prevention.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fractal-scaling"><a class="header" href="#fractal-scaling">Fractal scaling</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/41">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-system"><a class="header" href="#upgrade-system">Upgrade system</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/40">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>We can make use of the Tendermint's finality property to split the storage into immutable and mutable parts, where only the data at the current level is mutable. It should be possible to have the mutable state in-memory only and write to DB only once a block is finalized, which combined with batch writes would most likely be quite efficient (this can also be done asynchronously).</p>
<pre class="mermaid">graph LR
  subgraph &quot;in-memory&quot;
    LN[level n]
  end
  subgraph &quot;DB (each level is immutable once written)&quot;
    LN .-&gt; LNL[level n - 1]
    LNL ===== L0[level 0]
  end
</pre>
<h2 id="in-memory-mutable-state"><a class="header" href="#in-memory-mutable-state">In-memory (mutable state)</a></h2>
<p>The current state is stored in a Sparse Merkle tree. The layout of data in memory should be flexible to allow to optimize throughput. For example, the values of key/value pairs may better stored in a sequence outside of the tree structure. Furthermore, it maybe be better to have the data sorted in memory. This may be possible by decoupling the merkle tree structure from the data and the key/value pairs, as illustrated below.</p>
<pre class="mermaid">graph TD
  subgraph storage
    subgraph sparse merkle tree
      B[branches as paths segments in hashes of keys] .-&gt; L[leaves as a hashes of values]
    end
    subgraph columns
      KV[dictionaries of key/value pairs]
    end
  end
</pre>
<p>It may be advantageous if the data columns keys are not hashed to preserve ordering.</p>
<h2 id="db-immutable-state"><a class="header" href="#db-immutable-state">DB (immutable state)</a></h2>
<p>The immutable state doesn't have the same requirements as the mutable. This means that a different data structures or memory layout may perform better (subject to benchmarks). The state trees in the immutable blocks should take advantage of its properties for optimization. For example, it can save storage space by sharing common data and/or delta compression. </p>
<p>It's very likely that different settings for immutable storage will be provided in future, similar to e.g. <a href="https://tezos.gitlab.io/user/history_modes.html">Tezos history modes</a>.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>We'd like to have easily reproducible benchmarks for the whole database integration that should be filled over time with pre-generated realistic data. This should enable us to tune and compare different hashing functions, backends, data structures, memory layouts, etc.</p>
<h3 id="criteria"><a class="header" href="#criteria">Criteria</a></h3>
<ul>
<li>in-memory
<ul>
<li>writes (insert, update, delete)
<ul>
<li>possibly also concurrent writes, pending on the approach taken for concurrent transaction execution</li>
</ul>
</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
<li>DB (lower priority)
<ul>
<li>writes in batched mode</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
</ul>
<h2 id="db-backends"><a class="header" href="#db-backends">DB backends</a></h2>
<p>The considered options for a DB backend are given in <a href="explore/design//explore/libraries/db.html">Libraries &amp; Tools / Database page</a>.</p>
<h3 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h3>
<p>A committed block is not immediately persisted on RocksDB. When the block is committed, a set of key-value pairs which compose the block is written to the memtable on RocksDB. For the efficient sequential write, a flush is executed to persist the data on the memtable to the disk as a file when the size of the memtable is getting big (the threshold is one of the tuning parameters).</p>
<p>We can disable write-ahead log(WAL) which protects these data on the memtable from a crash by persisting the write logs to the disk. Disabling WAL helps reduce the write amplification. That's because WAL isn't required for Anoma because other nodes have the block. The blocks which have not been persisted to the disk by flush can be recovered even if an Anoma node crashes.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="storage-module"><a class="header" href="#storage-module"><code>storage</code> module</a></h3>
<p>This is the main interface for interacting with storage in Anoma.</p>
<p>This module and its sub-modules should implement the in-memory storage (and/or a cache layer) with Merkle tree (however, the interface should be agnostic to the choice of vector commitment scheme or whether or not there even is one, we may want non-Merklised storage) and the persistent DB.</p>
<p>The in-memory storage holds chain's metadata and current block's storage.</p>
<p>Its public API should allow/provide:</p>
<ul>
<li>get the Merkle root and Merkle tree proofs</li>
<li>read-only storage API for ledger's metadata to be accessible for transactions' code, VPs and the RPC
<ul>
<li>with public types of all the stored metadata</li>
</ul>
</li>
<li>unless specified otherwise, read the state from the current block</li>
</ul>
<p>An API made visible only to the shell module (e.g. <code>pub ( in SimplePath )</code> - https://doc.rust-lang.org/reference/visibility-and-privacy.html) should allow the shell to:</p>
<ul>
<li>load state from DB for latest persisted block or initialize a new storage if none found</li>
<li>begin a new block</li>
<li>within a block:
<ul>
<li>transaction can modify <a href="explore/design//explore/design/ledger/accounts.html#dynamic-storage-sub-space">account sub-space</a>
<ul>
<li>the function that modify storage (e.g. <code>write</code> and <code>delete</code>) have to guarantee to also update the Merkle tree</li>
</ul>
</li>
<li>store each applied transaction and its result</li>
</ul>
</li>
<li>end the current block</li>
<li>commit the current block (persist to storage)</li>
</ul>
<h3 id="storagedb-module"><a class="header" href="#storagedb-module"><code>storage/db</code> module</a></h3>
<p>The persistent DB implementation (e.g. RocksDB).</p>
<h3 id="db-keys"><a class="header" href="#db-keys">DB keys</a></h3>
<p>The DB keys are composed of key segments. A key segment can be an <code>Address</code> which starts with <code>#</code> (there can be multiple addresses involved in a key) or any user defined non-empty utf-8 string (maybe limited to only alphanumerical characters). Also, <code>/</code> and <code>?</code> are reserved. <code>/</code> is used as a separator for segments. <code>?</code> is reserved for a validity predicate and the key segment <code>?</code> can be specified only by the specific API.</p>
<p>In the DB storage, the keys would be prefixed by the block height and the space type. This would be hidden from the wasm environment, which only operates at the current block height. For example, when the block height is <code>123</code> and the key specified by the storage is <code>#my_address_hash/balance/token</code>, the actual key for the persistent DB implementation would be <code>123/subspace/#my_address_hash/balance/token</code>.</p>
<p>This could roughly be implemented as:</p>
<pre><code>struct Key {
    segments: Vec&lt;DbKeySeg&gt;
}

impl Key {
    fn parse(string: String) -&gt; Result&lt;Self, Error&gt; {..}
    fn push(&amp;self, other: &amp;KeySeg) -&gt; Self {..}
    fn join(&amp;self, other: &amp;Key) -&gt; Self {..}
    fn into_string(&amp;self) -&gt; String;
    // find addresses included in the key, used to find which validity-predicates should be triggered by a key space change
    fn find_addresses(&amp;self) -&gt; Vec&lt;Address&gt; {..}
}

// Provide a trait so that we can define new pre-defined key segment types inside wasm environment and also ad-hoc key segments defined by wasm users
trait KeySeg {
    fn parse(string: String) -&gt; Result&lt;Self, Error&gt;;
    fn to_string(&amp;self) -&gt; String;
    fn to_db_key(&amp;self) -&gt; DbKeySeg;
}

enum DbKeySeg {
    AddressSeg(Address),
    StringSeg(String),
}

impl KeySeg for DbKeySeg {..}
impl KeySeg for BlockHeight {..}
</code></pre>
<p>Then the storage API functions (read/write/delete) should only accept the keys with this <code>Key</code> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-schema"><a class="header" href="#data-schema">Data schema</a></h1>
<p>At high level, all the data in the <a href="explore/design/accounts.html#dynamic-storage-sub-space">accounts' dynamic
sub-spaces</a> is just keys associated with
arbitrary bytes and intents are just wrapper around arbitrary data. To help the
processes that read and write this data (transactions, validity predicates,
matchmaker) interpret it and implement interesting functionality on top it, the
ledger could provide a way to describe the schema of the data.</p>
<p>For storage data encoding, we're currently using the borsh library, which
provides a way to derive schema for data that can describe its structure in a
very generic way that can easily be consumed in different data-exchange formats
such as JSON. In Rust code, the data can be composed with Rust native ADTs
(<code>struct</code> and <code>enum</code>) and basic collection structures (fixed and dynamic sized
array, hash map, hash set). Borsh already has a decent coverage of different
implementations in e.g. JS and TypeScript, JVM based languages and Go, which
we'll hopefully be able to support in wasm in near future too.</p>
<p>Note that the borsh data schema would not be forced upon the users as they can
still build and use custom data with arbitrary encoding.</p>
<p>A naive implementation could add optional <code>schema</code> field to each stored key. To
reduce redundancy, there could be some &quot;built-in&quot; schemas and/or specific
storage space for commonly used data schema definitions. Storage fees apply, but
perhaps they can be split between all the users, so some commonly used data
schema may be almost free.</p>
<p>A single address in the ledger is define with all schema. A specific schema can
be looked up with a key in its subspace. The schema variable is not yet
implemented and the definition might change to something more appropiate.</p>
<h2 id="schema-derived-library-code"><a class="header" href="#schema-derived-library-code">Schema derived library code</a></h2>
<h3 id="account-example"><a class="header" href="#account-example">account example</a></h3>
<p>Let's start with an example, in which some users want to deploy a
multi-signature account to some shared asset. They create a transaction, which
would initialize a new account with an address <code>shared-savings</code> and write into
its storage sub-space the initial funds for the account and data under the key
<code>&quot;multisig&quot;</code> with the following definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct MultiSig {
    threshold: u64,
    counter: u64,
    keys: Vec&lt;PublicKey&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>When the transaction is applied, the data is stored together with a reference to
the derived data schema, e.g.:</p>
<pre><code class="language-json">{
  &quot;MultiSig&quot;: {
    &quot;struct&quot;: {
      &quot;named_fields&quot;: {
        &quot;threshold&quot;: &quot;u64&quot;,
        &quot;counter&quot;: &quot;u64&quot;,
        &quot;keys&quot;: {
          &quot;sequence&quot;: &quot;PublicKey&quot;
        }
      }
    }
  }
}
</code></pre>
<p>Now any transaction that wants to interact with this account can look-up and use its data schema. We can also use this information to display values read from storage from e.g. RPC or indexer.</p>
<p>What's more, when the data has schema attached on-chain, with borsh we have bijective mapping between the data definitions and their schemas. We can use this nice property to generate code for data definitions back from the schema in any language supported by borsh and that we'll able to support in wasm.</p>
<p>We can take this a step further and even generate some code for data access on top of our wasm environment functions to lift the burden of encoding/decoding data from storage. For our example, from the key <code>&quot;multisig&quot;</code>, in Rust we can generate this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_multisig() -&gt; MultiSig;
fn write_multisig(MultiSig);
fn with_multisig(FnMut(MultiSig) -&gt; MultiSig);
<span class="boring">}
</span></code></pre></pre>
<p>Which can be imported like regular library code in a transaction and arbitrarily extended by the users. Similarly, the schema could be used to derive some code for validity predicates and intents.</p>
<p>We can generate the code on demand (e.g. we could allow to query a node to generate library code for some given accounts for a given language), but we could also provide some helpers for e.g. foundation's or validator's node to optionally automatically publish generated code via git for all the accounts in the current state. In Rust, using this library could look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// load the account(s) code where the identifier is the account's address.
use anoma_accounts::SharedSavings;

fn transaction(...) {
  let multisig = SharedSavings::read_multisig();
  ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-primitives"><a class="header" href="#crypto-primitives">Crypto primitives</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/39">Tracking Issue</a></p>
<hr />
<p>This page should describe cryptography primitives that we might want to use, such as types of keys, hashing functions, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors-and-incentives"><a class="header" href="#actors-and-incentives">Actors and Incentives</a></h1>
<p>Anoma consists of various actors fulfilling various roles in the network. They are all incentivized to act for the good of the network. The native Anoma token <code>XAN</code> is used to settle transaction fees and pay for the incentives in Anoma.</p>
<h2 id="fees-associated-with-a-transaction"><a class="header" href="#fees-associated-with-a-transaction">Fees associated with a transaction</a></h2>
<p>Users of Anoma can</p>
<ul>
<li>transfer private assets they hold to other users and</li>
<li>barter assets with other users.</li>
</ul>
<p>Each transaction may be associated with the following fees, paid in <code>XAN</code>:</p>
<ul>
<li><strong>Execution fees</strong> to compensate for computing, storage and memory costs, charges at 2 stages:
<ul>
<li><strong>initial fee (init_f)</strong>: charged before the transaction is settled</li>
<li><strong>post-execution fee (exe_f)</strong>: charged after the settlement</li>
</ul>
</li>
<li><strong>Exchange fee (ex_f)</strong>: a fee proportional to the value exchanged in a trade</li>
</ul>
<h2 id="actors-and-their-associated-fees-and-responsibilities"><a class="header" href="#actors-and-their-associated-fees-and-responsibilities">Actors and their associated fees and responsibilities</a></h2>
<table><thead><tr><th>Actor</th><th>Responsibilities</th><th>Incentives</th><th>Bond in escrow</th><th>May also be</th></tr></thead><tbody>
<tr><td>User</td><td>Make offers or send transactions</td><td>Features of Anoma</td><td>X</td><td>Anyone</td></tr>
<tr><td>Signer</td><td>Generate key shards</td><td>portions of init_f, exe_f</td><td>✓</td><td>Validator</td></tr>
<tr><td>Validator</td><td>Validate</td><td>portions of init_f, exe_f</td><td>✓</td><td>Signer</td></tr>
<tr><td>Submitter</td><td>Submit orders &amp; pay init_f</td><td>successful orders get init_f back plus bonus</td><td>X</td><td></td></tr>
<tr><td>Intent gossip operator</td><td>Signs and shares orders</td><td>portions of init_f, exe_f</td><td>X</td><td></td></tr>
<tr><td>Market maker</td><td>Signs and broadcast orders</td><td>the difference between the ask and bid price</td><td>X</td><td></td></tr>
<tr><td>Proposer</td><td>Proposes blocks</td><td>portions of init_f, exe_f</td><td></td><td>Validator</td></tr>
</tbody></table>
<p>Questions to explore:</p>
<ul>
<li>
<p>How do we calculate the incentives? What are the equations for each actor?</p>
</li>
<li>
<p>How do we calculate the bond/reward for the signers and validators?</p>
</li>
<li>
<p>How do we ensure certain dual/multi agencies are allowed but not others? E.g., signers can be validators but we may not want them to be proposers because they may have knowledge of which transactions are encrypted.</p>
</li>
</ul>
<h2 id="actors-and-fees-flowchart"><a class="header" href="#actors-and-fees-flowchart">Actors and fees flowchart</a></h2>
<p><img src="explore/design/summary.png?raw=true" alt="Summary" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototypes"><a class="header" href="#prototypes">Prototypes</a></h1>
<p>A prototype should start with a description of its goals. These can include, but are not limited to a proof of concept of novel ideas or alternative approaches, comparing different libraries and gathering feedback.</p>
<p>To get started on a prototype, please:</p>
<ul>
<li>open an issue on this repository</li>
<li>add a sub-page to this section with a link to the issue</li>
</ul>
<p>The page outlines the goals and possibly contains any notes that are not suitable to be added to the prototype source itself, while the issue should track the sub-task, their progress, and assignees.</p>
<p>The code quality is of lesser importance in prototypes. To put the main focus on the prototype's goals, we don't need to worry much about testing, linting and doc strings.</p>
<h2 id="advancing-a-successful-prototype"><a class="header" href="#advancing-a-successful-prototype">Advancing a successful prototype</a></h2>
<p>Once the goals of the prototype have been completed, we can assess if we'd like to advance the prototype to a development version. </p>
<p>In order to advance a prototype, in general we'll want to:</p>
<ul>
<li>review &amp; clean-up the code for lint, format and best practices</li>
<li>enable common Rust lints</li>
<li>review any new dependencies</li>
<li>add docs for any public interface (internally public too)</li>
<li>add automated tests</li>
<li>if the prototype has diverged from the original design, update these pages </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-ledger-prototype"><a class="header" href="#base-ledger-prototype">Base ledger prototype</a></h1>
<h2 id="version-2"><a class="header" href="#version-2">Version 2</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/62">https://github.com/anoma/anoma/issues/62</a></p>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>storage
<ul>
<li>build key schema for access</li>
<li>implement dynamic account sub-spaces</li>
</ul>
</li>
<li>implement more complete support for WASM transactions and validity predicates
<ul>
<li>transactions can read/write all storage</li>
<li>validity predicates receive the set of changes (changed keys or complete write log) and can read their pre/post state</li>
</ul>
</li>
<li>add basic transaction gas metering</li>
<li>various other improvements</li>
</ul>
<h2 id="version-1"><a class="header" href="#version-1">Version 1</a></h2>
<p>tracking issue <a href="https://github.com/heliaxdev/rd-pm/issues/5">https://github.com/heliaxdev/rd-pm/issues/5</a></p>
<h3 id="goals-1"><a class="header" href="#goals-1">Goals</a></h3>
<ul>
<li>get some hands-on experience with Rust and Tendermint</li>
<li>initial usable node + client (+ validator?) setup</li>
<li>provide a base layer for other prototypes that need to build on top of a ledger</li>
</ul>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>The main components are built in a single Cargo project with <a href="explore/prototypes/base-ledger.html#shared">shared library code</a> and multiple binaries:</p>
<ul>
<li><code>anoma</code> - main executable with commands for both the node and the client (<code>anoma node</code> and <code>anoma client</code>)</li>
<li><code>anoman</code> - the <a href="explore/prototypes/base-ledger.html#node">node</a></li>
<li><code>anomac</code> - the <a href="explore/prototypes/base-ledger.html#client">client</a></li>
</ul>
<h4 id="node"><a class="header" href="#node">Node</a></h4>
<p>The node is built into <code>anoman</code>.</p>
<h5 id="shell"><a class="header" href="#shell">Shell</a></h5>
<p>The shell is what currently pulls together all the other components in the node.</p>
<p>When it's ran:</p>
<ul>
<li>establish a channel (e.g.<code>mpsc::channel</code> - Multi-producer, single-consumer FIFO queue) for communication from tendermint to the shell</li>
<li>launch tendermint node in another thread with the channel sender
<ul>
<li>send tendermint ABCI requests via the channel together with a new channel sender to receive a response</li>
</ul>
</li>
<li>run shell loop with the channel receiver, which handles ABIC requests:
<ul>
<li><a href="explore/prototypes//explore/design/ledger/tx-execution.html">transaction execution</a> which includes <a href="explore/prototypes//explore/design/ledger/wasm-vm.html">wasm VM calls</a></li>
</ul>
</li>
</ul>
<h6 id="tendermint"><a class="header" href="#tendermint">Tendermint</a></h6>
<p>This module handles initializing and running <code>tendermint</code> and forwards messages for the ABCI requests via its channel sender.</p>
<h5 id="storage-1"><a class="header" href="#storage-1">Storage</a></h5>
<p>Key-value storage. More details are specified on <a href="explore/prototypes/./explore/design/db.html">Database page</a>.</p>
<h5 id="cli"><a class="header" href="#cli">CLI</a></h5>
<ul>
<li><code>anoma run</code> to start the node (will initialize (if needed) and launch tendermint under the hood)</li>
<li><code>anoma reset</code> to delete all the node's state from DB and tendermint's state</li>
</ul>
<h4 id="client"><a class="header" href="#client">Client</a></h4>
<p>Allows to submit a transaction with an attached wasm code to the node with:</p>
<p><code>anoma tx --code tx.wasm</code></p>
<p>It presents back the received response on stdout. Currently, it waits for both the mempool validation and application in a block.</p>
<h4 id="shared"><a class="header" href="#shared">Shared</a></h4>
<h5 id="config"><a class="header" href="#config">Config</a></h5>
<p>Configuration settings:</p>
<ul>
<li>home directory (db storage and tendermint config and data)</li>
</ul>
<h5 id="genesis"><a class="header" href="#genesis">Genesis</a></h5>
<p>The genesis parameters, such as the initial validator set, are used to initialize a chain's genesis block.</p>
<h5 id="rpc-types"><a class="header" href="#rpc-types">RPC types</a></h5>
<p>The types for data that can be submitted to the node via the client's RPC commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-system-prototype"><a class="header" href="#intent-gossip-system-prototype">Intent Gossip system prototype</a></h1>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/35">https://github.com/anoma/anoma/issues/35</a></p>
<h2 id="goals-2"><a class="header" href="#goals-2">Goals</a></h2>
<ul>
<li>learning rust</li>
<li>usable node + client setup :
<ul>
<li>intent</li>
<li>incentive function</li>
<li>mempool and white list</li>
</ul>
</li>
<li>basic matchmaker</li>
</ul>
<h2 id="components-1"><a class="header" href="#components-1">components</a></h2>
<p>The intent gossip is build conjointly to the ledger and share the same binary.</p>
<h3 id="node-1"><a class="header" href="#node-1">Node</a></h3>
<p>The node is built into <code>anoman</code>, it runs all the necesarry part, rpc server,
libp2p, intent gossip app.</p>
<h4 id="intent-gossip-application"><a class="header" href="#intent-gossip-application">Intent gossip application</a></h4>
<p>The intent gossip application</p>
<h5 id="mempool"><a class="header" href="#mempool">Mempool</a></h5>
<h5 id="filter"><a class="header" href="#filter">Filter</a></h5>
<h4 id="network-behaviour"><a class="header" href="#network-behaviour">Network behaviour</a></h4>
<p>The network behaviour is the part that react on network event. It creates a
channel (e.g. <code>tokio::mpsc::channel</code>) with the intent gossip to communicate all
intent it receive.</p>
<h4 id="rpc-server"><a class="header" href="#rpc-server">Rpc server</a></h4>
<p>If the rpc command line option is set it creates a tonic server that receive
command from a client and send theses through a channel
(e.g. <code>tokio::mpsc::channel</code>) to the the intent gossip.</p>
<h3 id="client-1"><a class="header" href="#client-1">Client</a></h3>
<p>Allow to submit a intent :
<code>anoma gossip --data &quot;data&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries--tools"><a class="header" href="#libraries--tools">Libraries &amp; Tools</a></h1>
<p>The aim of this section is to document possible choices for certain components. For components where many choices are available, such as a database backend, an overview of the important differences of the considered libraries may be given.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">network</a></h1>
<h2 id="libp2p--peer-to-peer-network"><a class="header" href="#libp2p--peer-to-peer-network">Libp2p : Peer To Peer network</a></h2>
<p><a href="https://github.com/libp2p/rust-libp2p">https://github.com/libp2p/rust-libp2p</a></p>
<p>peer-to-peer framework that takes care of the transport/identity and message
encryption for us.</p>
<h2 id="tonic--clientserver-with-protobuf-prost"><a class="header" href="#tonic--clientserver-with-protobuf-prost">tonic : Client/Server with protobuf (prost)</a></h2>
<p><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a></p>
<p>Generates a client/server from protobuf file. This can be used for a rpc server.</p>
<h1 id="network-behaviour-1"><a class="header" href="#network-behaviour-1">network behaviour</a></h1>
<h2 id="gossipsub"><a class="header" href="#gossipsub">Gossipsub</a></h2>
<p><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">https://github.com/libp2p/specs/tree/master/pubsub/gossipsub</a></p>
<p>Publish/Subscribe protocol, improvement over floodsub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h1>
<p>Important factors:</p>
<ul>
<li>UX</li>
<li>ease of use</li>
<li>cross-platform</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>clap</li>
</ul>
<h2 id="clap"><a class="header" href="#clap">Clap</a></h2>
<p><a href="https://github.com/clap-rs/clap">https://github.com/clap-rs/clap</a></p>
<p>Probably the most widely used CLI library in Rust.</p>
<p>With version 2.x, we'd probably want to use it with <a href="https://github.com/TeXitoi/structopt">Structops</a> for deriving.</p>
<p>But we can probably use 3.0, which is not yet stable, but is pretty close <a href="https://github.com/clap-rs/clap/issues/1037">https://github.com/clap-rs/clap/issues/1037</a>. This version comes with deriving attributes and also other new ways to build CLI commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>Important factors:</p>
<ul>
<li>persistent key/value storage</li>
<li>reliability and efficiency (runtime performance and disk usage)</li>
<li>thread safety</li>
<li>ease of use</li>
</ul>
<p>The considered DBs:</p>
<ul>
<li>LMDB</li>
<li>LevelDB</li>
<li>RocksDB</li>
<li>sled - Rust native</li>
</ul>
<p>To watch:</p>
<ul>
<li><a href="https://docs.rs/sanakirja">sanakirja</a> - too new to be considered for now, but has some <a href="https://pijul.org/posts/2021-02-06-rethinking-sanakirja/">promising initial results</a> - TLDR. it can <em>fork tables</em> efficiently, it beats LMDB in benchmarks and usability</li>
</ul>
<p>The current preference is for RocksDB as it's tried and tested. Eventually, we might want to benchmark against other backends for our specific use case.</p>
<h2 id="lmdb"><a class="header" href="#lmdb">LMDB</a></h2>
<p><a href="https://symas.com/lmdb/">https://symas.com/lmdb/</a></p>
<p>A compact and efficient, persistent in-memory (i.e. mmap-based) B+trees database. Reportedly has a great read performance, but not as good at writing.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/mozilla/rkv">https://github.com/mozilla/rkv</a></li>
<li><a href="https://github.com/AltSysrq/lmdb-zero">https://github.com/AltSysrq/lmdb-zero</a></li>
<li><a href="https://github.com/vhbit/lmdb-rs">https://github.com/vhbit/lmdb-rs</a> - some <a href="https://github.com/vhbit/lmdb-rs/issues/32#issuecomment-310906601">comparison notes</a> with danburkert/lmdb-rs</li>
<li><a href="https://github.com/danburkert/lmdb-rs">https://github.com/danburkert/lmdb-rs</a></li>
</ul>
<h2 id="leveldb"><a class="header" href="#leveldb">LevelDB</a></h2>
<p>Log Structured Merge Tree db. Uses one global lock. Better write performance than LMDB and lower DB size.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/skade/leveldb">https://github.com/skade/leveldb</a></li>
</ul>
<h2 id="rocksdb-1"><a class="header" href="#rocksdb-1">RocksDB</a></h2>
<p>A fork of LevelDB with different optimizations (supposedly for RAM and flash storage).</p>
<p>Used in <a href="https://github.com/simplestaking/tezedge">https://github.com/simplestaking/tezedge</a> and <a href="https://github.com/near/nearcore">https://github.com/near/nearcore</a>.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/rust-rocksdb/rust-rocksdb">https://github.com/rust-rocksdb/rust-rocksdb</a></li>
</ul>
<h2 id="sled"><a class="header" href="#sled">Sled</a></h2>
<p>Repo: <a href="https://github.com/spacejam/sled">https://github.com/spacejam/sled</a>
Homepage: <a href="https://sled.rs/">https://sled.rs/</a></p>
<p>Modern, zero-copy reads, lock-free and many more features.</p>
<hr />
<h1 id="merkle-tree-data-structure"><a class="header" href="#merkle-tree-data-structure">Merkle tree data structure</a></h1>
<p>Some popular choices for merkle tree in the industry are AVL(+) tree, Patricia Trie and Sparse Merkle Tree, each with different trade-offs.</p>
<p>AVL(+) tree is used in e.g. <a href="https://github.com/cosmos/iavl">Cosmos</a>. The advantage of this structure is that key don't need to be hashed prior to insertion/look-up.</p>
<p>Patricia trie used in e.g. <a href="https://eth.wiki/en/fundamentals/patricia-tree">Ethereum</a> and <a href="https://www.dailambda.jp/blog/2020-05-11-plebeia/">Plebeia for Tezos</a> are designed to be more space efficient.</p>
<p>Sparse Merle tree as described in <a href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751">Optimizing sparse Merkle trees</a> used in e.g. <a href="https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers/2006">Plasma Cash</a> are somewhat similar to Patricia trees, but perhaps conceptually simpler.</p>
<ul>
<li>Compact Sparse Merkle Trees <a href="https://eprint.iacr.org/2018/955.pdf">https://eprint.iacr.org/2018/955.pdf</a></li>
<li>Efficient Sparse Merkle Trees (caching) <a href="https://eprint.iacr.org/2016/683.pdf">https://eprint.iacr.org/2016/683.pdf</a></li>
</ul>
<p>Considered libraries:</p>
<ul>
<li>merk</li>
<li>sparse-merkle-tree</li>
<li>patricia_tree</li>
</ul>
<h2 id="merk"><a class="header" href="#merk">merk</a></h2>
<p><a href="https://github.com/nomic-io/merk">https://github.com/nomic-io/merk</a></p>
<p>Using AVL tree built on top of RocksDB. It makes it easy to setup Merkle tree storage, but:</p>
<ul>
<li>is not yet fully implemented as described (e.g. <a href="https://github.com/nomic-io/merk/issues/26">concurrent ops</a>)</li>
<li>benchmarks seem to differ from results in README</li>
<li>doesn't have past states of the tree, instead <a href="https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md#database-representation">relies on RocksDB snapshot/checkpoint features</a>, which means that it's <a href="https://github.com/nomic-io/merk/issues/11">strongly coupled</a></li>
<li>uses a custom <a href="https://github.com/nomic-io/ed">encoding lib</a> which is zero-copy, but big-endian everywhere</li>
<li>there are a <code>unsafe</code> usages that are not well described/justified</li>
<li>uses some experimental dep such as <a href="https://github.com/rust-lang-nursery/failure">https://github.com/rust-lang-nursery/failure</a> (now deprecated)</li>
</ul>
<h2 id="sparse-merkle-tree"><a class="header" href="#sparse-merkle-tree">sparse-merkle-tree</a></h2>
<p><a href="https://github.com/jjyr/sparse-merkle-tree">https://github.com/jjyr/sparse-merkle-tree</a></p>
<p>A nice abstraction, albeit not yet declared stable. It allows to plug-in a custom hasher function (which is important for <a href="https://github.com/heliaxdev/rd-pm/issues/11">circuit friendliness</a>) and storage backend. Has minimal dependencies and support Rust <code>no_std</code>.</p>
<h2 id="patricia_tree"><a class="header" href="#patricia_tree">patricia_tree</a></h2>
<p><a href="https://github.com/sile/patricia_tree">https://github.com/sile/patricia_tree</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Options to consider:</p>
<ul>
<li>env_logger</li>
<li>slog</li>
<li>tracing</li>
</ul>
<p>The current preference is for tracing in combination with tracing-subscriber (to log collected events and traces), because we have some async and parallelized code. In future, we should also add tracing-appender for rolling file logging.</p>
<h2 id="env_logger"><a class="header" href="#env_logger">Env_logger</a></h2>
<p><a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></p>
<p>A simple logger used by many Rust tools, configurable by env vars. Usually combined with <a href="https://github.com/seanmonstar/pretty-env-logger">pretty-env-logger</a>.</p>
<h2 id="slog"><a class="header" href="#slog">Slog</a></h2>
<p><a href="https://github.com/slog-rs/slog">https://github.com/slog-rs/slog</a></p>
<p>Composable, structured logger. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/slog-rs/envlogger">https://github.com/slog-rs/envlogger</a> port of env_logger as a slog-rs drain </li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p><a href="https://github.com/tokio-rs/tracing">https://github.com/tokio-rs/tracing</a></p>
<p>Tracing &amp; logging better suited for concurrent processes and async code. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-appender">https://github.com/tokio-rs/tracing/tree/master/tracing-appender</a> non-blocking log appender</li>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-log">https://github.com/tokio-rs/tracing/tree/master/tracing-log</a> allows to forward library log statements and to use this in combination with env_logger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packaging"><a class="header" href="#packaging">Packaging</a></h1>
<p>For Rust native code, cargo works great, but we'll need to package stuff from outside of Rust too (e.g. tendermint). The goal is to have a repo that can always build as is (reproducible) and easily portable (having a single command to install all the deps).</p>
<p>Options to consider:</p>
<ul>
<li><a href="https://github.com/NixOS/nixpkgs">nix packages</a></li>
<li><a href="https://guix.gnu.org/manual/en/html_node/Package-Management.html">guix</a></li>
<li>docker</li>
</ul>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>For Rust dependencies, it would be nice to integrate and use:</p>
<ul>
<li><a href="https://github.com/crev-dev/cargo-crev">https://github.com/crev-dev/cargo-crev</a></li>
<li><a href="https://github.com/rust-secure-code/cargo-geiger">https://github.com/rust-secure-code/cargo-geiger</a></li>
<li><a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></li>
</ul>
<h2 id="nix"><a class="header" href="#nix">Nix</a></h2>
<p>Purely functional package management for reproducible environment. The big drawback is its language.</p>
<h2 id="guix"><a class="header" href="#guix">Guix</a></h2>
<p>Similar package management capability to nix, but using scheme language.</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>Not ideal for development, but we'll probably want to provide docker images for users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-libraries"><a class="header" href="#serialization-libraries">Serialization libraries</a></h1>
<p>Because the serialization for the RPC and storage have different priorities, it might be beneficial to use a different library for each.</p>
<h2 id="rpc"><a class="header" href="#rpc">RPC</a></h2>
<p>Important factors:</p>
<ul>
<li>security, e.g.:
<ul>
<li>handling of malicious input (buffers should not be trusted)</li>
<li>secure RPC, if included (e.g. DoS or memory exhaustion vulnerabilities)</li>
</ul>
</li>
<li>native and cross-language adoption for easy interop</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>protobuf</li>
<li>cap'n'proto</li>
<li>flatbuffers</li>
<li>serde</li>
</ul>
<p>The current preference is for protobuf using the prost library.</p>
<h2 id="storage-2"><a class="header" href="#storage-2">Storage</a></h2>
<p>Important factors:</p>
<ul>
<li>consistent binary representation for hashing</li>
<li>preserve ordering (for DB keys)</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>bincode</li>
<li>borsh</li>
</ul>
<h2 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h2>
<p>The most mature and widely adopted option. Usually combined with gRPC framework. The <a href="https://github.com/tendermint/rust-abci">Tendermint Rust ABCI</a> provides protobuf definitions.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/danburkert/prost">https://github.com/danburkert/prost</a> - Rust native</li>
<li><a href="https://github.com/stepancheg/rust-protobuf">https://github.com/stepancheg/rust-protobuf</a> - Rust native</li>
<li><a href="https://github.com/tafia/quick-protobuf">https://github.com/tafia/quick-protobuf</a> - <a href="https://github.com/tafia/quick-protobuf/issues/12">missing features</a></li>
</ul>
<p><a href="https://www.reddit.com/r/rust/comments/czxny2/which_protocol_buffers_crates_to_invest_in/">A comparison of the two</a> main competing Rust implementations seems to favor Prost. Prost reportedly generates cleaner (more idiomatic) Rust code (<a href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671">https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671</a>). Prost also has better performance (<a href="https://github.com/danburkert/prost/issues/398#issuecomment-751600653">https://github.com/danburkert/prost/issues/398#issuecomment-751600653</a>). It is possible to also add serde derive attributes for e.g. <a href="https://github.com/danburkert/prost/issues/75">JSON support</a>. JSON can be useful for development, requests inspection and web integration. However, to reduce attack surface, we might want to disallow JSON for write requests on mainnet by default.</p>
<p>gRPC implementations:</p>
<ul>
<li><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a> - Rust native, using Prost and Tokio</li>
<li><a href="https://github.com/tikv/grpc-rs">https://github.com/tikv/grpc-rs</a> - build on C core library</li>
<li><a href="https://github.com/stepancheg/grpc-rust">https://github.com/stepancheg/grpc-rust</a> - not production ready</li>
</ul>
<h2 id="capnproto"><a class="header" href="#capnproto">Cap'n'proto</a></h2>
<p>It avoids serialization altogether, you use the data natively in a representation that is efficient for interchange (&quot;zero-copy&quot;). The other cool feature is its <a href="https://capnproto.org/rpc.html">&quot;time-traveling RPC&quot;</a>. On the other hand concern for this lib is a much lower adoption rate, especially the Rust port which is not as complete. The format is designed to be safe against malicious input (on the both sides of a communication channel), but according to <a href="https://capnproto.org/faq.html">FAQ</a> the reference impl (C++) has not yet undergone security review.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/capnproto/capnproto-rust">https://github.com/capnproto/capnproto-rust</a></li>
</ul>
<h2 id="flatbuffers"><a class="header" href="#flatbuffers">Flatbuffers</a></h2>
<p>Similar to protobuf, but zero-copy like Cap'n'proto, hence a lot faster.</p>
<p>Unfortunately, the Rust implementation is <a href="https://google.github.io/flatbuffers/flatbuffers_support.html">lacking buffer verifiers</a>, which is crucial for handling malicious requests gracefully. There is only draft implementation <a href="https://github.com/google/flatbuffers/pull/6269">https://github.com/google/flatbuffers/pull/6269</a>. This most likely rules out this option.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/google/flatbuffers/tree/master/rust/flatbuffers">https://github.com/google/flatbuffers/tree/master/rust/flatbuffers</a></li>
</ul>
<h2 id="serde"><a class="header" href="#serde">Serde</a></h2>
<p>Serde is Rust native framework with great ergonomics. It supports many <a href="https://serde.rs/#data-formats">different formats</a> implemented as libraries. It's used in some DBs too. Serde itself gives <a href="https://github.com/serde-rs/serde/issues/1087">no security guarantees</a>, handling of malicious input depends heavily on the used format. Serde can be used in combination with many other formats, like protobuf.</p>
<h2 id="bincode"><a class="header" href="#bincode">Bincode</a></h2>
<p><a href="https://github.com/servo/bincode">https://github.com/servo/bincode</a></p>
<p>Built on top of serde. Easy to use.</p>
<h2 id="borsh"><a class="header" href="#borsh">Borsh</a></h2>
<p><a href="https://github.com/near/borsh-rs">https://github.com/near/borsh-rs</a></p>
<p>Used in the Near protocol, it guarantees consistent representations and has a specification. It is also faster than bincode and is being <a href="https://github.com/near/borsh#implementations">implemented in other languages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-runtime"><a class="header" href="#wasm-runtime">WASM runtime</a></h1>
<p>Considered runtimes:</p>
<ul>
<li>wasmer</li>
<li>wasmi</li>
</ul>
<p>A good comparison overview is given in this <a href="https://forum.holochain.org/t/wasmi-vs-wasmer/1929">thread that discusses replacing wasmi with wasmer</a> and its links. In summary:</p>
<ul>
<li>wasmer has native rust closures (simpler code)</li>
<li>wasmer uses lexical scoping to import functions, wasmi is based on structs and trait impls</li>
<li>the wasmer org maintains wasmer packages in many languages</li>
<li>wasmer may be vulnerable to compiler bombs
<ul>
<li>this can be mitigated by using <a href="https://lib.rs/crates/wasmer-compiler-singlepass-near">a singlepass wasm compiler</a></li>
</ul>
</li>
<li>gas metering
<ul>
<li>wasmi inject calls to the host gas meter from Wasm modules</li>
<li>wasmer 
<ul>
<li>uses Middleware which injects the instructions at the parsing stage of the compiler (with inlining) - reduced overhead</li>
<li>must also consider compiler gas cost and how to handle compiler performance changes</li>
</ul>
</li>
<li>it's hard to implement gas rules for precompiles</li>
</ul>
</li>
<li><a href="https://github.com/WebAssembly/design/blob/c9db0ebdee28d2f92726314c05cb8ff382701f8e/Nondeterminism.md">nondeterminism concerns</a>
<ul>
<li>different wasm versions (e.g. newly added features) have to be handled in both the compiled and interpreted versions</li>
<li>non-determinism in the source language cannot be made deterministic in complied/interpreted wasm either</li>
<li>threading - look like it has a long way to go before being usable</li>
<li>floats/NaN - can be avoided <a href="https://github.com/WebAssembly/design/issues/582#issuecomment-191318866">https://github.com/WebAssembly/design/issues/582#issuecomment-191318866</a></li>
<li>SIMD</li>
<li>environment resources exhaustion</li>
</ul>
</li>
<li>both are using the same spec, in wasmi words &quot;there shouldn't be a problem migrating to another spec compliant execution engine.&quot; and &quot;wasmi should be a good option for initial prototyping&quot;
<ul>
<li>of course this is only true if we don't use features that are not yet in the spec</li>
</ul>
</li>
</ul>
<h2 id="wasmer"><a class="header" href="#wasmer">wasmer</a></h2>
<p>Repo: <a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></p>
<p>Compiled with multiple backends (Singlepass, Cranelift and LLVM). It <a href="https://github.com/wasmerio/wasmer/blob/3dc537cc49b8034047c3b142a66b3b6180f4447c/examples/metering.rs">support metering</a> via a <a href="https://github.com/wasmerio/wasmer/tree/3dc537cc49b8034047c3b142a66b3b6180f4447c/lib/middlewares">Middleware</a>.</p>
<h2 id="wasmi"><a class="header" href="#wasmi">wasmi</a></h2>
<p>Repo: <a href="https://github.com/paritytech/wasmi">https://github.com/paritytech/wasmi</a></p>
<p>Built for blockchain to ensure high degree of correctness (security, determinism). Interpreted, hence slower.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>The current preference is to use <code>thiserror</code> for most code and <code>eyre</code> for reporting errors at the CLI level and the client.</p>
<p>To make the code robust, we should avoid using code that may panic for errors that recoverable and handle all possible errors explicitly. Two exceptions to this rule are:</p>
<ul>
<li>prototyping, where it's fine to use <code>unwrap</code>, <code>expect</code>, etc.</li>
<li>in code paths with conditional compilation <strong>only</strong> for development build, where it's preferable to use <code>expect</code> in place of <code>unwrap</code> to help with debugging</li>
</ul>
<p>In case of panics, we should provide an error trace that is helpful for trouble-shooting and debugging.</p>
<p>A great post on error handling library/application distinction: <a href="https://nick.groenen.me/posts/rust-error-handling/">https://nick.groenen.me/posts/rust-error-handling/</a>.</p>
<p>The considered DBs:</p>
<ul>
<li>thiserror</li>
<li>anyhow</li>
<li>eyre</li>
</ul>
<p>The current preference is to use eyre at the outermost modules to print any encountered errors nicely back to the user and thiserror elsewhere.</p>
<h2 id="thiserror"><a class="header" href="#thiserror">Thiserror</a></h2>
<ul>
<li><a href="https://crates.io/crates/thiserror">https://crates.io/crates/thiserror</a></li>
</ul>
<p>Macros for user-derived error types. Commonly used for library code.</p>
<h2 id="anyhow"><a class="header" href="#anyhow">Anyhow</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">https://crates.io/crates/anyhow</a></li>
</ul>
<p>Easy error handling helpers. Commonly used for application code.</p>
<h2 id="eyre"><a class="header" href="#eyre">Eyre</a></h2>
<ul>
<li><a href="https://crates.io/crates/eyre">https://crates.io/crates/eyre</a></li>
</ul>
<p>Fork of <code>anyhow</code> with custom error reporting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li><strong>intent gossip</strong>
The intent gossip network must maintain a mempool of intents and gossips them
via a p2p layer. Each intent gossip node maintains a list of interests that
describe what intents it is interested in.</li>
<li><strong>intent</strong>
An expression of intent describes a particular trade an account agrees to.</li>
<li><strong>matchmaker</strong>
The matchmaker tries to match intents together. For each match it crafts a valid
transaction and submits it to the base ledger.</li>
<li><strong>validity predicate (VP)</strong>
A <a href="explore/design//explore/design/ledger/vp.html">validity predicate</a> is a piece of code
attached to an account that can accept or reject any state changes performed by
a transaction in its sub-space.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-1"><a class="header" href="#resources-1">Resources</a></h1>
<p>Please add anything relevant to the project that you'd like to share with others, such as research papers, blog posts or tutorials. If it's not obvious from the title, please add some description.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li><a href="https://github.com/rust-in-blockchain/awesome-blockchain-rust">https://github.com/rust-in-blockchain/awesome-blockchain-rust</a></li>
</ul>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<ul>
<li><a href="https://github.com/mre/idiomatic-rust">https://github.com/mre/idiomatic-rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<h2 id="vscode"><a class="header" href="#vscode">VsCode</a></h2>
<p>Some handy extensions (output of <code>code --list-extensions</code>):</p>
<pre><code class="language-shell">aaron-bond.better-comments
be5invis.toml
bodil.file-browser
bungcip.better-toml
DavidAnson.vscode-markdownlint
jacobdufault.fuzzy-search
kahole.magit
matklad.rust-analyzer
oderwat.indent-rainbow
# easy to see if crates are up-to-date and update if not
serayuzgur.crates
streetsidesoftware.code-spell-checker
vscodevim.vim
# this is like https://www.spacemacs.org/ but in VsCode
VSpaceCode.vspacecode
VSpaceCode.whichkey
# org-mode
vscode-org-mode.org-mode
publicus.org-checkbox
</code></pre>
<p>Add these to your settings.json to get rustfmt and clippy with the nightly version that we use:</p>
<pre><code class="language-json">&quot;rust-analyzer.checkOnSave.overrideCommand&quot;: [
    &quot;cargo&quot;,
    &quot;+nightly-2021-08-04&quot;,
    &quot;clippy&quot;,
    &quot;--workspace&quot;,
    &quot;--message-format=json&quot;,
    &quot;--all-targets&quot;
],
&quot;rust-analyzer.rustfmt.overrideCommand&quot;: [
    &quot;rustup&quot;,
    &quot;run&quot;,
    &quot;nightly-2021-08-04&quot;,
    &quot;--&quot;,
    &quot;rustfmt&quot;,
    &quot;--edition&quot;,
    &quot;2018&quot;,
    &quot;--&quot;
],
</code></pre>
<p>When editing the wasms source (i.e. <code>wasm/wasm_source/src/..</code>), open the <code>wasm/wasm_source</code> as a workspace to get rust-analyzer working (because the crate is excluded from the root cargo workspace) and then active <code>--all-features</code> for it in the preferences.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>two main mode:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-mode">rust-mode</a>
official mode supported by rust dev</li>
<li><a href="https://github.com/brotzeit/rustic">rustic-mode</a>
forked with more option and better integration/default value</li>
</ul>
<h2 id="config-example-with-rustic-and-use-package"><a class="header" href="#config-example-with-rustic-and-use-package">config example with rustic and use-package</a></h2>
<pre><code class="language-elisp">    ;; all flycheck not mandatory not mandatory
  (use-package flycheck
    :commands flycheck-mode
    :init (global-flycheck-mode))

  (use-package flycheck-color-mode-line
    :after flycheck
    :hook
    (flycheck-mode . flycheck-color-mode-line-mode))

  (use-package flycheck-pos-tip
    :after flycheck)
  (use-package lsp-mode
    :after flycheck
    :bind-keymap
    (&quot;C-c i&quot; .  lsp-command-map)
    :hook
    (lsp-mode . lsp-enable-which-key-integration) ;; if wichkey installed
    :commands (lsp lsp-deferred)
    :custom
    (lsp-eldoc-render-all t)
    (lsp-idle-delay 0.3)
    )

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :custom
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-max-height 30)
    :hook (lsp-mode . lsp-ui-mode))

    ;; if ivy installed installed
  (use-package lsp-ivy
    :after lsp-mode ivy
    :commands lsp-ivy-workspace-symbol)

    ;; if company installed
  (use-package company-lsp
    :after lsp-mode company
    :init
    (push 'company-lsp company-backend))

  (use-package rustic
    :bind (:map rustic-mode-map
                (&quot;M-j&quot; . lsp-ui-imenu)
                (&quot;M-?&quot; . lsp-find-references)
                (&quot;C-c C-c ?&quot; . lsp-describe-thing-at-point)
                (&quot;C-c C-c !&quot; . lsp-execute-code-action)
                (&quot;C-c C-c r&quot; . lsp-rename)
                (&quot;C-c C-c TAB&quot; . lsp-rust-analyzer-expand-macro)
                (&quot;C-c C-c q&quot; . lsp-workspace-restart)
                (&quot;C-c C-c Q&quot; . lsp-workspace-shutdown)
                (&quot;C-c C-c s&quot; . lsp-rust-analyzer-status)
                (&quot;C-c C-c C-a&quot; . rustic-cargo-add)
                (&quot;C-c C-c C-d&quot; . rustic-cargo-rm)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-upgrade)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-outdated))
    :hook
    (rustic-mode . lsp-deferred)
    :custom
    (lsp-rust-analyzer-cargo-watch-command &quot;clippy&quot;)
    :config
    (rustic-doc-mode t)
  )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifications"><a class="header" href="#specifications">Specifications</a></h1>
<p><a href="https://anoma.network/papers/whitepaper.pdf">Anoma</a> is a sovereign, proof-of-stake blockchain protocol that enables private, asset-agnostic cash and private bartering among any number of parties.</p>
<p>This specification defines the Anoma ledger's protocol and its components and the intent gossip and matchmaking system.</p>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/rfc/rfc2119">RFC-2119</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>At a high level, Anoma is composed of two main components: the distributed ledger and the intent gossip / matchmaking system. While they are designed to complement each other, they can be operated separately.</p>
<h2 id="the-ledger-1"><a class="header" href="#the-ledger-1">The ledger</a></h2>
<p>The ledger is a distributed state machine, relying on functionality provided by <a href="https://docs.tendermint.com/master/spec/">Tendermint</a> such as its BFT consensus algorithm with instant finality, P2P networking capabilities, transaction mempool and more. The ledger state machine is built on top the <a href="https://docs.tendermint.com/master/spec/abci/">ABCI</a>.</p>
<p>For block validator voting power assignment, the ledger employs a proof-of-stake system.</p>
<p>The ledger's key-value storage is organized into blocks and user specific state is organized into accounts. The state machine executes transactions, which can apply arbitrary changes to the state that are validated by validity predicates associated with the accounts involved in the transaction.</p>
<p>To prevent transaction front-running, the ledger employs a DKG scheme as implemented in <a href="https://github.com/anoma/ferveo">Ferveo</a>. Using this scheme, transactions are encrypted before being submitted to the ledger. The encrypted transactions are committed by a block proposer to a specific order in which they must be executed once decrypted.</p>
<ul>
<li>TODO add fractal scaling &amp; protocol upgrade system overview</li>
</ul>
<h2 id="the-intent-gossip-with-matchmaking-system"><a class="header" href="#the-intent-gossip-with-matchmaking-system">The intent gossip with matchmaking system</a></h2>
<ul>
<li>TODO add an overview</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger-2"><a class="header" href="#the-ledger-2">The ledger</a></h1>
<h2 id="the-protocol"><a class="header" href="#the-protocol">The protocol</a></h2>
<ul>
<li>TODO describe DKG transactions</li>
<li>TODO DKG transactions will include replay protection (this is because we can simply check a counter against the source (i.e. gas payer) of the transaction before the transactions order is committed to by the DKG protocol, which could affect the expected counter order for sources with multiple queued transactions)</li>
</ul>
<h3 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h3>
<p>A transaction <a href="specs/./encoding.html#transactions">encoded with proto3</a> received from ABCI <code>DeliverTx</code> method is executed in two main steps:</p>
<ol>
<li><a href="specs/ledger.html#transaction-execution">Transaction execution</a></li>
<li><a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a></li>
</ol>
<h4 id="transaction-execution"><a class="header" href="#transaction-execution">Transaction execution</a></h4>
<p>For any error encountered in any of the following steps of transaction execution, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<ol>
<li>Charge a base transaction <a href="specs/ledger.html#gas">gas</a>:
\[ \verb|BASE_TRANSACTION_FEE| \]</li>
<li>Decode the transaction bytes and validate the data. The field <code>timestamp</code> is required.</li>
<li>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the <code>code</code> field of the transaction (this is because the WASM code is compiled with a single-pass compiler):
\[ \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \]</li>
<li><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> from the <code>code</code> field of the transaction.</li>
<li>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</li>
<li>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</li>
<li>Compile the transaction <code>code</code> with a single-pass compiler (for example, <a href="https://medium.com/wasmer/a-webassembly-compiler-tale-9ef37aa3b537">the Wasmer runtime single-pass compiler</a>). The compilation computational complexity MUST be linear in proportion to the <code>code</code> size.</li>
<li>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_MAX_PAGES</code></a>.</li>
<li>Instantiate the WASM module with imported <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a> and the instantiated WASM memory.</li>
<li>Write the transaction's <code>data</code> into the memory exported from the WASM module instance.</li>
<li>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:
<pre><code class="language-wat">func (param i64 i64)
</code></pre>
The first argument is the offset to the <code>data</code> input written into the memory and the second argument is its bytes length.</li>
</ol>
<p>If the transaction executed successfully, it is followed <a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a>.</p>
<h4 id="validity-predicates-check"><a class="header" href="#validity-predicates-check">Validity predicates check</a></h4>
<p>For the transaction to be valid, all the triggered validity predicates must accept it.</p>
<p>First, the addresses whose validity predicates should be triggered by the transaction are determined. In this process, the addresses get associated with a set of modified storage keys that are relevant to the address:</p>
<ol>
<li>
<p>The addresses set by the transaction (see <code>insert_verifier</code> in <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a>) are associated with <em>all</em> the modified storage keys.</p>
<p>TODO - <a href="https://github.com/anoma/anoma/issues/292">https://github.com/anoma/anoma/issues/292</a></p>
</li>
<li>
<p>The storage keys that were modified by the transaction are associated with the addresses included in the storage keys. Note that a storage key may contain more than one address, in which case all its addresses are associated with this key. </p>
</li>
<li>
<p>All these addresses are additionally associated with the storage key to the validity predicates of any newly initialized accounts' by the transaction (see <code>init_account</code> in <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a>).</p>
</li>
</ol>
<p>For all these addresses, attempt to read their validity predicate WASM code from the storage. For each validity predicate look-up, charge storage read gas and WASM compilation gas, proportional to the bytes length of the validity predicate. If any of the validity predicates look-ups fails, or any validity rejects the transaction or fails anywhere in the execution, the whole transaction is rejected. If the transaction is rejected, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<p>Execute all validity predicates in parallel as follows:</p>
<ol>
<li>Charge WASM compilation gas, proportional to the bytes length of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler).</li>
<li>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler): \[ \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \].</li>
<li><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> of the validity predicate.</li>
<li>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</li>
<li>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</li>
<li>Compile the validity predicate with single-pass compiler. The compilation computational complexity MUST be linear in proportion to its bytes size.</li>
<li>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_MAX_PAGES</code></a>.</li>
<li>Instantiate the WASM module with imported <a href="specs/ledger.html#validity-predicate-host-environment-functions">validity predicate host environment functions</a> and the instantiated WASM memory.</li>
<li>Write the address of the validity predicate’s owner, the transaction <code>data</code>, the modified storage keys encoded with Borsh, and all the triggered validity predicates owners' addresses encoded with Borsh into the memory exported from the WASM module instance.</li>
<li>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:
<pre><code class="language-wat">func (param i64 i64 i64 i64 i64 i64 i64 i64) (result i64))
</code></pre>
<ul>
<li>The first argument is the offset to the owner’s address written into the memory, the second argument is its bytes length</li>
<li>The third is the offset of the transaction’s <code>data</code> and fourth is it’s bytes length</li>
<li>The fifth is the offset of the modified storage keys and sixth is its bytes length</li>
<li>The seventh is the offset of the triggered validity predicates owners' addresses and eighth is its bytes length</li>
</ul>
</li>
</ol>
<h4 id="gas"><a class="header" href="#gas">Gas</a></h4>
<h5 id="gas-constants"><a class="header" href="#gas-constants">Gas constants</a></h5>
<p>The gas constants are currently chosen arbitrarily and are subject to change following gas accounting estimations.</p>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td><code>COMPILE_GAS_PER_BYTE</code></td><td>1</td></tr>
<tr><td><code>BASE_TRANSACTION_FEE</code></td><td>2</td></tr>
<tr><td><code>PARALLEL_GAS_DIVIDER</code></td><td>10</td></tr>
<tr><td><code>MIN_STORAGE_GAS</code></td><td>1</td></tr>
</tbody></table>
<ul>
<li>TODO describe gas accounting, wasm gas counter, limits, what happens if we go over limits and how gas relates to fees</li>
</ul>
<h4 id="webassembly-wasm"><a class="header" href="#webassembly-wasm">WebAssembly (WASM)</a></h4>
<h5 id="wasm-constants"><a class="header" href="#wasm-constants">WASM constants</a></h5>
<table><thead><tr><th>Name</th><th>Unit</th><th>Value</th></tr></thead><tbody>
<tr><td><code>PAGE</code> (as defined in the WASM spec)</td><td>kiB</td><td>64</td></tr>
<tr><td><code>TX_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>TX_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>VP_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>VP_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>WASM_STACK_LIMIT</code></td><td>stack depth</td><td>65535</td></tr>
</tbody></table>
<p>The WASM instantiation, the types, instructions, validation and execution of WASM modules MUST conform to the <a href="https://webassembly.github.io/spec/core/intro/index.html">WebAssembly specification</a>.</p>
<h5 id="wasm-validation"><a class="header" href="#wasm-validation">WASM validation</a></h5>
<p>The WebAssembly code is REQUIRED to only use deterministic instructions. Furthermore, it MUST NOT use features from any of the following WebAssembly proposals:</p>
<ul>
<li>The reference types proposal</li>
<li>The multi-value proposal</li>
<li>The bulk memory operations proposal</li>
<li>The module linking proposal</li>
<li>The SIMD proposal</li>
<li>The threads proposal</li>
<li>The tail-call proposal</li>
<li>The multi memory proposal</li>
<li>The exception handling proposal</li>
<li>The memory64 proposal</li>
</ul>
<h5 id="stack-height-limiter"><a class="header" href="#stack-height-limiter">Stack height limiter</a></h5>
<p>To make stack overflows deterministic, set the upper bound of the stack size to <a href="specs/ledger.html#wasm-constants"><code>WASM_STACK_LIMIT</code></a>. If the stack height exceeds the limit then execution MUST abort.</p>
<!--
cargo test test_tx_stack_limiter
cargo test test_vp_stack_limiter
-->
<h5 id="wasm-memory-1"><a class="header" href="#wasm-memory-1">WASM memory</a></h5>
<ul>
<li>TODO memory read/write gas costs</li>
</ul>
<h5 id="transaction-host-environment-functions"><a class="header" href="#transaction-host-environment-functions">Transaction host environment functions</a></h5>
<p>The following functions from the host ledger are made available in transaction's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime:</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_tx_read&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_has_key&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_write&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_delete&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_insert_verifier&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_update_validity_predicate&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_init_account&quot; (func (param i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_log_string&quot; (func (param i64 i64)))
</code></pre>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<ul>
<li><code>anoma_tx_init_account</code> TODO newly created accounts' validity predicates aren't used until the block is committed (i.e. only the transaction that created the account may write into its storage in the block in which its being applied).</li>
<li>TODO describe functions in detail</li>
</ul>
<h5 id="validity-predicate-host-environment-functions"><a class="header" href="#validity-predicate-host-environment-functions">Validity predicate host environment functions</a></h5>
<p>The following functions from the host ledger are made available in validity predicate's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime.</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_vp_read_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_read_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_pre_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_post_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_verify_tx_signature&quot; (func (param i64 i64 i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_eval&quot; (func (param i64 i64 i64 i64) (result i64)))
</code></pre>
<ul>
<li>TODO describe functions in detail</li>
</ul>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<h3 id="storage-3"><a class="header" href="#storage-3">Storage</a></h3>
<ul>
<li>TODO</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding"><a class="header" href="#encoding">Encoding</a></h1>
<p>All the data fields are REQUIRED, unless specified otherwise.</p>
<h2 id="the-ledger-3"><a class="header" href="#the-ledger-3">The ledger</a></h2>
<h3 id="transactions-2"><a class="header" href="#transactions-2">Transactions</a></h3>
<p>Transactions MUST be encoded using <a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec">proto3</a> in the format as defined for <a href="specs/encoding.html#proto-definitions"><code>message Tx</code></a>.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Field Number</th></tr></thead><tbody>
<tr><td>code</td><td>bytes</td><td>Transaction WASM code.</td><td>1</td></tr>
<tr><td>data</td><td>optional bytes</td><td>Transaction data (OPTIONAL).</td><td>2</td></tr>
<tr><td>timestamp</td><td>google.protobuf.Timestamp</td><td>Timestamp of when the transaction was created.</td><td>3</td></tr>
</tbody></table>
<h2 id="proto-definitions"><a class="header" href="#proto-definitions">Proto definitions</a></h2>
<pre><code>syntax = &quot;proto3&quot;;

import &quot;google/protobuf/timestamp.proto&quot;;

package types;

message Tx {
  bytes code = 1;
  // TODO this optional is useless because it's default on proto3
  optional bytes data = 2;
  google.protobuf.Timestamp timestamp = 3;
}

message Intent {
  bytes data = 1;
  google.protobuf.Timestamp timestamp = 2;
}

message IntentGossipMessage{
  // TODO remove oneof because it's not used so far
  oneof msg {
    Intent intent = 1;
  }
}

message Dkg {
  string data = 1;
}

message DkgGossipMessage{
  oneof dkg_message {
    Dkg dkg = 1;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playnet"><a class="header" href="#playnet">Playnet</a></h1>
<p>🕹🎮👾 Welcome to the very first Anoma testnet and thank you for joining us! 🕹🎮👾</p>
<p>The main goals of this testnet is to try out some of the functionality of the ledger, intent gossip and the matchmaker and to get some early feedback on its current state. To give feedback, ask questions and report issues, please use the #playnet Slack channel. Many issues and limitations are well known and our test coverage is currently very low, so please excuse Anoma while it is rough around the edges.</p>
<p>You can interact with Anoma via transactions, validity predicates and intents turned into transactions by the matchmaker. Because we don't have a proper wallet yet, each of us will have a pre-generated account address and a wallet key on the genesis block. Because all the keys are public, please respect others' keys and do not use them to sign stuff :)</p>
<h2 id="-install"><a class="header" href="#-install">💾 Install</a></h2>
<p>You can either use the pre-built binaries we've released on Github or build from source. If you'll want to customize any of the wasm code (transactions, validity predicates and/or matchmaker), we recommend that you build from source to have the source available.</p>
<h3 id="pre-built-binaries"><a class="header" href="#pre-built-binaries">Pre-built binaries</a></h3>
<p>We have built for Mac (darwin_amd64) and Linux (linux_amd64). If you're not on one of these, you'll have to build from the source.</p>
<p>Download the release for your platform from <a href="https://github.com/anoma/anoma/releases">https://github.com/anoma/anoma/releases</a>. They are packaged with Tendermint, which will be used by the Anoma node.</p>
<pre><code class="language-shell"># Extract the archive
tar -xf anoma_0.1_darwin_amd64.tar.gz

cd anoma

# Add the executables to your $PATH
export PATH=&quot;$(pwd):$PATH&quot;
</code></pre>
<p>And you're ready to go!</p>
<h3 id="build-from-the-source"><a class="header" href="#build-from-the-source">Build from the source</a></h3>
<pre><code class="language-shell"># Clone the repo
git clone https://github.com/anoma/anoma.git
# or
git clone git@github.com:anoma/anoma.git

cd anoma

# Checkout the release branch
git checkout v0.1-playnet

# Build and link the executables
make install
</code></pre>
<p>You'll also need to install Tendermint v0.34.* and have it available on your $PATH, e.g.:</p>
<pre><code class="language-shell">apt install tendermint
nix-env -i tendermint
</code></pre>
<p>Or you can get it from <a href="https://github.com/tendermint/tendermint/releases">https://github.com/tendermint/tendermint/releases</a>.</p>
<p>To modify and build any of the wasm source codes:</p>
<pre><code># Run this first if you don't have Rust wasm target installed:
make -C txs/tx_template deps

# If you modify e.g. the transaction template (txs/template/src/lib.rs), you can build it with
make -C txs/tx_template
</code></pre>
<h2 id="-addresses"><a class="header" href="#-addresses">📇 Addresses</a></h2>
<p>The following are the addresses that we have included in the genesis block. You can add them to your shell to use them in commands. You should be able to find your own address among them:</p>
<pre><code class="language-shell"># User addresses
export adrian=a1qq5qqqqqxgeyzdeng4zrw33sxez5y3p3xqerz3psx5e5x32rg3rryw2ygc6yy3p4xpq5gvfnw3nwp8
export alberto=a1qq5qqqqq8yerw3jxx565y333gfpnjwzygcc5zd6xxarr2dzzgcm5xv3kxazrjve589p5vv34vl0yy3
export ash=a1qq5qqqqqxue5vs69xc6nwvfcgdpyy3pnxv6rxw2zx3zryv33gyc5xdekxaryydehgvunsvzz2hjedu
export awa=a1qq5qqqqqg565zv34gcc52v3nxumr23z9gezrj3pnx56rwse4xc6yg3phgcun2d33xyenqv2x4xyw62
export celso=a1qq5qqqqq8qmrwsjyxcerqwzpx9pnzve3gvc5xw29gdqnvv2yx5mrvsjpxgcrxv6pg5engvf5hgjscj
export chris=a1qq5qqqqqgye5xwpcxqu5z3p4g5ens3zr8qm5xv69xfznvwzzx4p5xwpkxc6n2v6x8yc5gdpeezdqc4
export gabriella=a1qq5qqqqq8ycn2djrxqmnyd3sxcunsv2zgyeyvwzpgceyxdf3xyu5gv2pgeprxdfe8ycrzwzzkezpcp
export gianmarco=a1qq5qqqqq89prqsf38qcrzd6zxym5xdfjg4pyg3pjg3pyx32zg5u5y3jpgc65zdej8pznwwf3jqzsws
export joe=a1qq5qqqqqgvuyv335g9z5v32xgdz523zxgsuy23fjxazrjve5g4pnydphxyu5v33cxarrzd692045xh
export nat=a1qq5qqqqq89rygsejx9q5yd6pxpp5x3f38ymyydp3xcu523zzx4prw3fc8qu5vvjpxyeyydpnfha6qt
export simon=a1qq5qqqqqgfqnqdecxcurq33hxcey2sf4g5mygdjyxfrrjse4xyc52vpjxyenwve4gv6njsecz4tzen
export sylvain=a1qq5qqqqqgccnyvp3gyergvp5xgmr2s3s8yung3f4gdq52wzpxvurysfhgycnwd29xfryxvekfwc00t
export tomas=a1qq5qqqqqggcrzsfj8ym5g3psxuurxv2yxseyxwpsxdpy2s35gsc5zdzpx9pyxde48ppnqd3cnzlava
export yuji=a1qq5qqqqqgvcrz3f5x4prssj9x5enydecxfznzdj9g5cnj3fcxarrxdjpx5cnwv69xye5vvfeva4z85

# Token Addresses
export XAN=a1qq5qqqqqxuc5gvz9gycryv3sgye5v3j9gvurjv34g9prsd6x8qu5xs2ygdzrzsf38q6rss33xf42f3
export BTC=a1qq5qqqqq8q6yy3p4xyurys3n8qerz3zxxeryyv6rg4pnxdf3x3pyv32rx3zrgwzpxu6ny32r3laduc
export ETH=a1qq5qqqqqxeryzvjxxsmrj3jpxapygve58qerwsfjxaznvd3n8qenyv2ygsc52335xue5vve5m66gfm
export XTZ=a1qq5qqqqqx3z5xd3ngdqnzwzrgfpnxd3hgsuyx3phgfry2s3kxsc5xves8qe5x33sgdprzvjptzfry9
export DOGE=a1qq5qqqqqx9rrq3zrg5myzv3eg9zyxvf3gery2dfhgg6nsdjrxscrgv6rgsunx33sxg6nvdjrkujezz
</code></pre>
<h2 id="-the-nodes"><a class="header" href="#-the-nodes">፨ The nodes</a></h2>
<p>There are 4 ledger validator and intent gossip nodes running in cloud at:</p>
<ul>
<li><code>52.210.23.30</code></li>
<li><code>63.34.55.152</code></li>
<li><code>54.195.72.213</code></li>
<li><code>79.125.112.218</code></li>
</ul>
<p>The ledger is pre-configured to connect to them.</p>
<p>To run a local ledger node:</p>
<pre><code class="language-shell">anoma run-ledger
</code></pre>
<p>To run the intent gossip with the matchmaker that can submit transactions to the local ledger:</p>
<pre><code class="language-shell">anoma run-gossip --rpc &quot;127.0.0.1:20202&quot; \
  --matchmaker-path matchmaker_template/matchmaker.wasm \
  --tx-code-path txs/tx_from_intent/tx.wasm \
  --ledger-address &quot;127.0.0.1:26657&quot;
</code></pre>
<p>If you don't have a local ledger running, the matchmaker can also submit transactions to a remote validator ledger, with e.g.:</p>
<pre><code class="language-shell">anoma run-gossip --rpc &quot;127.0.0.1:20202&quot; \
  --matchmaker-path matchmaker_template/matchmaker.wasm \
  --tx-code-path txs/tx_from_intent/tx.wasm \
  --ledger-address &quot;52.210.23.30:26657&quot;
</code></pre>
<h2 id="-wasm"><a class="header" href="#-wasm">🧮 WASM</a></h2>
<p>Currently, Anoma only supports wasm built from Rust code. This is used for validity predicates, transactions' code, matchmaker's logic and matchmaker's intent filter. We provide a prelude with functions specialized for each of these environments. Additionally, any library code that you may attempt to use in wasm has to be able to compile to wasm, which means no foreign function interface (e.g. C dependencies).</p>
<p>Because wasm doesn't have any built-in logging facilities nor access to stdout, trying to print from wasm has no effect. Instead, we provide <code>log_string</code> function in the wasm environment preludes. When the wasm is being executed, this will be printed from the node's log (search for <code>WASM Transaction log</code>, <code>WASM Validity predicate log</code> or <code>WASM Matchmaker log</code>). You can use the Rust's <code>format!</code> macro for the string that you want to print. Because we don't yet have an RPC client, this in combination with transactions' <code>--dry-run</code> flag is the best way to query the ledger's state.</p>
<p>To view the full list of functions available in wasm, please refer to:</p>
<ul>
<li><a href="https://heliaxdev.github.io/anoma-playnet/doc/anoma_vm_env/tx_prelude/index.html">Transaction prelude</a></li>
<li><a href="https://heliaxdev.github.io/anoma-playnet/doc/anoma_vm_env/vp_prelude/index.html">Validity predicate prelude</a></li>
<li><a href="https://heliaxdev.github.io/anoma-playnet/doc/anoma_vm_env/matchmaker_prelude/index.html">Matchmaker prelude</a></li>
</ul>
<h2 id="-validity-predicates"><a class="header" href="#-validity-predicates">☑️ Validity predicates</a></h2>
<p>Your account will be instantiated with a validity predicate built from the source code of <code>vps/vp_user/src/lib.rs</code> and a public key. This VP allows:</p>
<ul>
<li>for anyone to send you a token(s)</li>
<li>for you to send a token(s), which must be authorized by a signature with the key associated with your account</li>
<li>perform any changes to your account's storage, which must also be authorized by a signature</li>
<li>perform transactions created by the matchmaker from intents that were signed by your the key associated with your account</li>
</ul>
<p>You can customize this code and deploy it to the ledger with a transaction described below.</p>
<h2 id="-transactions"><a class="header" href="#-transactions">📩 Transactions</a></h2>
<p>A transaction consists of a wasm code and additional optional arbitrary data bytes. The data will be passed to the transaction as its input when it's being executed on-chain.</p>
<p>Any of the following commands can optionally be submitted with <code>--dry-run</code> argument to simulate transaction's execution without including it in a block.</p>
<h3 id="-a-simple-token-transfer"><a class="header" href="#-a-simple-token-transfer">💸 A simple token transfer</a></h3>
<p>To make a transfer of e.g. <code>10.1</code> of a fungible token <code>$XAN</code> from <code>$awa</code> to <code>$joe</code>:</p>
<pre><code class="language-shell">anoma client transfer --source $awa \
  --target $joe \
  --token $XAN \
  --amount 10.1 \
  --code-path txs/tx_transfer/tx.wasm
</code></pre>
<p>This client command will take care of signing the transaction using your key.</p>
<p>To check balances of fungible token, run e.g.:</p>
<pre><code class="language-shell">anoma client balances --address $adrian
</code></pre>
<h3 id="-update-an-accounts-validity-predicate"><a class="header" href="#-update-an-accounts-validity-predicate">♼ Update an account's validity predicate</a></h3>
<p>To update an account's validity predicate, you can customize the default user's VP at <code>vps/vp_user/src/lib.rs</code>, or built your own from scratch using <code>vps/vp_template/src/lib.rs</code>. To deploy to, use e.g.:</p>
<pre><code class="language-shell"># Compile the validity predicate
make -C vps/vp_user

# Submit a transaction with the updated VP to the ledger
anoma client update --address $awa --code-path vps/vp_user/vp.wasm
</code></pre>
<h3 id="-a-custom-transaction"><a class="header" href="#-a-custom-transaction">🦄 A custom transaction</a></h3>
<p>To submit a custom transaction, one can use the <code>txs/tx_template/src/lib.rs</code> to implement the transaction's effects. Optionally, you can attach arbitrary bytes to the transaction from a file with the <code>--data-path</code> argument.</p>
<p>For example:</p>
<pre><code class="language-shell"># Compile the transaction's code from the template
make -C txs/tx_template

# Submit the transaction to the ledger
anoma client tx --code-path txs/tx_template/tx.wasm --data-path tx.data
</code></pre>
<p>This transaction is by default not signed by any key, so if you try to use it make changes to your account's storage, it will be rejected by your validity predicate.</p>
<h2 id="-intents"><a class="header" href="#-intents">✋ Intents</a></h2>
<p>In general, intents are some data that describe what you'd like to do with your account. We provide a template for intents signed by the source key of the source address, which can describe a desire to trade one of the fungible tokens.</p>
<p>To create a file <code>intent.data</code> with the intent's data, use e.g.:</p>
<pre><code class="language-shell">anoma client craft-intent --address $awa \
  --token-buy $XTZ \
  --amount-buy 10 \
  --token-sell $BTC \
  --amount-sell 20 \
  --file-path intent.data
</code></pre>
<p>To submit the intent from the file to the intent gossip (which will propagate to matchmakers):</p>
<pre><code class="language-shell"># Without a local intent gossip node, using one of the cloud nodes
anoma client intent --node &quot;http://52.210.23.30:20202&quot; \
  --data-path intent.data \
  --topic &quot;asset_v0&quot;

# With a local intent gossip node
anoma client intent --node &quot;http://127.0.0.1:20202&quot; \
  --data-path intent.data \
  --topic &quot;asset_v0&quot;
</code></pre>
<p>Once a matchmaker finds suitable matches of intents that it decides are likely to be accepted, it will try to submit a transaction to a connected ledger.</p>
<p>For now, to match intents, their amounts have to match exactly. In future, there will more options on how intents can be specified and matched.</p>
<h2 id="-matchmaker"><a class="header" href="#-matchmaker">🤝 Matchmaker</a></h2>
<p>The provide matchmaker's code tries to match intents using a graph of intents in the format described above constructed with Tarjan's algorithm, but it also allows for you to write your own! The source code to the matchmaker is at <code>matchmaker_template/src/lib.rs</code>. To customize the transaction's code that is used to submit transactions from matched intent, you can update <code>txs/tx_from_intent/src/lib.rs</code>.</p>
<pre><code># build the matchmaker's code
make -C matchmaker_template

# build the matchmaker's transaction's code
make -C txs/tx_from_intent
</code></pre>
<p>And then restart the intent gossip with the matchmaker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>Deprecated pages archived for possible later re-use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-name-addresses"><a class="header" href="#domain-name-addresses">Domain name addresses</a></h1>
<p>The transparent addresses are similar to domain names and the ones used in e.g. <a href="https://eips.ethereum.org/EIPS/eip-137">ENS as specified in EIP-137</a> and <a href="https://nomicon.io/DataStructures/Account.html">account IDs in Near protocol</a>. These are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>A transparent address is a human-readable string very similar to a domain name, containing only alpha-numeric ASCII characters, hyphen (<code>-</code>) and full stop (<code>.</code>) as a separator between the &quot;labels&quot; of the address. The letter case is not significant and any upper case letters are converted to lower case. The last label of an address is said to be the top-level name and each predecessor segment is the sub-name of its successor.</p>
<p>The length of an address must be at least 3 characters. For compatibility with a legacy DNS TXT record, we'll use syntax as defined in <a href="https://www.ietf.org/rfc/rfc1034.txt">RFC-1034 - section 3.5 DNS preferred name syntax</a>. That is, the upper limit is 255 characters and 63 for each label in an address (which should be sufficient anyway); and the label must not begin or end with hyphen (<code>-</code>) and must not begin with a digit.</p>
<p>These addresses can be chosen by users who wish to <a href="archive/domain-name-addresses.html#initializing-a-new-account">initialize a new account</a>, following these rules:</p>
<ul>
<li>a new address must be initialized on-chain
<ul>
<li>each sub-label must be authorized by the predecessor level address (e.g. initializing address <code>free.eth</code> must be authorized by <code>eth</code>, or <code>gives.free.eth</code> by <code>free.eth</code>, etc.) </li>
<li>note that besides the address creation, each address level is considered to be a distinct address with its own dynamic storage sub-space and validity predicate.</li>
</ul>
</li>
<li>the top-level names under certain length (to be specified) cannot be initialized directly, they may be <a href="https://eips.ethereum.org/EIPS/eip-162">auctioned like in ENS registrar as described in EIP-162</a>.
<ul>
<li>some top-level names may be reserved</li>
</ul>
</li>
</ul>
<p>For convenience, the <code>anoma</code> top-level address is initially setup to allow initialization of any previously unused second-level address, e.g. <code>bob.anoma</code> (we may want to revise this before launch to e.g. auction the short ones, like with top-level names to make the process fairer).</p>
<p>Like in ENS, the addresses are stored on chain by their hash, encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a> (<a href="https://github.com/zcash/zips/issues/484">not yet adopted in Zcash</a>), which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>. Likewise, this is for two reasons:</p>
<ul>
<li>help preserve privacy of addresses that were not revealed publicly and to prevent trivial enumeration of registered names (of course, you can still try to enumerate by hashes)</li>
<li>using fixed-length string in the ledger simplifies gas accounting</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/mermaid.min.js"></script>
        <script type="text/javascript" src="assets/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
