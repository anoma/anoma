<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anoma - DOCS</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/custom.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user-guide/index.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user-guide/install.html"><strong aria-hidden="true">2.1.</strong> Install</a></li><li class="chapter-item expanded "><a href="user-guide/getting-started.html"><strong aria-hidden="true">2.2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="user-guide/wallet.html"><strong aria-hidden="true">2.3.</strong> The Wallet</a></li><li class="chapter-item expanded "><a href="user-guide/ledger.html"><strong aria-hidden="true">2.4.</strong> The Ledger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user-guide/ledger/pos.html"><strong aria-hidden="true">2.4.1.</strong> Interact with PoS</a></li><li class="chapter-item expanded "><a href="user-guide/ledger/customize.html"><strong aria-hidden="true">2.4.2.</strong> Customize</a></li></ol></li><li class="chapter-item expanded "><a href="user-guide/intent-gossip-and-matchmaker.html"><strong aria-hidden="true">2.5.</strong> The Intent gossip and Matchmaker</a></li></ol></li><li class="chapter-item expanded "><a href="explore/index.html"><strong aria-hidden="true">3.</strong> Exploration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/index.html"><strong aria-hidden="true">3.1.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/overview.html"><strong aria-hidden="true">3.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="explore/design/gossip.html"><strong aria-hidden="true">3.1.2.</strong> Gossip network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent_gossip.html"><strong aria-hidden="true">3.1.2.1.</strong> Intent gossip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent.html"><strong aria-hidden="true">3.1.2.1.1.</strong> Intent</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/topic.html"><strong aria-hidden="true">3.1.2.1.2.</strong> Topic</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/incentive.html"><strong aria-hidden="true">3.1.2.1.3.</strong> Incentive</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/matchmaker.html"><strong aria-hidden="true">3.1.2.1.4.</strong> Matchmaker</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/fungible_token.html"><strong aria-hidden="true">3.1.2.1.5.</strong> Fungible token</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/dkg.html"><strong aria-hidden="true">3.1.2.2.</strong> Distributed key generation gossip</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/ledger.html"><strong aria-hidden="true">3.1.3.</strong> The ledger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/ledger/parameters.html"><strong aria-hidden="true">3.1.3.1.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/epochs.html"><strong aria-hidden="true">3.1.3.2.</strong> Epochs</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/accounts.html"><strong aria-hidden="true">3.1.3.3.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/vp.html"><strong aria-hidden="true">3.1.3.4.</strong> Validity predicates</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/tx.html"><strong aria-hidden="true">3.1.3.5.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/wasm-vm.html"><strong aria-hidden="true">3.1.3.6.</strong> WASM VM</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/front-running.html"><strong aria-hidden="true">3.1.3.7.</strong> Front-running prevention</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/fractal-scaling.html"><strong aria-hidden="true">3.1.3.8.</strong> Fractal scaling</a></li><li class="chapter-item expanded "><a href="explore/design/upgrade-system.html"><strong aria-hidden="true">3.1.3.9.</strong> Upgrade system</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/storage.html"><strong aria-hidden="true">3.1.3.10.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/ledger/storage/data-schema.html"><strong aria-hidden="true">3.1.3.10.1.</strong> Data schema</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/ledger/pos-integration.html"><strong aria-hidden="true">3.1.3.11.</strong> PoS integration</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/crypto-primitives.html"><strong aria-hidden="true">3.1.4.</strong> Crypto primitives</a></li><li class="chapter-item expanded "><a href="explore/design/actors.html"><strong aria-hidden="true">3.1.5.</strong> Actors</a></li><li class="chapter-item expanded "><a href="explore/design/pos.html"><strong aria-hidden="true">3.1.6.</strong> Proof of Stake system</a></li></ol></li><li class="chapter-item expanded "><a href="explore/prototypes/index.html"><strong aria-hidden="true">3.2.</strong> Prototypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/prototypes/base-ledger.html"><strong aria-hidden="true">3.2.1.</strong> Base ledger</a></li><li class="chapter-item expanded "><a href="explore/prototypes/gossip-layer.html"><strong aria-hidden="true">3.2.2.</strong> Gossip layer</a></li></ol></li><li class="chapter-item expanded "><a href="explore/libraries/index.html"><strong aria-hidden="true">3.3.</strong> Libraries &amp; Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.1.</strong> Cryptography</div></li><li class="chapter-item expanded "><a href="explore/libraries/network.html"><strong aria-hidden="true">3.3.2.</strong> network</a></li><li class="chapter-item expanded "><a href="explore/libraries/cli.html"><strong aria-hidden="true">3.3.3.</strong> Command-line interface</a></li><li class="chapter-item expanded "><a href="explore/libraries/db.html"><strong aria-hidden="true">3.3.4.</strong> Database</a></li><li class="chapter-item expanded "><a href="explore/libraries/logging.html"><strong aria-hidden="true">3.3.5.</strong> Logging</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.6.</strong> Networking</div></li><li class="chapter-item expanded "><a href="explore/libraries/packaging.html"><strong aria-hidden="true">3.3.7.</strong> Packaging</a></li><li class="chapter-item expanded "><a href="explore/libraries/serialization.html"><strong aria-hidden="true">3.3.8.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="explore/libraries/wasm.html"><strong aria-hidden="true">3.3.9.</strong> WASM runtime</a></li><li class="chapter-item expanded "><a href="explore/libraries/errors.html"><strong aria-hidden="true">3.3.10.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/glossary.html"><strong aria-hidden="true">3.4.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="explore/resources/index.html"><strong aria-hidden="true">3.5.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/resources/ide.html"><strong aria-hidden="true">3.5.1.</strong> IDE</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="specs/index.html"><strong aria-hidden="true">4.</strong> Specifications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/overview.html"><strong aria-hidden="true">4.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="specs/ledger.html"><strong aria-hidden="true">4.2.</strong> The ledger</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Trade system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Intent gossip system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Fractal scaling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Upgrade system</div></li><li class="chapter-item expanded "><a href="specs/encoding.html"><strong aria-hidden="true">4.7.</strong> Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="archive/index.html"><strong aria-hidden="true">5.</strong> Archive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="archive/domain-name-addresses.html"><strong aria-hidden="true">5.1.</strong> Domain name addresses</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Anoma - DOCS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Anoma's docs!</p>
<h2 id="about-anoma"><a class="header" href="#about-anoma">About Anoma</a></h2>
<p><a href="https://anoma.network/">Anoma</a> is a sovereign, proof-of-stake blockchain protocol that enables private, asset-agnostic cash and private bartering among any number of parties. To learn more about the protocol, we recommend the following resources:</p>
<ul>
<li><a href="https://medium.com/anomanetwork/introducing-anoma-a-blockchain-for-private-asset-agnostic-bartering-dcc47ac42d9f">Introduction to Anoma Medium article</a></li>
<li><a href="https://anoma.network/papers/whitepaper.pdf">Anoma's Whitepaper</a></li>
<li><a href="https://anoma.network/papers/vision-paper.pdf">Anoma's Vision paper</a></li>
</ul>
<h3 id="anomas-current-testnet-feigenbaum"><a class="header" href="#anomas-current-testnet-feigenbaum">Anoma's current testnet: Feigenbaum</a></h3>
<p>Feigenbaum is the name of Anoma's first public testnet. Find <code>feigenbaum</code> on <a href="https://github.com/anoma/anoma/releases">Github</a>.</p>
<blockquote>
<p>‚ö†Ô∏è Here lay dragons: this codebase is still experimental, try at your own risk!</p>
</blockquote>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the documentation</a></h2>
<p>The three main sections of this book are:</p>
<ul>
<li><a href="./user-guide">User Guide</a>: explains basic concepts and interactions</li>
<li><a href="./explore">Exploration</a>: documents the process of exploring the design and implementation space for Anoma</li>
<li><a href="./specs">Specifications</a>: implementation independent technical specifications</li>
</ul>
<h3 id="the-source"><a class="header" href="#the-source">The source</a></h3>
<p>This book is written using <a href="https://rust-lang.github.io/mdBook/">mdBook</a> with <a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a> for diagrams, it currently lives in the <a href="https://github.com/anoma/anoma">Anoma repo</a>.</p>
<p>To get started quickly, in the <code>docs</code> directory one can:</p>
<pre><code class="language-shell"># Install dependencies
make dev-deps

# This will open the book in your default browser and rebuild on changes
make serve
</code></pre>
<p>The mermaid diagrams docs can be found at <a href="https://mermaid-js.github.io/mermaid">https://mermaid-js.github.io/mermaid</a>.</p>
<p><a href="https://github.com/anoma/anoma/issues">Contributions</a> to the contents and the structure of this book (nothing is set in stone) should be made via pull requests. Code changes that diverge from the spec should also update this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>Welcome to Anoma user guide!</p>
<p>This guide is intended to help you find how to install, operate and interact with the Anoma ledger and intent gossip nodes, the matchmaker, the client and the wallet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-install-anoma"><a class="header" href="#-install-anoma">üíæ Install Anoma</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Building from source requires at least 16GB of ram available and 4 core cpu</li>
<li>Free disk space of at least 60GB</li>
<li>At the moment we are not supporting windows</li>
</ul>
<p>There are different ways to install anoma.</p>
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<p>Download the source code from <a href="https://github.com/anoma/anoma">github anoma repo</a>.</p>
<pre><code class="language-shell">git clone https://github.com/anoma/anoma.git
</code></pre>
<p>To build from source you will have to install some dependecies:</p>
<ul>
<li>rust</li>
<li>clang</li>
<li>openssl</li>
<li>git</li>
<li>llvm</li>
</ul>
<p>For ubuntu users the following command should install everything necessary:</p>
<pre><code class="language-shell">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

apt-get install -y make git-core libssl-dev pkg-config libclang-12-dev
</code></pre>
<p>Last, to build and install anoma you can run the following command:</p>
<pre><code class="language-bash">make install
</code></pre>
<h2 id="github-release"><a class="header" href="#github-release">Github release</a></h2>
<p>Go to <a href="https://github.com/anoma/anoma/releases">anoma github release page</a> and download the last release.</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>Go to <a href="https://hub.docker.com/r/heliaxdev/anoma">heliaxdev dockerhub account</a> and pull the image.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>This guide assumes that the Anoma binaries are <a href="user-guide/./install.html">installed</a> and available on path. These are:</p>
<ul>
<li><code>anoma</code>: The main binary that can be used to interact with all the components of Anoma</li>
<li><code>anoman</code>: The ledger and intent gossiper node</li>
<li><code>anomac</code>: The client</li>
<li><code>anomaw</code>: The wallet</li>
</ul>
<p>The main binary <code>anoma</code> has sub-commands for all of the other binaries:</p>
<ul>
<li><code>anoma client = anomac</code></li>
<li><code>anoma node   = anoman</code></li>
<li><code>anoma wallet = anomaw</code></li>
</ul>
<p>To explore the command-line interface, add <code>--help</code> argument at any sub-command level to find out any possible sub-commands and/or arguments.</p>
<p>To configure your node to join the Feigenbaum public testnet, run:</p>
<pre><code class="language-bash">anoma client utils join-network --chain-id=anoma-feigenbaum-0.ebb9e9f9013
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-anoma-wallet"><a class="header" href="#the-anoma-wallet">The Anoma Wallet</a></h1>
<p>The Anoma wallet allows you to store and use addresses and keys by their alias.</p>
<p>The wallet's state is stored under <code>.anoma/{chain_id}/wallet.toml</code> (with the default <code>--base-dir</code>), which will be created for you if it doesn't already exist when you run any command that accesses the wallet. A newly created wallet will be pre-loaded with some default addresses.</p>
<p>For the ledger and intent gossip commands that use keys and addresses, you can enter their aliases as as defined in the wallet (case-sensitive).</p>
<p>By default, keys are stored encrypted (unless the <code>--unsafe-dont-encrypt</code> flag is used). Currently, the Anoma client can load the password via:</p>
<ul>
<li>file, by exporting an ENV variable called <code>ANOMA_WALLET_PASSWORD_FILE</code> with value containing the path to a file containing the password.</li>
<li>env variable, by exporting a ENV variable called <code>ANOMA_WALLET_PASSWORD</code> with value of the actual password.</li>
<li>stdin, the client will prompt for a password.</li>
</ul>
<h2 id="-keys"><a class="header" href="#-keys">üîê Keys</a></h2>
<p>For cryptographic signatures, we currently support ed25519 keys. More will be added in future.</p>
<p>To manage keys, various sub-commands are available, see the commands <code>--help</code>:</p>
<pre><code class="language-shell">anoma wallet key
</code></pre>
<p>List all known keys:</p>
<pre><code class="language-shell">anoma wallet key list
</code></pre>
<p>Generate a new key:</p>
<pre><code class="language-shell">anoma wallet key gen --alias my-key
</code></pre>
<p>Note that this will also save an implicit address derived from this public key under the same alias. More about addresses below. This command has the same effect as <code>address gen</code>.</p>
<h2 id="-addresses"><a class="header" href="#-addresses">üìá Addresses</a></h2>
<p>All accounts in the Anoma ledger have a unique address, exactly one validity predicate and optionally any additional data in its dynamic storage sub-space.</p>
<p>There are currently 3 types of account addresses:</p>
<ul>
<li>Established: Used for accounts that allow the deployment of custom validation logic. These must be created on-chain via a transaction (see <a href="user-guide/./ledger.html#-initialize-an-account">the Ledger guide</a>). The address is generated on-chain and is not known until the transaction is applied.</li>
<li>Implicit, <em>not yet fully supported in the ledger</em>: Derived from a key, which can be used to authorize certain transactions from the account. They can be used as recipients of transactions without even when the account has not been used on-chain before.</li>
<li>Internal: Special internal accounts, such as protocol parameters account, PoS and IBC</li>
</ul>
<p>To manage addresses, similar to keys, various sub-commands are available:</p>
<pre><code class="language-shell">anoma wallet address
</code></pre>
<p>List all known addresses:</p>
<pre><code class="language-shell">anoma wallet address list
</code></pre>
<p>Generate a new implicit address:</p>
<pre><code class="language-shell">anoma wallet address gen --alias my-account
</code></pre>
<p>Note that this will also generate and save a key from which the address derived and save it under the same alias. Thus, this command has the same effect as <code>key gen</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-anoma-ledger"><a class="header" href="#the-anoma-ledger">The Anoma Ledger</a></h1>
<p>To start a local Anoma ledger node, run:</p>
<pre><code class="language-shell">anoma ledger
</code></pre>
<p>The node will attempt to connect to the persistent validator nodes and other peers in the network, and synchronize to the latest block.</p>
<p>By default, the ledger will store its configuration and state in the <code>.anoma</code> directory relative to the current working directory. You can use the <code>--base-dir</code> CLI global argument or <code>ANOMA_BASE_DIR</code> environment variable to change it.</p>
<p>If not found on start up, the ledger will generate a configuration file at <code>.anoma/config.toml</code>.</p>
<p>The ledger also needs access to the built WASM files that are used in the genesis block. These files are included in release and shouldn't be modified, otherwise your node will fail with a consensus error on the genesis block. By default, these are expected to be in the <code>wasm</code> directory, relative to the current working directory. This can also be set with the <code>--wasm-dir</code> CLI global argument, <code>ANOMA_WASM_DIR</code> environment variable or the configuration file.</p>
<h2 id="-initialize-an-account"><a class="header" href="#-initialize-an-account">üìù Initialize an account</a></h2>
<p>If you already have a key in your wallet, you can skip this step and use it in the following commands. Otherwise, generate a new key now:</p>
<pre><code class="language-shell">anoma wallet key gen --alias my-key
</code></pre>
<p>Then send a transaction to initialize the account and save its address with the alias <code>my-new-acc</code>. The <code>my-key</code> public key will be written into the account's storage for authorizing future transactions. We also sign this transaction with <code>my-key</code>.</p>
<pre><code class="language-shell">anoma client init-account \
  --alias my-new-acc \
  --public-key my-key \
  --source my-key
</code></pre>
<p>Once this transaction has been applied, the client will automatically see the new address created by the transaction and add it to your <a href="user-guide/./wallet.html">wallet</a> with the chosen alias <code>my-new-acc</code>.</p>
<p>By default, this command will use the prebuilt user validity predicate (from the <a href="https://github.com/anoma/anoma/blob/fb445f67ffe3afe3bf50eb71658b01ff760e909d/wasm/wasm_source/src/vp_user.rs">vp_user</a> source). You can supply a different validity predicate with the <code>--code-path</code> argument. We'll come back to this topic and cover how to write and deploy custom validity predicates in the <a href="user-guide/ledger/customize.html#-validity-predicates">custom validity predicates section</a>.</p>
<h2 id="-token-transactions-and-queries"><a class="header" href="#-token-transactions-and-queries">üí∏ Token transactions and queries</a></h2>
<p>In Anoma, tokens are implemented as accounts with a token validity predicate. It checks that its total supply is preserved in any transaction that uses this token. Your wallet will be pre-loaded with some token addresses that are initialized in the genesis block.</p>
<p>You can see the tokens addresses known by the client when you query all tokens balances:</p>
<pre><code class="language-shell">anoma client balance
</code></pre>
<p>XAN is Anoma's native token. To obtain some tokens in a testnet, there is a special &quot;faucet&quot; account that allows anyone to withdraw up to 1000 of any token for a single transaction. You can find the address of this account in your wallet. To get some tokens from the faucet account:</p>
<pre><code class="language-shell">anoma client transfer \
  --source faucet \
  --target my-new-acc \
  --signer my-new-acc \
  --token XAN \
  --amount 1000
</code></pre>
<p>Note that because you don't have the key to sign a transfer from the faucet account, in the command above, we set the <code>--signer</code> explicitly to your account's address.</p>
<p>To submit a regular token transfer from your account to the <code>validator-1</code> address:</p>
<pre><code class="language-shell">anoma client transfer \
  --source my-new-acc \
  --target validator-1 \
  --token XAN \
  --amount 10
</code></pre>
<p>This command will attempt to find and use the key of the source address to sign the transaction.</p>
<p>To query token balances for a specific token and/or owner:</p>
<pre><code class="language-shell">anoma client balance --token XAN --owner my-new-acc
</code></pre>
<p>Note that for any client command that submits a transaction (<code>init-account</code>, <code>transfer</code>, <code>tx</code>, <code>update</code> and <a href="user-guide/ledger/pos.html">PoS transactions</a>), you can use the <code>--dry-run</code> flag to simulate the transaction being applied in the block, to see what its result would be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-interacting-with-the-proof-of-stake-system"><a class="header" href="#-interacting-with-the-proof-of-stake-system">üîè Interacting with the Proof-of-Stake system</a></h1>
<p>The Anoma Proof of Stake system uses the XAN token as the staking token. It features delegation to any number of validators and customizable validator validity predicates.</p>
<p>The PoS system is implemented as an account with a validity predicate that governs the rules of the system. You can find its address in your wallet:</p>
<pre><code class="language-shell">anoma wallet address find --alias PoS
</code></pre>
<p>The system relies on the concept of epochs. An epoch is a range of consecutive blocks identified by consecutive natural numbers. Each epoch lasts a minimum duration and includes a minimum number of blocks since the beginning of the last epoch. These are defined by protocol parameters.</p>
<p>To query the current epoch:</p>
<pre><code class="language-shell">anoma client epoch
</code></pre>
<p>You can delegate to any number of validators at any time. When you delegate tokens, the delegation won't count towards the validator's stake (which in turn determines its voting power) until the beginning of epoch <code>n + 2</code> in the current epoch <code>n</code> (the literal <code>2</code> is set by PoS parameter <code>pipeline_len</code>). The delegated amount of tokens will be deducted from your account immediately, and will be credited to the PoS system's account.</p>
<p>To submit a delegation that bonds tokens from the source address to a validator with alias <code>validator-1</code>:</p>
<pre><code class="language-shell">anoma client bond \
  --source my-new-acc \
  --validator validator-1 \
  --amount 12.34
</code></pre>
<p>You can query your delegations:</p>
<pre><code class="language-shell">anoma client bonds --owner my-new-acc
</code></pre>
<p>The result of this query will inform the epoch from which your delegations will be active.</p>
<p>Because the PoS system is just an account, you can query its balance, which is the sum of all staked tokens:</p>
<pre><code class="language-shell">anoma client balance --owner PoS
</code></pre>
<p>Should a validator exhibit punishable behavior, the delegations towards this validator are also liable for slashing. Only the delegations that were active in the epoch in which the fault occurred will be slashed by the slash rate of the fault type. If any of your delegations have been slashed, this will be displayed in the <code>bonds</code> query. You can also find all the slashes applied with:</p>
<pre><code class="language-shell">anoma client slashes
</code></pre>
<p>While your tokens are being delegated, they are locked-in the PoS system and hence are not liquid until you withdraw them. To do that, you first need to send a transaction to ‚Äúunbond‚Äù your tokens. You can unbond any amount, up to the sum of all your delegations to the given validator, even before they become active.</p>
<p>To submit an unbonding of a delegation of tokens from a source address to the validator:</p>
<pre><code class="language-shell">anoma client unbond \
  --source my-new-acc \
  --validator validator-1 \
  --amount 1.2
</code></pre>
<p>When you unbond tokens, you won't be able to withdraw them immediately. Instead, tokens unbonded in the epoch <code>n</code> will be withdrawable starting from the epoch <code>n + 6</code> (the literal <code>6</code> is set by PoS parameter <code>unbonding_len</code>). After you unbond some tokens, you will be able to see when you can withdraw them via <code>bonds</code> query:</p>
<pre><code class="language-shell">anoma client bonds --owner my-new-acc
</code></pre>
<p>When the chain reaches the epoch in which you can withdraw the tokens (or anytime after), you can submit a withdrawal of unbonded delegation of tokens back to your account:</p>
<pre><code class="language-shell">anoma client withdraw \
  --source my-new-acc \
  --validator validator-1
</code></pre>
<p>Upon success, the withdrawn tokens will be credited back your account and debited from the PoS system.</p>
<p>To see all validators and their voting power, you can query:</p>
<pre><code class="language-shell">anoma client voting-power
</code></pre>
<p>With this command, you can specify <code>--epoch</code> to find the voting powers at some future epoch. Note that only the voting powers for the current and the next epoch are final.</p>
<h2 id="-pos-validators"><a class="header" href="#-pos-validators">üìí PoS Validators</a></h2>
<p>To register a new validator account, run:</p>
<pre><code class="language-shell">anoma client init-validator \
  --alias my-validator \
  --source my-new-acc
</code></pre>
<p>This command will generate the keys required for running a validator:</p>
<ul>
<li>Consensus key, which is used in <a href="https://docs.tendermint.com/master/nodes/validators.html#validator-keys">signing blocks in Tendermint</a>.</li>
<li>Validator account key for signing transactions on the validator account, such as token self-bonding, unbonding and withdrawal, validator keys, validity predicate, state and metadata updates.</li>
<li>Staking reward account key for signing transactions on the staking reward accounts. More on this account below.</li>
</ul>
<p>Then, it submits a transaction to the ledger that generates two new accounts with established addresses:</p>
<ul>
<li>A validator account with the main validator address, which can be used to receive new delegations</li>
<li>A staking reward account, which will receive rewards for participation in the PoS system. In the future, the validity predicate of this account will be able to control how the rewards are to be distributed to the validator's delegators. <em>Staking rewards are not yet implemented</em>.</li>
</ul>
<p>These keys and aliases of the addresses will be saved in your wallet. Your local ledger node will also be setup to run this validator, you just have to shut it down with e.g. <code>Ctrl + C</code>, then start it again with the same command:</p>
<pre><code class="language-shell">anoma ledger
</code></pre>
<p>The ledger will then use the validator consensus key to sign blocks, should your validator account acquire enough voting power to be included in the active validator set. The size of the active validator set is limited to <code>128</code> (the limit is set by the PoS <code>max_validator_slots</code> parameter).</p>
<p>Note that the balance of XAN tokens that is in your validator account does not count towards your validator's stake and voting power:</p>
<pre><code class="language-shell">anoma client balance --owner my-validator --token XAN
</code></pre>
<p>That is, the balance of your account's address is a regular liquid balance that you can transfer using your validator account key, depending on the rules of the validator account's validity predicate. The default validity predicate allows you to transfer it with a signed transaction and/or stake it in the PoS system.</p>
<p>You can submit a self-bonding transaction of tokens from a validator account to the PoS system with:</p>
<pre><code class="language-shell">anoma client bond \
  --validator my-validator \
  --amount 3.3
</code></pre>
<p>A validator's voting power is determined by the sum of all their active self-bonds and delegations of tokens, with slashes applied, if any, divided by <code>1000</code> (PoS <code>votes_per_token</code> parameter, with the current value set to <code>10‚Ä±</code> in parts per ten thousand).</p>
<p>The same rules apply to delegations. When you self-bond tokens, the bonded amount won't count towards your validator's stake (which in turn determines your power) until the beginning of epoch <code>n + 2</code> in the current epoch <code>n</code>. The bonded amount of tokens will be deducted from the validator's account immediately and will be credited to the PoS system's account.</p>
<p>While your tokens are being self-bonded, they are locked-in the PoS system and hence are not liquid until you withdraw them. To do that, you first need to send a transaction to ‚Äúunbond‚Äù your tokens. You can unbond any amount, up to the sum of all your self-bonds, even before they become active.</p>
<p>To submit an unbonding of self-bonded tokens from your validator:</p>
<pre><code class="language-shell">anoma client unbond \
  --validator my-validator \
  --amount 0.3
</code></pre>
<p>Again, when you unbond tokens, you won't be able to withdraw them immediately. Instead, tokens unbonded in the epoch <code>n</code> will be withdrawable starting from the epoch <code>n + 6</code>. After you unbond some tokens, you will be able to see when you can withdraw them via <code>bonds</code> query:</p>
<pre><code class="language-shell">anoma client bonds --validator my-validator
</code></pre>
<p>When the chain reaches the epoch in which you can withdraw the tokens (or anytime after), you can submit a withdrawal of unbonded tokens back to your validator account:</p>
<pre><code class="language-shell">anoma client withdraw --validator my-validator
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customize-accounts-and-transactions"><a class="header" href="#customize-accounts-and-transactions">Customize accounts and transactions</a></h1>
<p>On this page, we'll cover how to tailor your account(s) to your use-case with custom-made validity predicates and transactions.</p>
<p>We currently only support Rust for custom validity predicates and transactions via WASM, but expect many more options to be available in the future!</p>
<h2 id="-anoma-accounts-primer"><a class="header" href="#-anoma-accounts-primer">üë©üèΩ‚Äçüè´ Anoma accounts primer</a></h2>
<p>Instead of the common smart contract design, in Anoma, all the accounts follow the same basic principles. Each account has exactly one validity predicate. Any transaction that attempts to make some storage modifications will trigger validity predicates of each account whose storage has been modified by it. Validity predicates are stateless functions that decide if an account accepts the transaction.</p>
<p>Every account also has its dedicated key-value storage. The ledger encodes agnostic, it allows you to use the encoding of your preference for the storage values. Internally and for the pre-built validity predicates and transactions, we use <a href="https://github.com/near/borsh-rs">Borsh</a>, which allows you to simply derive the encoding from your data types. The storage keys are <code>/</code> separated path segments, where the first segment is always the address of the account to which the storage key belongs. In storage keys, addresses use a reserved prefix <code>#</code>.</p>
<p>To illustrate with an example storage key used for fungible tokens (with addresses shortened for clarity), let's say:</p>
<ul>
<li>
<p>XAN token's address is <code>atest1v4ehgw36x3prs...</code></p>
</li>
<li>
<p>A user Bertha has address <code>atest1v4ehgw36xvcyyv...</code></p>
</li>
<li>
<p>Then, the balance of Bertha's XAN tokens is stored in the XAN account, with the storage key comprised of <code>#{token}/balance/#{owner}</code>, i.e.:</p>
<pre><code class="language-text">#atest1v4ehgw36x3prs.../balance/#atest1v4ehgw36xvcyy...
</code></pre>
</li>
</ul>
<p>Any transaction can attempt to make changes to the storage of any account(s). Only if all the involved accounts accept, the transaction will it be committed. Otherwise, the transaction is rejected and its modifications discarded.</p>
<p>This approach allows multiparty transactions to be applied atomically, without any a priority coordination. It also gives accounts complete and fine-grained control over how they can be used in transactions in themselves and in relation to other accounts.</p>
<p>In fact, most of the functionality in the Anoma ledger is being built leveraging the simplicity and flexibility of this account system, from a simple fungible token to more complex accounts that integrate the Inter-blockchain Communication protocol and the Proof of Stake system.</p>
<h2 id="-validity-predicates"><a class="header" href="#-validity-predicates">‚òë Validity predicates</a></h2>
<p>A custom validity predicates can be built from scratch using <code>vp_template</code> (from root directory <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_template"><code>wasm/vp_template</code></a>), which is Rust code compiled to WASM. Consult its <code>README.md</code> to find out more.</p>
<p>You can also check out the pre-built validity predicates' source code in the <a href="https://github.com/anoma/anoma/tree/master/wasm/wasm_source"><code>wasm/wasm_source</code></a>, where each sub-module that begins with <code>vp_</code> implements a validity predicate. For example the <a href="https://github.com/anoma/anoma/blob/master/wasm/wasm_source/src/vp_user.rs"><code>vp_user</code></a> is the default validity predicate used for established accounts (created with <code>init-account</code> command).</p>
<p>A validity predicate's must contain the following function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anoma_vm_env::vp_prelude::*;

#[validity_predicate]
fn validate_tx(
    // The data attached to the transaction
    tx_data: Vec&lt;u8&gt;,
    // The address of the account where this validity predicate is used
    addr: Address,
    // The storage keys that were modified by the transaction
    keys_changed: HashSet&lt;storage::Key&gt;,
    // The addresses of all the accounts that are verifying the current 
    // transaction
    verifiers: HashSet&lt;Address&gt;,
) -&gt; bool {
  // Returning `true` allows any key change
  true
}
<span class="boring">}
</span></code></pre></pre>
<p>You can think of it as its <code>main</code> function. When this VP is deployed to an account, this function will be called for every transaction that:</p>
<ul>
<li>Modifies a storage key that contains the account's address to which the validity predicate belongs</li>
<li>Inserts the account's address into the verifier set with <a href="https://docs.anoma.network/rustdoc/anoma_vm_env/imports/tx/fn.insert_verifier.html"><code>tx_prelude::insert_verifiers</code> function</a></li>
</ul>
<p>Inside the validity predicate function, you can read any storage value with the functions provided in the <code>vp_prelude</code> from the storage prior to the transaction (functions with name suffix <code>_pre</code>) and from the storage state after the transaction is applied (suffixed with <code>_post</code>).</p>
<p>To find out about the host interface available in a validity predicate, please check out <a href="https://docs.anoma.network/rustdoc/anoma_vm_env/vp_prelude/index.html">Rust docs for <code>vp_prelude</code></a>.</p>
<p>To compile the validity predicate's code from the template:</p>
<pre><code class="language-shell">make -C wasm/vp_template
</code></pre>
<p>This will output a WASM file that can be found in <code>wasm/vp_template/target/wasm32-unknown-unknown/release/vp_template.wasm</code>.</p>
<p>You can, for example, copy it into your <code>wasm</code> directory (the default directory used by the ledger's node and the client, which can be changed with <code>--wasm-dir</code> global argument or <code>ANOMA_WASM_DIR</code>):</p>
<pre><code class="language-shell">cp \
  wasm/vp_template/target/wasm32-unknown-unknown/release/vp_template.wasm \
  wasm/my_vp.wasm
</code></pre>
<p>To submit a transaction that updates an account's validity predicate:</p>
<pre><code class="language-shell">anoma client update --address my-new-acc --code-path my_vp.wasm
</code></pre>
<h2 id="-custom-transactions"><a class="header" href="#-custom-transactions">üì© Custom transactions</a></h2>
<p>A transaction must contain a WASM code that can perform arbitrary storage changes. It can also contain arbitrary data, which will be passed onto the transaction and validity predicates when the transaction is being applied.</p>
<p>A custom transaction can be built from scratch using <code>tx_template</code> (from root directory <a href="https://github.com/anoma/anoma/tree/master/wasm/tx_template"><code>wasm/tx_template</code></a>), which is Rust code compiled to WASM. Consult its <code>README.md</code> to find out more.</p>
<p>For some inspiration, check out the pre-built transactions source code in the <a href="https://github.com/anoma/anoma/tree/master/wasm/wasm_source"><code>wasm/wasm_source</code></a>, where each sub-module that begins with <code>tx_</code> implements a transaction.</p>
<p>A transaction code must contain the following function, which will be called when the transaction is being applied:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anoma_vm_env::tx_prelude::*;

#[transaction]
fn apply_tx(tx_data: Vec&lt;u8&gt;) {
  // Do anything here
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the validity predicate function, you can read, write or delete any storage value with the functions provided in the <code>tx_prelude</code> from the storage of any account.</p>
<p>To find out about the interface available in a transaction, please check out <a href="https://docs.anoma.network/rustdoc/anoma_vm_env/tx_prelude/index.html">Rust docs for <code>tx_prelude</code></a>.</p>
<p>Compile the transaction's code from the template:</p>
<pre><code class="language-shell">make -C wasm/tx_template
</code></pre>
<p>This will output a WASM file that can be found in <code>wasm/tx_template/target/wasm32-unknown-unknown/release/tx_template.wasm</code>.</p>
<p>Submit the transaction to the ledger:</p>
<pre><code class="language-shell">anoma client tx --code-path tx_template/tx.wasm
</code></pre>
<p>Optionally, you can also attach some data to the transaction from a file with the <code>--data-path</code> argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-intent-gossip-and-matchmaker"><a class="header" href="#the-intent-gossip-and-matchmaker">The Intent gossip and Matchmaker</a></h1>
<p>To run an intent gossip node with an RPC server:</p>
<pre><code class="language-shell">anoma node gossip --rpc &quot;127.0.0.1:39111&quot;
</code></pre>
<p>To run an intent gossip node with the intent gossip system, a token exchange matchmaker and RPC through which new intents are requested:</p>
<pre><code class="language-shell">anoma node gossip --rpc &quot;127.0.0.1:39111&quot; --matchmaker-path wasm/mm_token_exch.wasm --tx-code-path wasm/tx_from_intent.wasm --ledger-address &quot;127.0.0.1:26657&quot; --source matchmaker --signing-key matchmaker
</code></pre>
<p>Mind that <code>matchmaker</code> should be valid key in your wallet.</p>
<p>This pre-built matchmaker implementation is <a href="https://github.com/anoma/anoma/blob/master/wasm/wasm_source/src/mm_token_exch.rs">the fungible token exchange <code>mm_token_exch</code></a>, that is being used together with <a href="https://github.com/anoma/anoma/blob/master/wasm/wasm_source/src/lib.rs">the pre-built <code>tx_from_intent</code> transaction WASM</a> to submit transaction from matched intents to the ledger.</p>
<h2 id="-example-intents"><a class="header" href="#-example-intents">‚úã Example intents</a></h2>
<ol>
<li>
<p>Lets create some accounts:</p>
<pre><code>anoma wallet key gen --alias alberto --unsafe-dont-encrypt
anoma client init-account --alias alberto-account --public-key alberto --source alberto

anoma wallet  key gen --alias christel --unsafe-dont-encrypt
anoma client init-account --alias christel-account --public-key christel --source christel

anoma wallet key gen --alias bertha --unsafe-dont-encrypt
anoma client init-account --alias bertha-account --public-key bertha --source bertha

anoma wallet key gen --alias my-matchmaker --unsafe-dont-encrypt
anoma client init-account --alias my-matchmaker-account --public-key my-matchmaker --source my-matchmaker
</code></pre>
</li>
<li>
<p>We then need some tokens:</p>
<pre><code>anoma client transfer --source faucet --target alberto-account --signer alberto-account --token BTC --amount 1000
anoma client transfer --source faucet --target bertha-account --signer bertha-account --token ETH --amount 1000
anoma client transfer --source faucet --target christel-account --signer christel-account --token XAN --amount 1000
</code></pre>
</li>
<li>
<p>Lets export some variables:</p>
<pre><code class="language-shell">export ALBERTO=$(anoma wallet address find --alias alberto-account | cut -c 28- | tr -d '\n')
export CHRISTEL=$(anoma wallet address find --alias christel-account | cut -c 28- | tr -d '\n')
export BERTHA=$(anoma wallet address find --alias bertha-account | cut -c 28- | tr -d '\n')
export XAN=$(anoma wallet address find --alias XAN | cut -c 28- | tr -d '\n')
export BTC=$(anoma wallet address find --alias BTC | cut -c 28- | tr -d '\n')
export ETH=$(anoma wallet address find --alias ETH | cut -c 28- | tr -d '\n')
</code></pre>
</li>
<li>
<p>Create files with the intents description:</p>
<pre><code class="language-shell">echo '[{&quot;addr&quot;:&quot;'$ALBERTO'&quot;,&quot;key&quot;:&quot;'$ALBERTO'&quot;,&quot;max_sell&quot;:&quot;70&quot;,&quot;min_buy&quot;:&quot;100&quot;,&quot;rate_min&quot;:&quot;2&quot;,&quot;token_buy&quot;:&quot;'$XAN'&quot;,&quot;token_sell&quot;:&quot;'$BTC'&quot;,&quot;vp_path&quot;: &quot;wasm_for_tests/vp_always_true.wasm&quot;}]' &gt; intent.A.data

echo '[{&quot;addr&quot;:&quot;'$BERTHA'&quot;,&quot;key&quot;:&quot;'$BERTHA'&quot;,&quot;max_sell&quot;:&quot;300&quot;,&quot;min_buy&quot;:&quot;50&quot;,&quot;rate_min&quot;:&quot;0.7&quot;,&quot;token_buy&quot;:&quot;'$BTC'&quot;,&quot;token_sell&quot;:&quot;'$ETH'&quot;}]' &gt; intent.B.data

echo '[{&quot;addr&quot;:&quot;'$CHRISTEL'&quot;,&quot;key&quot;:&quot;'$CHRISTEL'&quot;,&quot;max_sell&quot;:&quot;200&quot;,&quot;min_buy&quot;:&quot;20&quot;,&quot;rate_min&quot;:&quot;0.5&quot;,&quot;token_buy&quot;:&quot;'$ETH'&quot;,&quot;token_sell&quot;:&quot;'$XAN'&quot;}]' &gt; intent.C.data
</code></pre>
</li>
<li>
<p>Start the ledger and the matchmaker. Instruct the matchmaker to subscribe to a topic &quot;asset_v1&quot;:</p>
<pre><code class="language-shell">anoma node ledger run

anoma node gossip --rpc &quot;127.0.0.1:39111&quot; --matchmaker-path wasm/mm_token_exch.wasm --tx-code-path wasm/tx_from_intent.wasm --ledger-address &quot;127.0.0.1:26657&quot; --source mm-1 --signing-key mm-1

anoma client subscribe-topic --node &quot;http://127.0.0.1:39111&quot; --topic &quot;asset_v1&quot;
</code></pre>
</li>
<li>
<p>Submit the intents (the target gossip node must be running an RPC server):</p>
<pre><code class="language-shell">anoma client intent --data-path intent.A.data --topic &quot;asset_v1&quot; --signing-key alberto --node &quot;http://127.0.0.1:39111&quot;
anoma client intent --data-path intent.B.data --topic &quot;asset_v1&quot; --signing-key bertha --node &quot;http://127.0.0.1:39111&quot;
anoma client intent --data-path intent.C.data --topic &quot;asset_v1&quot; --signing-key christel --node &quot;http://127.0.0.1:39111&quot;
</code></pre>
<p>The matchmaker should find a match from these intents and submit a transaction to the ledger that performs the n-party transfers of tokens.</p>
</li>
<li>
<p>You can check the balances with:</p>
<pre><code>anoma client balance --owner alberto-account
anoma client balance --owner bertha-account
anoma client balance --owner christel-account
</code></pre>
</li>
</ol>
<h2 id="-custom-matchmaker"><a class="header" href="#-custom-matchmaker">ü§ù Custom matchmaker</a></h2>
<p>A custom matchmaker code can be built from <a href="https://github.com/anoma/anoma/tree/master/wasm/mm_template"><code>wasm/mm_template</code></a>.</p>
<p>A matchmaker code must contain the following function, which will be called when a new intent is received:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anoma_vm_env::matchmaker_prelude::*;

#[matchmaker]
fn add_intent(last_state: Vec&lt;u8&gt;, intent_id: Vec&lt;u8&gt;, intent_data: Vec&lt;u8&gt;) -&gt; bool {
  // Returns a result of processing the intent
  true
}
<span class="boring">}
</span></code></pre></pre>
<p>The matchmaker can keep some state between its runs. The state can be updated from within the matchmaker code with <a href="https://docs.anoma.network/rustdoc/anoma_vm_env/imports/matchmaker/fn.update_state.html"><code>update_state</code> function</a> and received from the <code>last_state</code> argument.</p>
<p>To find out about the interface available in a matchmaker and the library code used in the <code>mm_token_exch</code> implementation, please check out <a href="https://docs.anoma.network/master/rustdoc/anoma_vm_env/matchmaker_prelude/index.html">Rust docs for <code>matchmaker_prelude</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploration"><a class="header" href="#exploration">Exploration</a></h1>
<p>This section documents the process of exploring the design and implementation space for Anoma. Ideally, the captured information should provide an overview of the explored space and help to guide further decisions.</p>
<p>The content of this section is more free-form. This is largely a cross-over of both the implementation details and the design of implementation-independent specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This section covers the exploration of the possible design directions of the involved components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<blockquote>
<p>‚ö†Ô∏è This section is WIP.</p>
</blockquote>
<ul>
<li>TODO: add high-level interaction diagram(s)</li>
</ul>
<p>The Rust crates internal dependency graph:</p>
<p><img src="explore/design/./overview/crates.svg" alt="crates" title="crates" />
<a href="https://excalidraw.com/#room=e32fc914de750ed4f5e4,6CWRFjnmCoiFR4BQ6i9K4g">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gossip-network"><a class="header" href="#the-gossip-network">The gossip network</a></h1>
<p>The gossip network runs in parallel to the ledger network and is used to
propagate off-chain information. The network is based on
<a href="https://libp2p.io/">libp2p</a> , a peer to peer network system that is implemented
in different languages, has a large user base and an active development.  It
allows us to readily implement a network to run our application.</p>
<p>The gossip network is used to propagate messages of two different applications,
intents for the <a href="explore/design/intent_gossip/intent_gossip.html">intent gossip system</a>, and message for distributed keys
generation application.</p>
<h2 id="flow-diagram-high-level-overview"><a class="header" href="#flow-diagram-high-level-overview">Flow diagram: High level overview</a></h2>
<p><img src="explore/design/./gossip_process.svg" alt="gossip process" title="gossip process" /></p>
<p><a href="https://excalidraw.com/#room=5d4a2a84ef52cf5f5f96,r4ghl40frJ9putMy-0vyOQ">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-network"><a class="header" href="#intent-gossip-network">Intent gossip network</a></h1>
<p>The intent gossip network enables counterparty discovery for bartering. The
users can express any sort of intents that might be matched and transformed into
a transaction that fulfills the intents on the Anoma ledger.</p>
<p>An <a href="explore/design/intent_gossip/./intent.html">intent</a> describes the desire of a user, from asset exchange to a
green tax percent for selling shoes. These intents are picked up by a matchmaker
that composes them into transactions to send to the ledger network. A matchmaker
is optionally included in the intent gossip node.</p>
<p>Each node connects to a specified intent gossip network, either a public or a
private one. Anyone can create their own network where they decide all aspects
of it: which type of intents is propagated, which nodes can participate, the
matchmaker logic, etc. It is possible, for example, to run the intent gossip system
over bluetooth to have it off-line.</p>
<p>An intent gossip node is a peer in the intent gossip network that has the role
of propagating intents to all other connected nodes.</p>
<p>The network uses the
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
network behaviour. This system aggregates nodes around topics of interest. Each
node subscribes to a set of topics and connects to other nodes that are also
subscribed to the same topics. A topic defines a sub-network for a defined
interest, e.g. ‚Äúasset_exchange‚Äù. see
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
for more information on the network topology.</p>
<p>Each node has an incentive to propagate intents and will obtain a small portion
of the fees if the intent is settled. (TODO: update when logic is found) See
<a href="explore/design/intent_gossip/./incentive.html">incentive</a> for more information.</p>
<h3 id="flow-diagram-asset-exchange"><a class="header" href="#flow-diagram-asset-exchange">Flow diagram: asset exchange</a></h3>
<p>This example shows three intents matched together by the intent gossip network.
These three intents express user desires to exchange assets.</p>
<p><img src="explore/design/intent_gossip/./example.svg" alt="intent gossip and ledger network interaction" title="intent gossip network" />
<a href="https://excalidraw.com/#room=257e44f4b4b5867bf541,XDEKyGVIpqCrfq55bRqKug">Diagram on Excalidraw</a></p>
<h1 id="flow-diagram-life-cycle-of-intent-and-global-process"><a class="header" href="#flow-diagram-life-cycle-of-intent-and-global-process">Flow diagram: life cycle of intent and global process</a></h1>
<p>This diagram shows the process flow for intents, from users expressing their
desire to the ledger executing the validity predicate to check the crafted
transaction.</p>
<p><img src="explore/design/intent_gossip/./intent_life_cycle.svg" alt="intent life cycle" title="intent life
cycle" /> 
<a href="https://excalidraw.com/#room=7ac107b3757c64049003,cdMInfvdLtjaGWSZWEKrhw">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intents"><a class="header" href="#intents">Intents</a></h1>
<p>An intent is a way of expressing a user's desire. It is defined as arbitrary
data and an optional address for a schema. The data is as arbitrary as possible
to allow the users to express any sort of intent. It could range from defining a
selling order for a specific token to offering piano lessons or even proposing a
green tax for shoes‚Äô manufacturers.</p>
<p>An intent is written using an encoding, or data schema. The encoding exists
either on-chain or off-chain. It must be known by users that want to express
similar intents. It also must be understood by some matchmaker. Otherwise, it 
possibly won‚Äôt be  matched. The user can define its own schema and inform either 
off-chain or on-chain. Having it on-chain allows it to easily share it with other
participants. Please refer to <a href="explore/design/intent_gossip/./../ledger/storage/data-schema.html">data schema</a> for more
information about the usage of on-chain schema.</p>
<hr />
<p>There is only a single intent type that is composed of arbitrary data and a
possible schema definition.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Intent {
    schema: Option&lt;Key&gt;,
    data: Vec&lt;u8&gt;,
    timestamp: Timestamp
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic"><a class="header" href="#topic">Topic</a></h1>
<p>A topic is string and an encoding that describes this sub-network. In a topic
all intents use the exact same encoding. That encoding is known by matchmakers
so it can decode them to find matches. Whenever a node subscribes to a new topic
it informs all connected nodes and each of them propagate it. With this it‚Äôs
easy to create new topics in the intent gossip network and inform others.</p>
<p>Other nodes can choose to subscribe to a new topic with the help of a
filter. This filter is defined as a combination of a whitelist, a regex
expression, and a maximum limit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incentive"><a class="header" href="#incentive">Incentive</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/37">Tracking Issue</a></p>
<hr />
<p>TODO</p>
<ul>
<li>describe incentive function</li>
<li>describe logic to ensure matchmaker can't cheat intent gossip service</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matchmaker"><a class="header" href="#matchmaker">Matchmaker</a></h1>
<p>The matchmaker is a specific actor in the intent gossip network that tries to
match intents together. When intents are matched together, the matchmaker crafts
a transaction from them and sends it to the ledger network.</p>
<p>A matchmaker is an intent gossip node started with additional parameters: a
ledger address and a list of sub-matchmakers. A sub-matchmaker is defined with a
topics list, a main program path, a filter program path, and a transaction code.</p>
<p>The main and filter programs are wasm compiled code. Each has a defined
entrypoint and their own set of environment functions that they can call.</p>
<p>When the matchmaker receives a new intent from the network it calls the
corresponding sub-matchmaker, the one that has the intent‚Äôs topic in their
topics list. A sub-matchmaker first checks if the intent is accepted by the
filter, before adding it to that sub-matchmaker database. Then the main program
is called with the intent and current state.</p>
<h2 id="sub-matchmaker-topics-list"><a class="header" href="#sub-matchmaker-topics-list">Sub-matchmaker topics' list</a></h2>
<p>A sub-matchmaker is defined to work with only a subset of encoding. Each intent
propagated to the corresponding topic will be process by this sub-matchmaker.</p>
<p>Having a topics list instead of a unique topic allows a matchmaker to match
intents from different encodings. For example, when an updated version of an
encoding is out, the matchmaker could match intents from both versions if they
don‚Äôt diverge too much.</p>
<h2 id="sub-matchmaker-database-and-state-name-tbd"><a class="header" href="#sub-matchmaker-database-and-state-name-tbd">Sub-matchmaker database and state (name TBD)</a></h2>
<p>Each sub-matchmaker has a database and an arbitrary state.</p>
<p>The database contains intents received by the node from the topics list that
passed the filter.</p>
<p>The state is arbitrary data that is managed by the main program. That state is
given to all calls in the main program.</p>
<p>The database is persistent but the state is not. When a node is started the
state is recovered by giving all intents from the database to the main program.
The invariant that the current state is equal to the state if the node is
restarted is not enforced and is the responsibility of the main program.</p>
<h2 id="filter-program"><a class="header" href="#filter-program">Filter program</a></h2>
<p>The filter is an optional wasm program given in parameters. This filter is used
to check each intent received by that sub-matchmaker. If it's not defined,
intents are directly passed to the main program.</p>
<p>The entrypoint <code>filter_intent</code> takes an intent and returns a boolean. The
filter has the ability to query the state of the ledger for any given key.</p>
<h2 id="main-program"><a class="header" href="#main-program">Main program</a></h2>
<p>The main program is a mandatory wasm program given in parameters. The main
program must match together intents.</p>
<p>The main program entrypoint <code>match_intent</code> takes the current state, a new intent
data and its id. The main program also has the ability to query the state of the
ledger. It also has functions <code>remove</code> and <code>get</code> to interact with the matchmaker
mempool. When a main matchmaker program finds a match it sends a transaction to
the ledger composed of the code template given in the matchmaker parameter and
the data given to this function. Finally the matchmaker must update its state so
the next run will have up to date values.</p>
<p>The main program is called on two specific occasion; when intent gossip node is
started, on all intent from database and whenever a new intent is received from
the p2p network and the RPC endpoint, if enabled.</p>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>The transaction code given in parameters is used when the main program matches a
group of intents. The main program returns arbitrary data that is attached to
the transaction which is then injected into a ledger node.</p>
<h2 id="flow-diagram-matchmaker-process"><a class="header" href="#flow-diagram-matchmaker-process">Flow diagram: Matchmaker process</a></h2>
<p><img src="explore/design/intent_gossip/./matchmaker_process.svg" alt="matchmaker process" title="matchmaker process" /></p>
<p><a href="https://excalidraw.com/#room=92b291c13cfab8fb22a4,OvHfWIrL0jeDzPI-EFZMaw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fungible-token-encoding-and-template"><a class="header" href="#fungible-token-encoding-and-template">Fungible token encoding and template</a></h1>
<p>The Heliax team implemented an intent encoding, a filter program template, and a
matchmaker program template that can be used to exchange fungible tokens between
any number of participants.</p>
<h2 id="intent-encoding"><a class="header" href="#intent-encoding">Intent encoding</a></h2>
<p>The intent encoding allows the expression of a desire to participate in an asset
exchange. The encoding is defined as follows :</p>
<pre><code class="language-protobuf">message FungibleToken {
  string address = 1;
  string token_sell = 2;
  int64 max_sell = 3;
  int64 rate_min = 4;
  string token_buy = 5;
  int64 min_buy = 6;
  google.protobuf.Timestamp expire = 7;
}
</code></pre>
<h2 id="matchmaker-program"><a class="header" href="#matchmaker-program">Matchmaker program</a></h2>
<p>The filter program attempts to decode the intent and if successful, checks
that it's not yet expired and that the account address has enough funds for the
intended token to be sold.</p>
<p>The main program can match intents for exchanging assets. It does that by
creating a graph from all intents. When a cycle is found then it removes all
intents from that cycle of the mempool and crafts a transaction based on all the
removed intents.</p>
<p><img src="explore/design/intent_gossip/matchmaker_graph.svg" alt="matchmaker" />
<a href="https://excalidraw.com/#room=1db86ba6d5f0ccb7447c,2vvRd4X2Y3HDWHihJmy9zw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-key-generation-gossip"><a class="header" href="#distributed-key-generation-gossip">Distributed key generation gossip</a></h1>
<blockquote>
<p>‚ö†Ô∏è This section is WIP.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger"><a class="header" href="#the-ledger">The ledger</a></h1>
<p>The ledger depends on <a href="https://github.com/tendermint/tendermint">Tendermint node</a>. Running the Anoma node will also initialize and run Tendermint node. Anoma communicates with Tendermint via the ABCI.</p>
<h2 id="tendermint-abci"><a class="header" href="#tendermint-abci">Tendermint ABCI</a></h2>
<p>We are using the Tendermint state-machine replication engine via ABCI. It provides many useful things, such as a BFT consensus protocol, P2P layer with peer exchange, block sync and mempool layer.</p>
<p>Useful resources:</p>
<ul>
<li>Tendermint ABCI <a href="https://docs.tendermint.com/master/spec/abci/">https://docs.tendermint.com/master/spec/abci/</a></li>
<li>Tendermint RPC reference <a href="https://docs.tendermint.com/master/rpc/">https://docs.tendermint.com/master/rpc/</a></li>
<li>Awesome collection <a href="https://github.com/tendermint/awesome">https://github.com/tendermint/awesome</a></li>
</ul>
<p>Rust ABCI implementations:</p>
<ul>
<li><a href="https://github.com/informalsystems/tendermint-rs">https://github.com/informalsystems/tendermint-rs</a>
<ul>
<li>the future update planned for this crate is to add async support</li>
<li>longer term the goal is to be able to <a href="https://github.com/informalsystems/tendermint-rs/issues/29#issuecomment-672444401">seamlessly switch from Go Tendermint
to Rust Tendermint</a></li>
<li>includes RPC and light-client libraries</li>
</ul>
</li>
<li><a href="https://github.com/devashishdxt/abci-rs">https://github.com/devashishdxt/abci-rs</a>
<ul>
<li>async support</li>
</ul>
</li>
<li><a href="https://github.com/tendermint/rust-abci">https://github.com/tendermint/rust-abci</a>
<ul>
<li>deprecated in favor of informalsystems/tendermint-rs</li>
</ul>
</li>
</ul>
<h3 id="abci-integration"><a class="header" href="#abci-integration">ABCI Integration</a></h3>
<p>The ledger wraps the Tendermint node inside the Anoma node. The Tendermint node
communicates with the Anoma shell via four layers as illustrated below.</p>
<pre class="mermaid">flowchart LR
    C[Client] --- R
    subgraph Anoma Node
    S((Anoma Shell))
    subgraph Tendermint ABCI
    R[RPC] === T{Tendermint}
    T --- TC[Consensus]
    T --- TM[Mempool]
    T --- TQ[Query]
    T --- TS[Snapshot]
    end
    TC --- S
    TM --- S
    TQ --- S
    TS --- S
    end
</pre>
<p>The <em>consensus</em> connection allows the shell to:</p>
<ul>
<li>initialize genesis on start-up</li>
<li>begin a block</li>
<li>apply a transaction(s) in a block</li>
<li>end a block</li>
<li>commit a block</li>
</ul>
<p>The <em>mempool</em> connection asks the shell to validate transactions before they get
stored in the mempool and broadcasted to peers. The mempool will signify that
the transaction is either new, when it has not been validated before, or to be
re-checked when it has been validated at some previous level.</p>
<p>The <em>query</em> connection is used for:</p>
<ul>
<li>the Tendermint node asks the last known state from the shell to determine if it needs to replay any blocks</li>
<li>relay client queries for some state at a given path to the shell</li>
</ul>
<p>The <em>snapshot</em> connection is used to serve state sync snapshots for other nodes and/or restore state sync snapshots to a local node being bootstrapped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<p>The parameters are used to dynamically control certain variables in the protocol. They are implemented as an internal address with a native VP. The current values are written into and read from the block storage in the parameters account's sub-space.</p>
<p>Initial parameters for a chain are set in the genesis configuration. On chain, these can be changed by 2/3 of voting power (specifics are TBA).</p>
<h2 id="epoch-duration"><a class="header" href="#epoch-duration">Epoch duration</a></h2>
<p>The parameters for <a href="explore/design/ledger/./epochs.html">epoch</a> duration are:</p>
<ul>
<li>Minimum number of blocks in an epoch</li>
<li>Minimum duration of an epoch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epochs"><a class="header" href="#epochs">Epochs</a></h1>
<p>An epoch is a range of blocks whose length is determined by the <a href="explore/design/ledger/./parameters.html#epoch-duration">epoch duration protocol parameter</a>: minimum epoch duration and minimum number of blocks in an epoch. They are identified by consecutive natural numbers starting at 0.</p>
<p>We store the current epoch in global storage and the epoch of each block in the block storage. We also store the minimum height and minimum time of a first block in the next epoch in global storage, so that changes to the epoch duration protocol parameter don't affect the current epoch, but rather apply from the following epoch. Note that protocol parameters changes may themselves be delayed.</p>
<p>The first epoch (ID 0) starts on the genesis block. The next epoch minimum start time is set to the genesis time configured for the chain + minimum duration and the next epoch minimum height is set to the height of the genesis block (typically 1) + minimum number of blocks.</p>
<p>On each block <code>BeginBlock</code> Tendermint call, we check if the current epoch is finished, in which case we move on to the next epoch. An epoch is finished when both the minimum number of blocks and minimum duration of an epoch have been created from the first block of a current epoch. When a new epoch starts, the next epoch minimum height is set to the block's height + minimum number of blocks and minimum start time time is set to block's time from the block header + minimum duration.</p>
<h2 id="predecessor-blocks-epochs"><a class="header" href="#predecessor-blocks-epochs">Predecessor blocks epochs</a></h2>
<p>We store the epoch ranges of predecessor blocks. This is used for example for to look-up the epoch from an evidence of validators that acted maliciously (which includes block height and block time) for PoS system. For the PoS system, in block at height <code>h</code>, we only need to know values from Tendermint <code>max(h - consensus_params.evidence.max_age_num_blocks, 0)</code>, which is set to <code>100000</code> by default.</p>
<p>The predecessor epochs are stored in the block storage.  We update this structure on every new epoch and trim any epochs that ended more than <code>max_age_num_blocks</code> ago.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/45">Tracking Issue</a></p>
<hr />
<p>There's only a single account type. Each account is associated with:</p>
<ul>
<li>a unique <a href="explore/design/ledger/accounts.html#addresses">address</a></li>
<li>a <a href="explore/design/ledger/./vp.html">validity predicate</a></li>
<li><a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">dynamic storage sub-space</a></li>
</ul>
<h2 id="addresses"><a class="header" href="#addresses">Addresses</a></h2>
<p>There are two main types of address: transparent and shielded.</p>
<p>The transparent addresses are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>The shielded addresses are used for private transactions and they are not directly associated with storage sub-spaces.</p>
<h3 id="transparent-addresses"><a class="header" href="#transparent-addresses">Transparent addresses</a></h3>
<p>Furthermore, there are three types of transparent addresses:</p>
<ul>
<li>&quot;implicit&quot; addresses which are derived from public keys</li>
<li>&quot;established&quot; addresses which are generated from the current address nonce and hence must be created via a request in the ledger</li>
<li>&quot;internal&quot; addresses are used for special modules integrated into the ledger such as PoS and IBC.</li>
</ul>
<p>The addresses are stored on-chain encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a> (<a href="https://github.com/zcash/zips/issues/484">not yet adopted in Zcash</a>), which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>.</p>
<p>The human-readable prefix (as specified for <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#specification">bech32</a>) in the address encoding is:</p>
<ul>
<li><code>&quot;a&quot;</code> for Anoma live network</li>
<li><code>&quot;atest&quot;</code> for test network</li>
</ul>
<h4 id="implicit-transparent-addresses"><a class="header" href="#implicit-transparent-addresses">Implicit transparent addresses</a></h4>
<p>As implied by their name, accounts for implicit addresses exist as a possibility and not as a matter of fact. These addresses allow users to interact with public keys which may or may not have a registered on-chain account, e.g. allowing to send some fungible token to an address derived from a public key. An implicit address is derived from a hash of a public key, which also helps to protect keys for which the public key has not been revealed publicly.</p>
<h4 id="established-transparent-addresses"><a class="header" href="#established-transparent-addresses">Established transparent addresses</a></h4>
<p>Established addresses are created by a ledger transaction, which can create any number of new account addresses. The users are not in control of choosing the address as it's derived from the current address nonce, which is changed after every newly established address.</p>
<h4 id="internal-transparent-addresses"><a class="header" href="#internal-transparent-addresses">Internal transparent addresses</a></h4>
<p>There will be a static set of internal addresses that integrate certain functionality into the ledger via a dedicated module, such as the proof-of-stake module and the IBC module. The internal accounts use <a href="explore/design/ledger/vp.html#native-vps">native validity predicates</a> to validate transactions that interact with their module. A native module will use the <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">dynamic storage sub-space</a> to store all the data relevant to their functionality (e.g. PoS parameters, bond pool, IBC state and proofs).</p>
<h3 id="shielded-addresses"><a class="header" href="#shielded-addresses">Shielded addresses</a></h3>
<p>Similar to <a href="https://raw.githubusercontent.com/zcash/zips/master/protocol/protocol.pdf">Zcash Sapling protocol payment addresses and keys (section 3.1)</a>, users can generate spending keys for private payments. A shielded payment address, incoming viewing key and full viewing key are derived from a spending key. In a private payment, a shielded payment address is hashed with a diversifier into a diversified transmission key. When a different diversifier function is chosen for different transactions, it prevents the transmission key from being matched across the transactions.</p>
<p>The encoding of the shielded addresses, spending and viewing keys is not yet decided, but for consistency we'll probably use a the same schema with different prefixes for anything that can use an identifier.</p>
<ul>
<li>TODO consider using a schema similar to the <a href="https://github.com/zcash/zips/issues/482">unified addresses proposed in Zcash</a>, that are designed to unify the payment addresses across different versions by encoding a typecode and the length of the payment address together with it. This may be especially useful for the protocol upgrade system and fractal scaling system.</li>
</ul>
<h2 id="dynamic-storage-sub-space"><a class="header" href="#dynamic-storage-sub-space">Dynamic storage sub-space</a></h2>
<p>Each account can have an associated dynamic account state in the storage. This
state may be comprised of keys of the built-in supported types and values of arbitrary user bytes.</p>
<p>The dynamic storage sub-space could be a unix filesystem-like tree under the
account's address key-space with <code>read, write, delete, has_key, iter_prefix</code>
(and maybe a few other convenience functions for hash-maps, hash-sets, optional values, etc.) functions parameterized with the the account's address.</p>
<p>In addition, the storage sub-space would provide:</p>
<ul>
<li>a public type/trait for storage keys and key segments:
<ul>
<li>this should allow to turn types to storage key segments, key segments back to types</li>
<li>combine key segments into keys</li>
<li>can be extended with custom types in the code in a transaction</li>
</ul>
</li>
<li>a public type/trait for storage values:
<ul>
<li>values need to implement encoding traits, e.g. <code>BorshSerialize, BorshDeserialize</code>
<ul>
<li>this allows composition of types as specified for <a href="https://borsh.io">Borsh</a></li>
<li>the Merkle tree hashing function should hash values from the encoded bytes of this trait (the encoded value may be cached, because we update the Merkle tree in-memory before we commit the finalized block to the DB)</li>
</ul>
</li>
</ul>
</li>
<li>functions to get the size of a key and an encoded value (for storage fees)</li>
<li>the updates to account storage should be immediately visible to the transaction that performed the updates
<ul>
<li>validity predicate modifications have to be handled a little differently -
the old validity predicate should be run to check that the new validity
predicate (and other state changes included in the transaction) is valid</li>
</ul>
</li>
</ul>
<h2 id="initializing-a-new-account"><a class="header" href="#initializing-a-new-account">Initializing a new account</a></h2>
<p>A new account can be initialized on-chain with a transaction:</p>
<ul>
<li>anything be written into its storage (initial parameter)</li>
<li>a validity predicate has to be provided (we can have a default out-of-band)</li>
<li>at minimum, accounts need to be enumerated on chain, this could be done with an address or a counter</li>
</ul>
<p>A newly created account should be validated by all the VPs triggered by the transaction, i.e. it should be included in the set of changed keys passed to each VP. If the VPs are not interested in the newly created account, they can choose to ignore it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validity-predicates"><a class="header" href="#validity-predicates">Validity predicates</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/44">Tracking Issue</a></p>
<hr />
<p>Each <a href="explore/design/ledger/accounts.html">account</a> is associated with exactly one validity predicate (VP).</p>
<p>Conceptually, a VP is a function from the transaction's data and the storage state prior and posterior to a transaction execution returning a boolean value. A transaction may modify any data in the <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>. Upon <a href="explore/design/ledger/tx.html#tx-execution">transaction execution</a>, the VPs associated with the accounts whose storage has been modified are invoked to verify the transaction. If any of them reject the transaction, all of its storage modifications are discarded.</p>
<p>There are some native VPs for <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal transparent addresses</a> that are built into the ledger. All the other VPs are implemented as <a href="explore/design/ledger/wasm-vm.html">WASM programs</a>. One can build a custom VP using the <a href="https://github.com/anoma/anoma/tree/master/vps/vp_template">VP template</a> or use one of the pre-defined VPs.</p>
<p>The VPs must implement the following interface that will be invoked by the protocol:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_tx(
    // Data of the transaction that triggered this VP call
    tx_data: Vec&lt;u8&gt;,
    // Address of this VP
    addr: Address,
    // Storage keys that have been modified by the transation, relevant to this VP
    keys_changed: HashSet&lt;storage::Key&gt;,
    // Set of all the addresses whose VP was triggered by the transaction
    verifiers: HashSet&lt;Address&gt;,
) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>The host functions available to call from inside the VP code can be found in <a href="https://docs.anoma.network/master/rustdoc/anoma_vm_env/imports/vp/index.html#functions">docs generated from code</a>.</p>
<h2 id="native-vps"><a class="header" href="#native-vps">Native VPs</a></h2>
<p>The native VPs follow the same interface as WASM VPs and rules for how they are <a href="explore/design/ledger/tx.html#tx-execution">triggered by a transaction</a>. They can also call the same host functions as those provided in <a href="explore/design/ledger/wasm-vm.html#vps-environment">WASM VPs environment</a> and must also account any computation for gas usage.</p>
<h3 id="pos-slash-pool-vp"><a class="header" href="#pos-slash-pool-vp">PoS slash pool VP</a></h3>
<p>The Proof-of-Stake slash pool is a simple account with a native VP which can receive slashed tokens, but no token can ever be withdrawn from it by anyone at this point.</p>
<h2 id="fungible-token-vp"><a class="header" href="#fungible-token-vp">Fungible token VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_token.wasm">fungible token VP</a> allows to associate accounts balances of a specific token under its account. </p>
<p>For illustration, users <code>Albert</code> and <code>Bertha</code> might hold some amount of token with the address <code>XAN</code>. Their balances would be stored in the <code>XAN</code>'s storage sub-space under the storage keys <code>@XAN/balance/@Albert</code> and <code>@XAN/balance/@Bertha</code>, respectively. When <code>Albert</code> or <code>Bertha</code> attempt to transact with their <code>XAN</code> tokens, its validity predicate would be triggered to check:</p>
<ul>
<li>the total supply of <code>XAN</code> token is preserved (i.e. inputs = outputs)</li>
<li>the senders (users whose balance has been deducted) are checked that their validity predicate has also been triggered</li>
</ul>
<p>Note that the fungible token VP doesn't need to know whether any of involved users accepted or rejected the transaction, because if any of the involved users rejects it, the whole transaction will be rejected.</p>
<h2 id="user-vp"><a class="header" href="#user-vp">User VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_user.wasm">user VP</a> currently provides a signature verification against a public key for sending tokens as prescribed by the fungible token VP. In this VP, a transfer of tokens doesn't have to be authorized by the receiving party. </p>
<p>It also allows arbitrary storage modifications to the user's sub-space to be performed by a transaction that has been signed by the secret key corresponding to the user's public key stored on-chain. This functionality also allows one to update their own validity predicate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/43">Tracking Issue</a></p>
<hr />
<p>There is only a single general transaction (tx) type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Transaction {
    // A wasm module with a required entrypoint
    code: Vec&lt;u8&gt;
    // Optional arbitrary data
    data: Option&lt;Vec&lt;u8&gt;&gt;,
    // A timestamp of when the transaction was created
    timestamp: Timestamp,
    gas_limit: TODO,
}
<span class="boring">}
</span></code></pre></pre>
<p>The tx allows to include arbitrary <code>data</code>, e.g zero-knowledge proofs and/or arbitrary nonce bytes to obfuscate the tx's minimum encoded size that may be used to derive some information about the tx.</p>
<p>TODO once we have DKG, we will probably want to have some kind of a wrapper transaction with submission fees, payer and signature</p>
<h2 id="tx-life-cycle"><a class="header" href="#tx-life-cycle">Tx life cycle</a></h2>
<pre class="mermaid">flowchart TD
    subgraph Node
    I[Initialize chain] --&gt; Begin
    Begin[Begin block] --&gt; Poll
    Poll[Poll mempool queue] --&gt; Apply
    Apply[Apply txs] --&gt; End
    End[End block] --&gt; Commit[Commit block]
    Commit --&gt; Begin
    Commit --&gt; Flush
      subgraph Mempool
      Validate --&gt; V{is valid?}
      V --&gt;|Yes| Add[Add to local queue]
      V --&gt;|No| Fail[Drop tx]
      Flush --&gt;|Re-validate txs not included in this block| V
      end
    end
    subgraph Client
    Submit[Submit tx] --&gt; Validate
    end
</pre>
<p>New txs are injected by the client via mempool. Before including a tx in a local mempool queue, some cheap validation may be performed. Once a tx is included in a mempool queue, it will be gossiped with the peers and may be included in a block by the block proposer. Any txs that are left in the queue after flush will be subject to re-validation before being included again.</p>
<p>The order of applying transactions within a block is fixed by the block proposer in <a href="explore/design/ledger/front-running.html">the front-running prevention protocol</a>.</p>
<p>TODO we might want to randomize the tx order after DKG protocol is completed</p>
<h3 id="block-application"><a class="header" href="#block-application">Block application</a></h3>
<p>Within a block, each tx is applied sequentially in three steps:</p>
<pre class="mermaid">flowchart TD
    B[Begin block] --&gt; N{Has next tx and within block gas limit?}
    N --&gt; |Yes|E
    N -----&gt; |No|EB[End block]
    E[Exec tx code] --&gt;|&quot;‚àÄ accounts with modified storage&quot;| VP[Run validity predicates in parallel]
    VP --&gt; A{all accept}
    A --&gt; |No|R[Reject tx]
    A --&gt; |Yes|C[Commit tx and state changes]
    R --&gt; N
    C --&gt; N

</pre>
<h2 id="tx-execution"><a class="header" href="#tx-execution">Tx execution</a></h2>
<p>The code is allowed to read and write anything from <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' sub-spaces</a> and to <a href="explore/design/ledger/./accounts.html#initializing-a-new-account">initialize new accounts</a>. Other data that is not in an account's subspace is read-only, e.g. chain and block metadata, account addresses and potentially keys.</p>
<p>In addition to the verifiers specified in a transaction, each account whose sub-space has been modified by the tx triggers its VP.</p>
<p>For <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal addresses</a>, we invoke their module's native VP interface directly. For other addresses, we look-up validity predicates WASM to be executed from storage.</p>
<p>The VPs are then given the prior and posterior state from the account's sub-space together with the tx to decide if it accepts the tx's state modifications.</p>
<p>Within a single tx the execution of the validity predicates will be parallelized and thus the fee for VPs execution would their maximum value (plus some portion of the fees for each of the other parallelized VPs - nothing should be &quot;free&quot;). Once any of the VPs rejects the modifications, execution is aborted, the transaction is rejected and state changes discarded. If all the VPs accept the modifications, the transaction is successful and modifications are committed to storage as the input of the next tx.</p>
<p>The transaction's API should make it possible to transfer tokens to a hash of a public key that is not revealed. This could be done by having a &quot;deposit&quot; account from which the key's owner can claim the deposited funds.</p>
<p>Should some type of token prefer not to allow to receive tokens without recipient's approval, a token account can implement logic to decline the received tokens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-vm"><a class="header" href="#wasm-vm">WASM VM</a></h1>
<p>A wasm virtual machine will be used for <a href="explore/design/ledger/./vp.html">validity predicates</a> and <a href="explore/design/ledger/./tx.html">transactions code</a>. </p>
<p>The VM should provide:</p>
<ul>
<li>an interface for compiling from higher-level languages to wasm (initially only Rust)</li>
<li>a wasm compiler, unless we use <a href="explore/design/ledger/../../libraries/wasm.html">an interpreted runtime</a></li>
<li>provide and inject <a href="explore/design/ledger/wasm-vm.html#wasm-environment">environments for higher-level languages for VPs and transactions</a></li>
<li>pre-process wasm modules
<ul>
<li>check &amp; sanitize modules</li>
<li>inject gas metering</li>
<li>inject stack height metering</li>
</ul>
</li>
<li>a runner for VPs and transaction code</li>
<li>encode/decode wasm for transfer &amp; storage</li>
<li><a href="explore/design/ledger/wasm-vm.html#wasm-memory">manage runtime memory</a></li>
<li>wasm development helpers</li>
<li>helpers to estimate gas usage</li>
<li>VM and environment versioning</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://webassembly.github.io/spec/">WebAssembly Specifications</a></li>
<li><a href="https://docs.wasmer.io/integrations/examples">wasmer examples</a></li>
<li><a href="https://github.com/webassembly/wabt/">The WebAssembly Binary Toolkit</a>
<ul>
<li>bunch of useful wasm tools (e.g. <code>wasm2wat</code> to convert from wasm binary to human-readable wat format) </li>
</ul>
</li>
<li><a href="https://github.com/rustwasm/team">Rust wasm WG</a> and <a href="https://rustwasm.github.io/book/introduction.html">wasm book</a> (some sections are JS specific)</li>
<li><a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/">A practical guide to WebAssembly memory</a> modulo JS specific details</li>
<li><a href="https://learnxinyminutes.com/docs/wasm/">Learn X in Y minutes Where X=WebAssembly</a></li>
</ul>
<h2 id="wasm-environment"><a class="header" href="#wasm-environment">Wasm environment</a></h2>
<p>The wasm environment will most likely be libraries that provide APIs for the wasm modules.</p>
<h3 id="common-environment"><a class="header" href="#common-environment">Common environment</a></h3>
<p>The common environment of VPs and transactions APIs:</p>
<ul>
<li>math &amp; crypto</li>
<li>logging</li>
<li>panics/aborts</li>
<li>gas metering</li>
<li>storage read-only API</li>
<li>context API (chain metadata such as block height)</li>
</ul>
<p>The accounts sub-space storage is described under <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>.</p>
<h3 id="vps-environment"><a class="header" href="#vps-environment">VPs environment</a></h3>
<p>Because VPs are stateless, everything that is exposed in the VPs environment should be read-only:</p>
<ul>
<li>storage API to account sub-space the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
<li>transaction API</li>
</ul>
<h3 id="transactions-environment"><a class="header" href="#transactions-environment">Transactions environment</a></h3>
<ul>
<li>storage write access for all public state via the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
</ul>
<p>Some exceptions as to what can be written are given under <a href="explore/design/ledger/./tx.html#tx-execution">transaction execution</a>.</p>
<h2 id="wasm-memory"><a class="header" href="#wasm-memory">Wasm memory</a></h2>
<p>The wasm memory allows to share data bi-directionally between the host (Rust shell) and the guest (wasm) through a <a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-meminst">wasm linear memory instance</a>.</p>
<p>Because <a href="https://webassembly.github.io/spec/core/syntax/types.html">wasm currently only supports basic types</a>, we need to choose how to represent more sophisticated data in memory.</p>
<p>The options on how the data can be passed through the memory are:</p>
<ul>
<li>using <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc">&quot;C&quot; structures</a> (probably too invasive because everything in memory would have to use C repr)</li>
<li>(de)serializing the data with some encoding (JSON, binary, ...?)</li>
<li>currently very unstable: <a href="https://developer.mozilla.org/en-US/docs/Glossary/WebIDL">WebIDL</a> / <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">Interface Types</a> / <a href="https://github.com/WebAssembly/reference-types">Reference types</a></li>
</ul>
<p>The choice should allow for easy usage in wasm for users (e.g. in Rust a bindgen macro on data structures, similar to <a href="https://github.com/rustwasm/wasm-bindgen">wasm_bindgen used for JS &lt;-&gt; wasm</a>).</p>
<p>Related <a href="https://github.com/wasmerio/wasmer/issues/315">wasmer issue</a>.</p>
<p>We're currently using borsh for storage serialization, which is also a good option for wasm memory. </p>
<ul>
<li>it's easy for users (can be derived)</li>
<li>because borsh encoding is safe and consistent, the encoded bytes can also be used for Merkle tree hashing</li>
<li>good performance, although it's not clear at this point if that may be negligible anyway</li>
</ul>
<h3 id="the-data"><a class="header" href="#the-data">The data</a></h3>
<p>The data being passed between the host and the guest in the order of the execution:</p>
<ul>
<li>For transactions:
<ul>
<li>host-to-guest: pass tx.data to tx.code call</li>
<li>guest-to-host: parameters of environment functions calls, including storage modifications (pending on storage API)</li>
<li>host-to-guest: return results for host calls</li>
</ul>
</li>
<li>For validity predicates:
<ul>
<li>host-to-guest: pass tx.data, prior and posterior account storage sub-space state and/or storage modifications (i.e. a write log) for the account</li>
<li>guest-to-host: parameters of environment function calls</li>
<li>host-to-guest: return results for host calls</li>
<li><del>guest-to-host</del>: the VP result (<code>bool</code>) can be passed directly from the call</li>
</ul>
</li>
</ul>
<h3 id="storage-write-log"><a class="header" href="#storage-write-log">Storage write log</a></h3>
<p>The storage write log gathers any storage updates (<code>write</code>/<code>delete</code>s) performed by transactions. For each transaction, the write log changes must be accepted by all the validity predicates that were triggered by these changes.</p>
<p>A validity predicate can read its prior state directly from storage as it is not changed by the transaction directly. For the posterior state, we first try to look-up the keys in the write log to try to find a new value if the key has been modified or deleted. If the key is not present in the write log, it means that the value has not changed and we can read it from storage.</p>
<p>The write log of each transaction included in a block and accepted by VPs is accumulated into the block write log. Once the block is committed, we apply the storage changes from the block write log to the persistent storage.</p>
<p><img src="explore/design/ledger/./wasm-vm/storage-write-log.svg" alt="write log" title="storage write log" />
<a href="https://excalidraw.com/new#room=333e1db689b083669c80,Y0i8yhvIAZCFICs753CSuA">Diagram on Excalidraw</a></p>
<h2 id="gas-metering"><a class="header" href="#gas-metering">Gas metering</a></h2>
<p>The two main options for implementing gas metering within wasm using wasmer are:</p>
<ul>
<li>a <a href="https://github.com/wasmerio/wasmer/tree/72d47336cc1461d63baa2322b38c4cb5f67bb72a/lib/middlewares">gas metering middleware included in wasmer</a>.</li>
<li><a href="https://crates.io/crates/pwasm-utils">https://crates.io/crates/pwasm-utils</a></li>
</ul>
<p>Both of these allow us to assign a gas cost for each wasm operation.</p>
<p><code>wasmer</code> gas middleware is more recent, so probably more risky. It injects the gas metering code into the wasm code, which is more efficient than host calls to a gas meter.</p>
<p><code>pwasm-utils</code> divides the wasm code into metered blocks. It performs host call with the gas cost of each block before it is executed. The gas metering injection is linear to the code size.</p>
<p>The <code>pwasm-utils</code> seems like a safer option to begin with (and we'll probably need to use it for <a href="explore/design/ledger/wasm-vm.html#stack-height-metering">stack height metering</a> too). We can look into switching to <code>wasmer</code> middleware at later point.</p>
<h2 id="stack-height-metering"><a class="header" href="#stack-height-metering">Stack height metering</a></h2>
<p>For safety, we need to limit the stack height in wasm code. Similarly to gas metering, we can also use <code>wasmer</code> middleware or <code>pwasm-utils</code>.</p>
<p>We have to use <code>pwasm-utils</code>, because <code>wasmer</code>'s stack limiter is currently non-deterministic (platform specific). This is to be fixed in this PR: <a href="https://github.com/wasmerio/wasmer/pull/1037">https://github.com/wasmerio/wasmer/pull/1037</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="front-running-prevention"><a class="header" href="#front-running-prevention">Front-running prevention</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/42">Tracking Issue</a></p>
<hr />
<p>This page should describe how DKG can be integrated for front-running prevention.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fractal-scaling"><a class="header" href="#fractal-scaling">Fractal scaling</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/41">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-system"><a class="header" href="#upgrade-system">Upgrade system</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/40">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>We can make use of the Tendermint's finality property to split the storage into immutable and mutable parts, where only the data at the current level is mutable. It should be possible to have the mutable state in-memory only and write to DB only once a block is finalized, which combined with batch writes would most likely be quite efficient (this can also be done asynchronously).</p>
<pre class="mermaid">graph LR
  subgraph &quot;in-memory&quot;
    LN[level n]
  end
  subgraph &quot;DB (each level is immutable once written)&quot;
    LN .-&gt; LNL[level n - 1]
    LNL ===== L0[level 0]
  end
</pre>
<h2 id="in-memory-mutable-state"><a class="header" href="#in-memory-mutable-state">In-memory (mutable state)</a></h2>
<p>The current state is stored in a Sparse Merkle tree. The layout of data in memory should be flexible to allow to optimize throughput. For example, the values of key/value pairs may better stored in a sequence outside of the tree structure. Furthermore, it maybe be better to have the data sorted in memory. This may be possible by decoupling the merkle tree structure from the data and the key/value pairs, as illustrated below.</p>
<pre class="mermaid">graph TD
  subgraph storage
    subgraph sparse merkle tree
      B[branches as paths segments in hashes of keys] .-&gt; L[leaves as a hashes of values]
    end
    subgraph columns
      KV[dictionaries of key/value pairs]
    end
  end
</pre>
<p>It may be advantageous if the data columns keys are not hashed to preserve ordering.</p>
<h2 id="db-immutable-state"><a class="header" href="#db-immutable-state">DB (immutable state)</a></h2>
<p>The immutable state doesn't have the same requirements as the mutable. This means that a different data structures or memory layout may perform better (subject to benchmarks). The state trees in the immutable blocks should take advantage of its properties for optimization. For example, it can save storage space by sharing common data and/or delta compression. </p>
<p>It's very likely that different settings for immutable storage will be provided in future, similar to e.g. <a href="https://tezos.gitlab.io/user/history_modes.html">Tezos history modes</a>.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>We'd like to have easily reproducible benchmarks for the whole database integration that should be filled over time with pre-generated realistic data. This should enable us to tune and compare different hashing functions, backends, data structures, memory layouts, etc.</p>
<h3 id="criteria"><a class="header" href="#criteria">Criteria</a></h3>
<ul>
<li>in-memory
<ul>
<li>writes (insert, update, delete)
<ul>
<li>possibly also concurrent writes, pending on the approach taken for concurrent transaction execution</li>
</ul>
</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
<li>DB (lower priority)
<ul>
<li>writes in batched mode</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
</ul>
<h2 id="db-backends"><a class="header" href="#db-backends">DB backends</a></h2>
<p>The considered options for a DB backend are given in <a href="explore/design/ledger/../../libraries/db.html">Libraries &amp; Tools / Database page</a>.</p>
<h3 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h3>
<p>A committed block is not immediately persisted on RocksDB. When the block is committed, a set of key-value pairs which compose the block is written to the memtable on RocksDB. For the efficient sequential write, a flush is executed to persist the data on the memtable to the disk as a file when the size of the memtable is getting big (the threshold is one of the tuning parameters).</p>
<p>We can disable write-ahead log(WAL) which protects these data on the memtable from a crash by persisting the write logs to the disk. Disabling WAL helps reduce the write amplification. That's because WAL isn't required for Anoma because other nodes have the block. The blocks which have not been persisted to the disk by flush can be recovered even if an Anoma node crashes.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="storage-module"><a class="header" href="#storage-module"><code>storage</code> module</a></h3>
<p>This is the main interface for interacting with storage in Anoma.</p>
<p>This module and its sub-modules should implement the in-memory storage (and/or a cache layer) with Merkle tree (however, the interface should be agnostic to the choice of vector commitment scheme or whether or not there even is one, we may want non-Merklised storage) and the persistent DB.</p>
<p>The in-memory storage holds chain's metadata and current block's storage.</p>
<p>Its public API should allow/provide:</p>
<ul>
<li>get the Merkle root and Merkle tree proofs</li>
<li>read-only storage API for ledger's metadata to be accessible for transactions' code, VPs and the RPC
<ul>
<li>with public types of all the stored metadata</li>
</ul>
</li>
<li>unless specified otherwise, read the state from the current block</li>
</ul>
<p>An API made visible only to the shell module (e.g. <code>pub ( in SimplePath )</code> - https://doc.rust-lang.org/reference/visibility-and-privacy.html) should allow the shell to:</p>
<ul>
<li>load state from DB for latest persisted block or initialize a new storage if none found</li>
<li>begin a new block</li>
<li>within a block:
<ul>
<li>transaction can modify <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">account sub-space</a>
<ul>
<li>the function that modify storage (e.g. <code>write</code> and <code>delete</code>) have to guarantee to also update the Merkle tree</li>
</ul>
</li>
<li>store each applied transaction and its result</li>
</ul>
</li>
<li>end the current block</li>
<li>commit the current block (persist to storage)</li>
</ul>
<h3 id="storagedb-module"><a class="header" href="#storagedb-module"><code>storage/db</code> module</a></h3>
<p>The persistent DB implementation (e.g. RocksDB).</p>
<h3 id="db-keys"><a class="header" href="#db-keys">DB keys</a></h3>
<p>The DB keys are composed of key segments. A key segment can be an <code>Address</code> which starts with <code>#</code> (there can be multiple addresses involved in a key) or any user defined non-empty utf-8 string (maybe limited to only alphanumerical characters). Also, <code>/</code> and <code>?</code> are reserved. <code>/</code> is used as a separator for segments. <code>?</code> is reserved for a validity predicate and the key segment <code>?</code> can be specified only by the specific API.</p>
<p>In the DB storage, the keys would be prefixed by the block height and the space type. This would be hidden from the wasm environment, which only operates at the current block height. For example, when the block height is <code>123</code> and the key specified by the storage is <code>#my_address_hash/balance/token</code>, the actual key for the persistent DB implementation would be <code>123/subspace/#my_address_hash/balance/token</code>.</p>
<p>This could roughly be implemented as:</p>
<pre><code>struct Key {
    segments: Vec&lt;DbKeySeg&gt;
}

impl Key {
    fn parse(string: String) -&gt; Result&lt;Self, Error&gt; {..}
    fn push(&amp;self, other: &amp;KeySeg) -&gt; Self {..}
    fn join(&amp;self, other: &amp;Key) -&gt; Self {..}
    fn into_string(&amp;self) -&gt; String;
    // find addresses included in the key, used to find which validity-predicates should be triggered by a key space change
    fn find_addresses(&amp;self) -&gt; Vec&lt;Address&gt; {..}
}

// Provide a trait so that we can define new pre-defined key segment types inside wasm environment and also ad-hoc key segments defined by wasm users
trait KeySeg {
    fn parse(string: String) -&gt; Result&lt;Self, Error&gt;;
    fn to_string(&amp;self) -&gt; String;
    fn to_db_key(&amp;self) -&gt; DbKeySeg;
}

enum DbKeySeg {
    AddressSeg(Address),
    StringSeg(String),
}

impl KeySeg for DbKeySeg {..}
impl KeySeg for BlockHeight {..}
</code></pre>
<p>Then the storage API functions (read/write/delete) should only accept the keys with this <code>Key</code> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-schema"><a class="header" href="#data-schema">Data schema</a></h1>
<p>At high level, all the data in the <a href="explore/design/ledger/storage/../accounts.html#dynamic-storage-sub-space">accounts' dynamic
sub-spaces</a> is just keys associated with
arbitrary bytes and intents are just wrapper around arbitrary data. To help the
processes that read and write this data (transactions, validity predicates,
matchmaker) interpret it and implement interesting functionality on top it, the
ledger could provide a way to describe the schema of the data.</p>
<p>For storage data encoding, we're currently using the borsh library, which
provides a way to derive schema for data that can describe its structure in a
very generic way that can easily be consumed in different data-exchange formats
such as JSON. In Rust code, the data can be composed with Rust native ADTs
(<code>struct</code> and <code>enum</code>) and basic collection structures (fixed and dynamic sized
array, hash map, hash set). Borsh already has a decent coverage of different
implementations in e.g. JS and TypeScript, JVM based languages and Go, which
we'll hopefully be able to support in wasm in near future too.</p>
<p>Note that the borsh data schema would not be forced upon the users as they can
still build and use custom data with arbitrary encoding.</p>
<p>A naive implementation could add optional <code>schema</code> field to each stored key. To
reduce redundancy, there could be some &quot;built-in&quot; schemas and/or specific
storage space for commonly used data schema definitions. Storage fees apply, but
perhaps they can be split between all the users, so some commonly used data
schema may be almost free.</p>
<p>A single address in the ledger is define with all schema. A specific schema can
be looked up with a key in its subspace. The schema variable is not yet
implemented and the definition might change to something more appropiate.</p>
<h2 id="schema-derived-library-code"><a class="header" href="#schema-derived-library-code">Schema derived library code</a></h2>
<h3 id="account-example"><a class="header" href="#account-example">account example</a></h3>
<p>Let's start with an example, in which some users want to deploy a
multi-signature account to some shared asset. They create a transaction, which
would initialize a new account with an address <code>shared-savings</code> and write into
its storage sub-space the initial funds for the account and data under the key
<code>&quot;multisig&quot;</code> with the following definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct MultiSig {
    threshold: u64,
    counter: u64,
    keys: Vec&lt;PublicKey&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>When the transaction is applied, the data is stored together with a reference to
the derived data schema, e.g.:</p>
<pre><code class="language-json">{
  &quot;MultiSig&quot;: {
    &quot;struct&quot;: {
      &quot;named_fields&quot;: {
        &quot;threshold&quot;: &quot;u64&quot;,
        &quot;counter&quot;: &quot;u64&quot;,
        &quot;keys&quot;: {
          &quot;sequence&quot;: &quot;PublicKey&quot;
        }
      }
    }
  }
}
</code></pre>
<p>Now any transaction that wants to interact with this account can look-up and use its data schema. We can also use this information to display values read from storage from e.g. RPC or indexer.</p>
<p>What's more, when the data has schema attached on-chain, with borsh we have bijective mapping between the data definitions and their schemas. We can use this nice property to generate code for data definitions back from the schema in any language supported by borsh and that we'll able to support in wasm.</p>
<p>We can take this a step further and even generate some code for data access on top of our wasm environment functions to lift the burden of encoding/decoding data from storage. For our example, from the key <code>&quot;multisig&quot;</code>, in Rust we can generate this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_multisig() -&gt; MultiSig;
fn write_multisig(MultiSig);
fn with_multisig(FnMut(MultiSig) -&gt; MultiSig);
<span class="boring">}
</span></code></pre></pre>
<p>Which can be imported like regular library code in a transaction and arbitrarily extended by the users. Similarly, the schema could be used to derive some code for validity predicates and intents.</p>
<p>We can generate the code on demand (e.g. we could allow to query a node to generate library code for some given accounts for a given language), but we could also provide some helpers for e.g. foundation's or validator's node to optionally automatically publish generated code via git for all the accounts in the current state. In Rust, using this library could look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// load the account(s) code where the identifier is the account's address.
use anoma_accounts::SharedSavings;

fn transaction(...) {
  let multisig = SharedSavings::read_multisig();
  ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pos-integration"><a class="header" href="#pos-integration">PoS integration</a></h1>
<p>The <a href="explore/design/ledger/../pos.html">PoS system</a> is integrated into Anoma ledger at 3 different layers:</p>
<ul>
<li>base ledger that performs genesis initialization, validator set updates on new epoch and applies slashes when they are received from ABCI</li>
<li>an account with an internal address and a <a href="explore/design/ledger/vp.html#native-vps">native VP</a> that validates any changes applied by transactions to the PoS account state</li>
<li>transaction WASMs to perform various PoS actions, also available as a library code for custom made transactions</li>
</ul>
<p>The <code>votes_per_token</code> PoS system parameter must be chosen to satisfy the <a href="https://github.com/tendermint/spec/blob/60395941214439339cc60040944c67893b5f8145/spec/abci/apps.md#validator-updates">Tendermint requirement</a> of <code>MaxTotalVotingPower = MaxInt64 / 8</code>.</p>
<p>All <a href="explore/design/ledger/../pos.html#storage">the data relevant to the PoS system</a> are stored under the PoS account's storage sub-space, with the following key schema (the PoS address prefix is omitted for clarity):</p>
<ul>
<li>
<p><code>params</code> (required): the system parameters</p>
</li>
<li>
<p>for any validator, all the following fields are required:</p>
<ul>
<li><code>validator/{validator_address}/consensus_key</code></li>
<li><code>validator/{validator_address}/state</code></li>
<li><code>validator/{validator_address}/total_deltas</code></li>
<li><code>validator/{validator_address}/voting_power</code></li>
</ul>
</li>
<li>
<p><code>slash/{validator_address}</code> (optional): a list of slashes, where each record contains epoch and slash rate</p>
</li>
<li>
<p><code>bond/{bond_source}/{bond_validator} (optional)</code></p>
</li>
<li>
<p><code>unbond/{unbond_source}/{unbond_validator} (optional)</code></p>
</li>
<li>
<p><code>validator_set (required)</code></p>
</li>
<li>
<p><code>total_voting_power (required)</code></p>
</li>
<li>
<p>standard validator metadata (these are regular storage values, not epoched data):</p>
<ul>
<li><code>validator/{validator_address}/staking_reward_address</code> (required): an address that should receive staking rewards</li>
<li><code>validator/{validator_address}/address_raw_hash</code> (required): raw hash of validator's address associated with the address is used for look-up of validator address from a raw hash</li>
<li>TBA (e.g. alias, website, description, delegation commission rate, etc.)</li>
</ul>
</li>
</ul>
<p>Only XAN tokens can be staked in bonds. The tokens being staked (bonds and unbonds amounts) are kept in the PoS account under <code>{xan_address}/balance/{pos_address}</code> until they are withdrawn.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>The PoS system is initialized via the shell on chain initialization. The genesis validator set is given in the genesis configuration. On genesis initialization, all the epoched data is set to be immediately active for the current (the very first) epoch.</p>
<h2 id="staking-rewards-and-transaction-fees"><a class="header" href="#staking-rewards-and-transaction-fees">Staking rewards and transaction fees</a></h2>
<p>Staking rewards for validators are rewarded in Tendermint's method <code>BeginBlock</code> in the base ledger. A validator must specify a <code>validator/{validator_address}/staking_reward_address</code> for its rewards to be credited to this address.</p>
<p>To a validator who proposed a block (<code>block.header.proposer_address</code>), the system rewards tokens based on the <code>block_proposer_reward</code> PoS parameter and each validator that voted on a block (<code>block.last_commit_info.validator</code> who <code>signed_last_block</code>) receives <code>block_vote_reward</code>.</p>
<p>All the fees that are charged in a transaction execution (DKG transaction wrapper fee and transactions applied in a block) are transferred into a fee pool, which is another special account controlled by the PoS module. Note that the fee pool account may contain tokens other than the staking token XAN.</p>
<ul>
<li>TODO describe the fee pool, related to <a href="https://github.com/anomanetwork/anoma/issues/48">https://github.com/anomanetwork/anoma/issues/48</a>, <a href="https://github.com/anomanetwork/anoma/issues/51">https://github.com/anomanetwork/anoma/issues/51</a> and <a href="https://github.com/anomanetwork/anoma/issues/72">https://github.com/anomanetwork/anoma/issues/72</a></li>
</ul>
<h2 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h2>
<p>The transactions are assumed to be applied in epoch <code>n</code>. Any transaction that modifies <a href="explore/design/ledger/../pos.html#epoched-data">epoched data</a> updates the structure as described in <a href="explore/design/ledger/../pos.html#storage">epoched data storage</a>.</p>
<p>For slashing tokens, we implement a <a href="explore/design/ledger/vp.html#pos-slash-pool-vp">PoS slash pool account</a>. Slashed tokens should be credited to this account and, for now, no tokens can be be debited by anyone.</p>
<h3 id="validator-transactions"><a class="header" href="#validator-transactions">Validator transactions</a></h3>
<p>The validator transactions are assumed to be applied with an account address <code>validator_address</code>.</p>
<ul>
<li><code>become_validator(consensus_key, staking_reward_address)</code>:
<ul>
<li>creates a record in <code>validator/{validator_address}/consensus_key</code> in epoch <code>n + pipeline_length</code></li>
<li>creates a record in <code>validator/{validator_address}/staking_reward_address</code></li>
<li>sets <code>validator/{validator_address}/state</code> for to <code>pending</code> in the current epoch and <code>candidate</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>deactivate</code>:
<ul>
<li>sets <code>validator/{validator_address}/state</code> for to <code>inactive</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>reactivate</code>:
<ul>
<li>sets <code>validator/{validator_address}/state</code> for to <code>pending</code> in the current epoch and <code>candidate</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>self_bond(amount)</code>:
<ul>
<li>let <code>bond = read(bond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> exist, update it with the new bond amount in epoch <code>n + pipeline_length</code></li>
<li>else, create a new record with bond amount in epoch <code>n + pipeline_length</code></li>
<li>debit the token <code>amount</code> from the <code>validator_address</code> and credit it to the PoS account</li>
<li>add the <code>amount</code> to <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>unbond(amount)</code>:
<ul>
<li>let <code>bond = read(bond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> doesn't exist, panic</li>
<li>let <code>pre_unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>total(bond) - total(pre_unbond) &lt; amount</code>, panic</li>
<li>decrement the <code>bond</code> deltas starting from the rightmost value (a bond in a future-most epoch) until whole <code>amount</code> is decremented</li>
<li>for each decremented <code>bond</code> value write a new <code>unbond</code> with the key set to the epoch of the source value</li>
<li>decrement the <code>amount</code> from <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + unbonding_length</code></li>
</ul>
</li>
<li><code>withdraw_unbonds</code>:
<ul>
<li>let <code>unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>unbond</code> doesn't exist, panic</li>
<li>if no <code>unbond</code> value is found for epochs &lt;= <code>n</code>, panic</li>
<li>for each <code>((bond_start, bond_end), amount) in unbond where unbond.epoch &lt;= n</code>:
<ul>
<li>let <code>amount_after_slash = amount</code></li>
<li>for each <code>slash in read(slash/{validator_address})</code>:
<ul>
<li>if <code>bond_start &lt;= slash.epoch &amp;&amp; slash.epoch &lt;= bond_end)</code>, <code>amount_after_slash *= (10_000 - slash.rate) / 10_000</code></li>
</ul>
</li>
<li>credit the <code>amount_after_slash</code> to the <code>validator_address</code> and debit the whole <code>amount</code> (before slash, if any) from the PoS account</li>
<li>burn the slashed tokens (<code>amount - amount_after_slash</code>), if not zero</li>
</ul>
</li>
</ul>
</li>
<li><code>change_consensus_key</code>:
<ul>
<li>creates a record in <code>validator/{validator_address}/consensus_key</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
</ul>
<p>For <code>self_bond</code>, <code>unbond</code>, <code>withdraw_unbonds</code>, <code>become_validator</code> and <code>change_consensus_key</code> the transaction must be signed with the validator's public key. Additionally, for <code>become_validator</code> and <code>change_consensus_key</code> we must attach a signature with the validator's consensus key to verify its ownership. Note that for <code>self_bond</code>, signature verification is also performed because there are tokens debited from the validator's account.</p>
<h3 id="delegator-transactions"><a class="header" href="#delegator-transactions">Delegator transactions</a></h3>
<p>The delegator transactions are assumed to be applied with an account address <code>delegator_address</code>.</p>
<ul>
<li><code>delegate(validator_address, amount)</code>:
<ul>
<li>let <code>bond = read(bond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> exist, update it with the new bond amount in epoch <code>n + pipeline_length</code></li>
<li>else, create a new record with bond amount in epoch <code>n + pipeline_length</code></li>
<li>debit the token <code>amount</code> from the <code>delegator_address</code> and credit it to the PoS account</li>
<li>add the <code>amount</code> to <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>undelegate(validator_address, amount)</code>:
<ul>
<li>let <code>bond = read(bond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> doesn't exist, panic</li>
<li>let <code>pre_unbond = read(unbond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>total(bond) - total(pre_unbond) &lt; amount</code>, panic</li>
<li>decrement the <code>bond</code> deltas starting from the rightmost value (a bond in a future-most epoch) until whole <code>amount</code> is decremented</li>
<li>for each decremented <code>bond</code> value write a new <code>unbond</code> with the key set to the epoch of the source value</li>
<li>decrement the <code>amount</code> from <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + unbonding_length</code></li>
</ul>
</li>
<li><code>redelegate(src_validator_address, dest_validator_address, amount)</code>:
<ul>
<li><code>undelegate(src_validator_address, amount)</code></li>
<li><code>delegate(dest_validator_address, amount)</code> but set in epoch <code>n + unbonding_length</code> instead of <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>withdraw_unbonds</code>:
<ul>
<li>for each <code>validator_address in iter_prefix(unbond/{delegator_address})</code>:
<ul>
<li>let <code>unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if no <code>unbond</code> value is found for epochs &lt;= <code>n</code>, <code>continue</code> to the next <code>validator_address</code></li>
<li>for each <code>((bond_start, bond_end), amount)</code> in epochs &lt;= <code>n</code>:
<ul>
<li>let <code>amount_after_slash = amount</code></li>
<li>for each <code>slash in read(slash/{validator_address})</code>:
<ul>
<li>if <code>bond_start &lt;= slash.epoch &amp;&amp; slash.epoch &lt;= bond_end)</code>, <code>amount_after_slash *= (10_000 - slash.rate) / 10_000</code></li>
</ul>
</li>
<li>credit the <code>amount_after_slash</code> to the <code>delegator_address</code> and debit the whole <code>amount</code> (before slash, if any) from the PoS account</li>
<li>burn the slashed tokens (<code>amount - amount_after_slash</code>), if not zero</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For <code>delegate</code>, <code>undelegate</code>, <code>redelegate</code> and <code>withdraw_unbonds</code> the transaction must be signed with the delegator's public key. Note that for <code>delegate</code>, signature verification is also performed because there are tokens debited from the delegator's account.</p>
<h2 id="slashing"><a class="header" href="#slashing">Slashing</a></h2>
<p>Evidence for byzantine behaviour is received from Tendermint ABCI on <code>BeginBlock</code>. For each evidence:</p>
<ul>
<li>append the <code>evidence</code> into <code>slash/{evidence.validator_address}</code></li>
<li>calculate the slashed amount from deltas in and before the <code>evidence.epoch</code> in <code>validator/{validator_address}/total_deltas</code> for the <code>evidence.validator_address</code> and the slash rate</li>
<li>deduct the slashed amount from the <code>validator/{validator_address}/total_deltas</code> at <code>pipeline_length</code> offset</li>
<li>update the <code>validator/{validator_address}/voting_power</code> for the <code>evidence.validator_address</code> in and after epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in and after epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in and after epoch <code>n + pipeline_length</code></li>
</ul>
<h2 id="validity-predicate"><a class="header" href="#validity-predicate">Validity predicate</a></h2>
<p>In the following description, &quot;pre-state&quot; is the state prior to transaction execution and &quot;post-state&quot; is the state posterior to it.</p>
<p>Any changes to PoS epoched data are checked to update the structure as described in <a href="explore/design/ledger/../pos.html#storage">epoched data storage</a>.</p>
<p>Because some key changes are expected to relate to others, the VP also accumulates some values that are checked for validity after key specific logic:</p>
<ul>
<li><code>balance_delta: token::Change</code></li>
<li><code>bond_delta: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>unbond_delta: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>total_deltas: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>total_stake_by_epoch: HashMap&lt;Epoch, HashMap&lt;Address, token::Amount&gt;&gt;</code></li>
<li><code>expected_voting_power_by_epoch: HashMap&lt;Epoch, HashMap&lt;Address, VotingPower&gt;&gt;</code>: calculated from the validator's total deltas</li>
<li><code>expected_total_voting_power_delta_by_epoch: HashMap&lt;Epoch, VotingPowerDelta&gt;</code>: calculated from the validator's total deltas</li>
<li><code>voting_power_by_epoch: HashMap&lt;Epoch, &lt;HashMap&lt;Address, VotingPower&gt;&gt;</code></li>
<li><code>validator_set_pre: Option&lt;ValidatorSets&lt;Address&gt;&gt;</code></li>
<li><code>validator_set_post: Option&lt;ValidatorSets&lt;Address&gt;&gt;</code></li>
<li><code>total_voting_power_delta_by_epoch: HashMap&lt;Epoch, VotingPowerDelta&gt;</code></li>
<li><code>new_validators: HashMap&lt;Address, NewValidator&gt;</code></li>
</ul>
<p>The accumulators are initialized to their default values (empty hash maps and hash set). The data keyed by address are using the validator addresses.</p>
<p>For any updated epoched data, the <code>last_update</code> field must be set to the current epoch.</p>
<p>The validity predicate triggers a validation logic based on the storage keys modified by a transaction:</p>
<ul>
<li><code>validator/{validator_address}/consensus_key</code>:
<pre><code class="language-rust ignore">match (pre_state, post_state) {
  (None, Some(post)) =&gt; {
    // - check that all other required validator fields have been initialized
    // - check that the `state` sub-key for this validator address has been set
    // correctly, i.e. the value should be initialized at `pipeline_length` offset
    // - insert into or update `new_validators` accumulator
  },
  (Some(pre), Some(post)) =&gt; {
    // - check that the new consensus key is different from the old consensus
    // key and that it has been set correctly, i.e. the value can only be changed at `pipeline_length` offset
  },
  _ =&gt; false,
}
</code></pre>
</li>
<li><code>validator/{validator_address}/state</code>:
<pre><code class="language-rust ignore">match (pre_state, post_state) {
  (None, Some(post)) =&gt; {
    // - check that all other required validator fields have been initialized
    // - check that the `post` state is set correctly:
    //   - the state should be set to `pending` in the current epoch and `candidate` at pipeline offset
    // - insert into or update `new_validators` accumulator
  },
  (Some(pre), Some(post)) =&gt; {
    // - check that a validator has been correctly deactivated or reactivated
    // - the `state` should only be changed at `pipeline_length` offset
    // - if the `state` becomes `inactive`, it must have been `pending` or `candidate`
    // - if the `state` becomes `pending`, it must have been `inactive`
    // - if the `state` becomes `candidate`, it must have been `pending` or `inactive`
  },
  _ =&gt; false,
}
</code></pre>
</li>
<li><code>validator/{validator_address}/total_deltas</code>:
<ul>
<li>find the difference between the pre-state and post-state values and add it to the <code>total_deltas</code> accumulator and update <code>total_stake_by_epoch</code>, <code>expected_voting_power_by_epoch</code> and <code>expected_total_voting_power_delta_by_epoch</code></li>
</ul>
</li>
<li><code>validator/{validator_address}/voting_power</code>:
<ul>
<li>find the difference between the pre-state and post-state value and insert it into the <code>voting_power_by_epoch</code> accumulator</li>
</ul>
</li>
<li><code>bond/{bond_source}/{bond_validator}/delta</code>:
<ul>
<li>for each difference between the post-state and pre-state values:
<ul>
<li>if the difference is not in epoch <code>n</code> or <code>n + pipeline_length</code>, panic</li>
<li>find slashes for the <code>bond_validator</code>, if any, and apply them to the delta value</li>
<li>add it to the <code>bond_delta</code> accumulator</li>
</ul>
</li>
</ul>
</li>
<li><code>unbond/{unbond_source}/{unbond_validator}/deltas</code>:
<ul>
<li>for each difference between the post-state and pre-state values:
<ul>
<li>if the difference is not in epoch <code>n</code> or <code>n + unboding_length</code>, panic</li>
<li>find slashes for the <code>bond_validator</code>, if any, and apply them to the delta value</li>
<li>add it to the <code>unbond_delta</code> accumulator</li>
</ul>
</li>
</ul>
</li>
<li><code>validator_set</code>:
<ul>
<li>set the accumulators <code>validator_set_pre</code> and <code>validator_set_post</code></li>
</ul>
</li>
<li><code>total_voting_power</code>:
<ul>
<li>find the difference between the post-state and pre-state</li>
<li>add it to the <code>total_voting_power_delta_by_epoch</code> accumulator</li>
</ul>
</li>
<li>PoS account's balance:
<ul>
<li>find the difference between the post-state and pre-state</li>
<li>add it to the <code>balance_delta</code> accumulator</li>
</ul>
</li>
</ul>
<p>No other storage key changes are permitted by the VP.</p>
<p>After the storage keys iteration, we check the accumulators:</p>
<ul>
<li>For each <code>total_deltas</code>, there must be the same delta value in <code>bond_delta</code>.</li>
<li>For each <code>bond_delta</code>, there must be validator's change in <code>total_deltas</code>.</li>
<li>Check that all positive <code>unbond_delta</code> also have a <code>total_deltas</code> update. Negative unbond delta is from withdrawing, which removes tokens from unbond, but doesn't affect total deltas.</li>
<li>Check validator sets updates against validator total stakes.</li>
<li>Check voting power changes against validator total stakes.</li>
<li>Check expected voting power changes against <code>voting_power_by_epoch</code>.</li>
<li>Check expected total voting power change against <code>total_voting_power_delta_by_epoch</code>.</li>
<li>Check that the sum of bonds and unbonds deltas is equal to the balance delta.</li>
<li>Check that all the new validators have their required fields set and that they have been added to the validator set</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-primitives"><a class="header" href="#crypto-primitives">Crypto primitives</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/39">Tracking Issue</a></p>
<hr />
<p>This page should describe cryptography primitives that we might want to use, such as types of keys, hashing functions, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors-and-incentives"><a class="header" href="#actors-and-incentives">Actors and Incentives</a></h1>
<p>Anoma consists of various actors fulfilling various roles in the network. They are all incentivized to act for the good of the network. The native Anoma token <code>XAN</code> is used to settle transaction fees and pay for the incentives in Anoma.</p>
<h2 id="fees-associated-with-a-transaction"><a class="header" href="#fees-associated-with-a-transaction">Fees associated with a transaction</a></h2>
<p>Users of Anoma can</p>
<ul>
<li>transfer private assets they hold to other users and</li>
<li>barter assets with other users.</li>
</ul>
<p>Each transaction may be associated with the following fees, paid in <code>XAN</code>:</p>
<ul>
<li><strong>Execution fees</strong> to compensate for computing, storage and memory costs, charges at 2 stages:
<ul>
<li><strong>initial fee (init_f)</strong>: charged before the transaction is settled</li>
<li><strong>post-execution fee (exe_f)</strong>: charged after the settlement</li>
</ul>
</li>
<li><strong>Exchange fee (ex_f)</strong>: a fee proportional to the value exchanged in a trade</li>
</ul>
<h2 id="actors-and-their-associated-fees-and-responsibilities"><a class="header" href="#actors-and-their-associated-fees-and-responsibilities">Actors and their associated fees and responsibilities</a></h2>
<table><thead><tr><th>Actor</th><th>Responsibilities</th><th>Incentives</th><th>Bond in escrow</th><th>May also be</th></tr></thead><tbody>
<tr><td>User</td><td>Make offers or send transactions</td><td>Features of Anoma</td><td>X</td><td>Anyone</td></tr>
<tr><td>Signer</td><td>Generate key shards</td><td>portions of init_f, exe_f</td><td>‚úì</td><td>Validator</td></tr>
<tr><td>Validator</td><td>Validate</td><td>portions of init_f, exe_f</td><td>‚úì</td><td>Signer</td></tr>
<tr><td>Submitter</td><td>Submit orders &amp; pay init_f</td><td>successful orders get init_f back plus bonus</td><td>X</td><td></td></tr>
<tr><td>Intent gossip operator</td><td>Signs and shares orders</td><td>portions of init_f, exe_f</td><td>X</td><td></td></tr>
<tr><td>Market maker</td><td>Signs and broadcast orders</td><td>the difference between the ask and bid price</td><td>X</td><td></td></tr>
<tr><td>Proposer</td><td>Proposes blocks</td><td>portions of init_f, exe_f</td><td></td><td>Validator</td></tr>
</tbody></table>
<p>Questions to explore:</p>
<ul>
<li>
<p>How do we calculate the incentives? What are the equations for each actor?</p>
</li>
<li>
<p>How do we calculate the bond/reward for the signers and validators?</p>
</li>
<li>
<p>How do we ensure certain dual/multi agencies are allowed but not others? E.g., signers can be validators but we may not want them to be proposers because they may have knowledge of which transactions are encrypted.</p>
</li>
</ul>
<h2 id="actors-and-fees-flowchart"><a class="header" href="#actors-and-fees-flowchart">Actors and fees flowchart</a></h2>
<p><img src="explore/design/summary.png?raw=true" alt="Summary" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-stake-pos-system"><a class="header" href="#proof-of-stake-pos-system">Proof of Stake (PoS) system</a></h1>
<h2 id="epoch"><a class="header" href="#epoch">Epoch</a></h2>
<p>An epoch is a range of blocks or time that is defined by the base ledger and made available to the PoS system. This document assumes that epochs are identified by consecutive natural numbers. All the data relevant to PoS are <a href="explore/design/pos.html#epoched-data">associated with epochs</a>.</p>
<h3 id="epoched-data"><a class="header" href="#epoched-data">Epoched data</a></h3>
<p>Epoched data are data associated with a specific epoch that are set in advance. The data relevant to the PoS system in the ledger's state are epoched. Each data can be uniquely identified. These are:</p>
<ul>
<li><a href="explore/design/pos.html#system-parameters">System parameters</a>. A single value for each epoch.</li>
<li><a href="explore/design/pos.html#active-validator-set">Active validator set</a>. A single value for each epoch.</li>
<li>Total voting power. A sum of all active and inactive validators' voting power. A single value for each epoch.</li>
<li><a href="explore/design/pos.html#validator">Validators' consensus key, state and total bonded tokens</a>. Identified by the validator's address.</li>
<li><a href="explore/design/pos.html#bonds">Bonds</a> are created by self-bonding and delegations. They are identified by the pair of source address and the validator's address.</li>
</ul>
<p>Changes to the epoched data do not take effect immediately. Instead, changes in epoch <code>n</code> are queued to take effect in the epoch <code>n + pipeline_length</code> for most cases and <code>n + unboding_length</code> for <a href="explore/design/pos.html#unbond">unbonding</a> actions. Should the same validator's data or same bonds (i.e. with the same identity) be updated more than once in the same epoch, the later update overrides the previously queued-up update. For bonds, the token amounts are added up. Once the epoch <code>n</code> has ended, the queued-up updates for epoch <code>n + pipeline_length</code> are final and the values become immutable.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<ul>
<li><a href="explore/design/pos.html#validator">Validator</a>: An account with a public consensus key, which may participate in producing blocks and governance activities. A validator may not also be a delegator.</li>
<li><a href="explore/design/pos.html#delegator">Delegator</a>: An account that delegates some tokens to a validator. A delegator may not also be a validator.</li>
</ul>
<p>Additionally, any account may submit evidence for <a href="explore/design/pos.html#slashing">a slashable misbehaviour</a>.</p>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>A validator must have a public consensus key. Additionally, it may also specify optional metadata fields (TBA).</p>
<p>A validator may be in one of the following states:</p>
<ul>
<li><em>inactive</em>:
A validator is not being considered for block creation and cannot receive any new delegations.</li>
<li><em>pending</em>:
A validator has requested to become a <em>candidate</em>.</li>
<li><em>candidate</em>:
A validator is considered for block creation and can receive delegations.</li>
</ul>
<p>For each validator (in any state), the system also tracks total bonded tokens as a sum of the tokens in their self-bonds and delegated bonds, less any unbonded tokens. The total bonded tokens determine their voting voting power by multiplication by the <code>votes_per_token</code> <a href="explore/design/pos.html#system-parameters">parameter</a>. The voting power is used for validator selection for block creation and is used in governance related activities.</p>
<h4 id="validator-actions"><a class="header" href="#validator-actions">Validator actions</a></h4>
<ul>
<li><em>become validator</em>:
Any account that is not a validator already and that doesn't have any delegations may request to become a validator. It is required to provide a public consensus key and staking reward address. For the action applied in epoch <code>n</code>, the validator's state will be immediately set to <em>pending</em>, it will be set to <em>candidate</em> for epoch <code>n + pipeline_length</code> and the consensus key is set for epoch <code>n + pipeline_length</code>.</li>
<li><em>deactivate</em>:
Only a <em>pending</em> or <em>candidate</em> validator account may <em>deactivate</em>. For this action applied in epoch <code>n</code>, the validator's account is set to become <em>inactive</em> in the epoch <code>n + pipeline_length</code>.</li>
<li><em>reactivate</em>:
Only an <em>inactive</em> validator may <em>reactivate</em>. Similarly to <em>become validator</em> action, for this action applied in epoch <code>n</code>, the validator's state will be immediately set to <em>pending</em> and it will be set to <em>candidate</em> for epoch <code>n + pipeline_length</code>.</li>
<li><em>self-bond</em>:
A validator may lock-up tokens into a <a href="explore/design/pos.html#bonds">bond</a> only for its own validator's address.</li>
<li><em>unbond</em>:
Any self-bonded tokens may be partially or fully <a href="explore/design/pos.html#unbond">unbonded</a>.</li>
<li><em>withdraw unbonds</em>:
Unbonded tokens may be withdrawn in or after the <a href="explore/design/pos.html#unbond">unbond's epoch</a>.</li>
<li><em>change consensus key</em>:
Set the new consensus key. When applied in epoch <code>n</code>, the key is set for epoch <code>n + pipeline_length</code>.</li>
</ul>
<h4 id="active-validator-set"><a class="header" href="#active-validator-set">Active validator set</a></h4>
<p>From all the <em>candidate</em> validators, in each epoch the ones with the most voting power limited up to the <code>max_active_validators</code> <a href="explore/design/pos.html#system-parameters">parameter</a> are selected for the active validator set. The active validator set selected in epoch <code>n</code> is set for epoch <code>n + pipeline_length</code>.</p>
<h3 id="delegator"><a class="header" href="#delegator">Delegator</a></h3>
<p>A delegator may have any number of delegations to any number of validators. Delegations are stored in <a href="explore/design/pos.html#bonds">bonds</a>.</p>
<h4 id="delegator-actions"><a class="header" href="#delegator-actions">Delegator actions</a></h4>
<ul>
<li><em>delegate</em>:
An account which is not a validator may delegate tokens to any number of validators. This will lock-up tokens into a <a href="explore/design/pos.html#bonds">bond</a>.</li>
<li><em>undelegate</em>:
Any delegated tokens may be partially or fully <a href="explore/design/pos.html#unbond">unbonded</a>.</li>
<li><em>withdraw unbonds</em>:
Unbonded tokens may be withdrawn in or after the <a href="explore/design/pos.html#unbond">unbond's epoch</a>.</li>
</ul>
<h2 id="bonds"><a class="header" href="#bonds">Bonds</a></h2>
<p>A bond locks-up tokens from validators' self-bonding and delegators' delegations. For self-bonding, the source address is equal to the validator's address. Only validators can self-bond. For a bond created from a delegation, the bond's source is the delegator's account.</p>
<p>For each epoch, bonds are uniquely identified by the pair of source and validator's addresses. A bond created in epoch <code>n</code> is written into epoch <code>n + pipeline_length</code>. If there already is a bond in the epoch <code>n + pipeline_length</code> for this pair of source and validator's addresses, its tokens are incremented by the newly bonded amount.</p>
<p>Any bonds created in epoch <code>n</code> increment the bond's validator's total bonded tokens by the bond's token amount and update the voting power for epoch <code>n + pipeline_length</code>.</p>
<p>The tokens put into a bond are immediately deducted from the source account.</p>
<h3 id="unbond"><a class="header" href="#unbond">Unbond</a></h3>
<p>An unbonding action (validator <em>unbond</em> or delegator <em>undelegate</em>) requested by the bond's source account in epoch <code>n</code> creates an &quot;unbond&quot; with epoch set to <code>n + unbounding_length</code>. We also store the epoch of the bond(s) from which the unbond is created in order to determine if the unbond should be slashed if a fault occurred within the range of bond epoch (inclusive) and unbond epoch (exclusive).</p>
<p>Any unbonds created in epoch <code>n</code> decrements the bond's validator's total bonded tokens by the bond's token amount and update the voting power for epoch <code>n + unbonding_length</code>.</p>
<p>An &quot;unbond&quot; with epoch set to <code>n</code> may be withdrawn by the bond's source address in or any time after the epoch <code>n</code>. Once withdrawn, the unbond is deleted and the tokens are credited to the source account.</p>
<h3 id="staking-rewards"><a class="header" href="#staking-rewards">Staking rewards</a></h3>
<p>To a validator who proposed a block, the system rewards tokens based on the <code>block_proposer_reward</code> <a href="explore/design/pos.html#system-parameters">system parameter</a> and each validator that voted on a block receives <code>block_vote_reward</code>.</p>
<h3 id="slashing-1"><a class="header" href="#slashing-1">Slashing</a></h3>
<p>Instead of absolute values, validators' total bonded token amounts and bonds' and unbonds' token amounts are stored as their deltas (i.e. the change of quantity from a previous epoch) to allow distinguishing changes for different epoch, which is essential for determining whether tokens should be slashed. However, because slashes for a fault that occurred in epoch <code>n</code> may only be applied before the beginning of epoch <code>n + unbonding_length</code>, in epoch <code>m</code> we can sum all the deltas of total bonded token amounts and bonds and unbond with the same source and validator for epoch equal or less than <code>m - unboding_length</code> into a single total bonded token amount, single bond and single unbond record. This is to keep the total number of total bonded token amounts for a unique validator and bonds and unbonds for a unique pair of source and validator bound to a maximum number (equal to <code>unbonding_length</code>).</p>
<p>To disincentivize validators misbehaviour in the PoS system a validator may be slashed for any fault that it has done. An evidence of misbehaviour may be submitted by any account for a fault that occurred in epoch <code>n</code> anytime before the beginning of epoch <code>n + unbonding_length</code>.</p>
<p>A valid evidence reduces the validator's total bonded token amount by the slash rate in and before the epoch in which the fault occurred. The validator's voting power must also be adjusted to the slashed total bonded token amount. Additionally, a slash is stored with the misbehaving validator's address and the relevant epoch in which the fault occurred. When an unbond is being withdrawn, we first look-up if any slash occurred within the range of epochs in which these were active and if so, reduce its token amount by the slash rate. Note that bonds and unbonds amounts are not slashed until their tokens are withdrawn.</p>
<p>The invariant is that the sum of amounts that may be withdrawn from a misbehaving validator must always add up to the total bonded token amount.</p>
<h2 id="system-parameters"><a class="header" href="#system-parameters">System parameters</a></h2>
<p>The default values that are relative to epoch duration assume that an epoch last about 24 hours.</p>
<ul>
<li><code>max_validator_slots</code>: Maximum active validators, default <code>128</code></li>
<li><code>pipeline_len</code>: Pipeline length in number of epochs, default <code>2</code></li>
<li><code>unboding_len</code>: Unbonding duration in number of epochs, default <code>6</code></li>
<li><code>votes_per_token</code>: Used in validators' voting power calculation, default 100‚Ä± (1 voting power unit per 1000 tokens)</li>
<li><code>block_proposer_reward</code>: Amount of tokens rewarded to a validator for proposing a block</li>
<li><code>block_vote_reward</code>: Amount of tokens rewarded to each validator that voted on a block proposal</li>
<li><code>duplicate_vote_slash_rate</code>: Portion of validator's stake that should be slashed on a duplicate vote</li>
<li><code>light_client_attack_slash_rate</code>: Portion of validator's stake that should be slashed on a light client attack</li>
</ul>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>The <a href="explore/design/pos.html#system-parameters">system parameters</a> are written into the storage to allow for their changes. Additionally, each validator may record a new parameters value under their sub-key that they wish to change to, which would override the systems parameters when more than 2/3 voting power are in agreement on all the parameters values.</p>
<p>The validators' data are keyed by the their addresses, conceptually:</p>
<pre><code class="language-rust ignore">type Validators = HashMap&lt;Address, Validator&gt;;
</code></pre>
<p>Epoched data are stored in the following structure:</p>
<pre><code class="language-rust ignore">struct Epoched&lt;Data&gt; {
  /// The epoch in which this data was last updated
  last_update: Epoch,
  /// Dynamically sized vector in which the head is the data for epoch in which 
  /// the `last_update` was performed and every consecutive array element is the
  /// successor epoch of the predecessor array element. For system parameters, 
  /// validator's consensus key and state, `LENGTH = pipeline_length + 1`. 
  /// For all others, `LENGTH = unbonding_length + 1`.
  data: Vec&lt;Option&lt;Data&gt;&gt;
}
</code></pre>
<p>Note that not all epochs will have data set, only the ones in which some changes occurred.</p>
<p>To try to look-up a value for <code>Epoched</code> data with independent values in each epoch (such as the active validator set) in the current epoch <code>n</code>:</p>
<ol>
<li>let <code>index = min(n - last_update, pipeline_length)</code></li>
<li>read the <code>data</code> field at <code>index</code>:
<ol>
<li>if there's a value at <code>index</code> return it</li>
<li>else if <code>index == 0</code>, return <code>None</code></li>
<li>else decrement <code>index</code> and repeat this sub-step from 1.</li>
</ol>
</li>
</ol>
<p>To look-up a value for <code>Epoched</code> data with delta values in the current epoch <code>n</code>:</p>
<ol>
<li>let <code>end = min(n - last_update, pipeline_length) + 1</code></li>
<li>sum all the values that are not <code>None</code> in the <code>0 .. end</code> range bounded inclusively below and exclusively above</li>
</ol>
<p>To update a value in <code>Epoched</code> data with independent values in epoch <code>n</code> with value <code>new</code> for epoch <code>m</code>:</p>
<ol>
<li>let <code>shift = min(n - last_update, pipeline_length)</code></li>
<li>if <code>shift == 0</code>:
<ol>
<li><code>data[m - n] = new</code></li>
</ol>
</li>
<li>else:
<ol>
<li>for <code>i in 0 .. shift</code> range bounded inclusively below and exclusively above, set <code>data[i] = None</code></li>
<li>rotate <code>data</code> left by <code>shift</code></li>
<li>set <code>data[m - n] = new</code></li>
<li>set <code>last_update</code> to the current epoch</li>
</ol>
</li>
</ol>
<p>To update a value in <code>Epoched</code> data with delta values in epoch <code>n</code> with value <code>delta</code> for epoch <code>m</code>:</p>
<ol>
<li>let <code>shift = min(n - last_update, pipeline_length)</code></li>
<li>if <code>shift == 0</code>:
<ol>
<li>set <code>data[m - n] = data[m - n].map_or_else(delta, |last_delta| last_delta + delta)</code> (add the <code>delta</code> to the previous value, if any, otherwise use the <code>delta</code> as the value)</li>
</ol>
</li>
<li>else:
<ol>
<li>let <code>sum</code> to be equal to the sum of all delta values in the <code>i in 0 .. shift</code> range bounded inclusively below and exclusively above and set <code>data[i] = None</code></li>
<li>rotate <code>data</code> left by <code>shift</code></li>
<li>set <code>data[0] = data[0].map_or_else(sum, |last_delta| last_delta + sum)</code></li>
<li>set <code>data[m - n] = delta</code></li>
<li>set <code>last_update</code> to the current epoch</li>
</ol>
</li>
</ol>
<p>The invariants for updates in both cases are that <code>m - n &gt;= 0</code> and <code>m - n &lt;= pipeline_length</code>.</p>
<p>For the active validator set, we store all the active and inactive validators separately with their respective voting power:</p>
<pre><code class="language-rust ignore">type VotingPower = u64;

/// Validator's address with its voting power.
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct WeightedValidator {
  /// The `voting_power` field must be on top, because lexicographic ordering is
  /// based on the top-to-bottom declaration order and in the `ValidatorSet`
  /// the `WeighedValidator`s these need to be sorted by the `voting_power`.
  voting_power: VotingPower,
  address: Address,
}

struct ValidatorSet {
  /// Active validator set with maximum size equal to `max_active_validators`
  active: BTreeSet&lt;WeightedValidator&gt;,
  /// All the other validators that are not active
  inactive: BTreeSet&lt;WeightedValidator&gt;,
}

type ValidatorSets = Epoched&lt;ValidatorSet&gt;;

/// The sum of all active and inactive validators' voting power
type TotalVotingPower = Epoched&lt;VotingPower&gt;;
</code></pre>
<p>When any validator's voting power changes, we attempt to perform the following update on the <code>ActiveValidatorSet</code>:</p>
<ol>
<li>let <code>validator</code> be the validator's address, <code>power_before</code> and <code>power_after</code> be the voting power before and after the change, respectively</li>
<li>let <code>power_delta = power_after - power_before</code></li>
<li>let <code>min_active = active.first()</code> (active validator with lowest voting power)</li>
<li>let <code>max_inactive = inactive.last()</code> (inactive validator with greatest voting power)</li>
<li>find whether the validator is active, let <code>is_active = power_before &gt;= max_inactive.voting_power</code>
<ol>
<li>if <code>is_active</code>:
<ol>
<li>if <code>power_delta &gt; 0 &amp;&amp; power_after &gt; max_inactive.voting_power</code>, update the validator in <code>active</code> set with <code>voting_power = power_after</code></li>
<li>else, remove the validator from <code>active</code>, insert it into <code>inactive</code> and remove <code>max_inactive.address</code> from <code>inactive</code> and insert it into <code>active</code></li>
</ol>
</li>
<li>else (<code>!is_active</code>):
<ol>
<li>if <code>power_delta &lt; 0 &amp;&amp; power_after &lt; min_active.voting_power</code>, update the validator in <code>inactive</code> set with <code>voting_power = power_after</code></li>
<li>else, remove the validator from <code>inactive</code>, insert it into <code>active</code> and remove <code>min_active.address</code> from <code>active</code> and insert it into <code>inactive</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Within each validator's address space, we store public consensus key, state, total bonded token amount and voting power calculated from the total bonded token amount (even though the voting power is stored in the <code>ValidatorSet</code>, we also need to have the <code>voting_power</code> here because we cannot look it up in the <code>ValidatorSet</code> without iterating the whole set):</p>
<pre><code class="language-rust ignore">struct Validator {
  consensus_key: Epoched&lt;PublicKey&gt;,
  state: Epoched&lt;ValidatorState&gt;,
  total_deltas: Epoched&lt;token::Amount&gt;,
  voting_power: Epoched&lt;VotingPower&gt;,
}

enum ValidatorState {
  Inactive,
  Pending,
  Candidate,
}
</code></pre>
<p>The bonds and unbonds are keyed by their identifier:</p>
<pre><code class="language-rust ignore">type Bonds = HashMap&lt;BondId, Epoched&lt;Bond&gt;&gt;;
type Unbonds = HashMap&lt;BondId, Epoched&lt;Unbond&gt;&gt;;

struct BondId {
  validator: Address,
  /// The delegator adddress for delegations, or the same as the `validator`
  /// address for self-bonds.
  source: Address,
}

struct Bond {
  /// A key is a the epoch set for the bond. This is used in unbonding, where
  // it's needed for slash epoch range check.
  deltas: HashMap&lt;Epoch, token::Amount&gt;,
}

struct Unbond {
  /// A key is a pair of the epoch of the bond from which a unbond was created
  /// the epoch of unboding. This is needed for slash epoch range check.
  deltas: HashMap&lt;(Epoch, Epoch), token::Amount&gt;
}
</code></pre>
<p>For slashes, we store the epoch and block height at which the fault occurred, slash rate and the slash type:</p>
<pre><code class="language-rust ignore">struct Slash {
  epoch: Epoch,
  block_height: u64,
  /// slash token amount ‚Ä± (per ten thousand)
  rate: u8,
  r#type: SlashType,
}
</code></pre>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>An initial validator set with self-bonded token amounts must be given on system initialization.</p>
<p>This set is used to pre-compute epochs in the genesis block from epoch <code>0</code> to epoch <code>pipeline_length - 1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototypes"><a class="header" href="#prototypes">Prototypes</a></h1>
<p>A prototype should start with a description of its goals. These can include, but are not limited to a proof of concept of novel ideas or alternative approaches, comparing different libraries and gathering feedback.</p>
<p>To get started on a prototype, please:</p>
<ul>
<li>open an issue on this repository</li>
<li>add a sub-page to this section with a link to the issue</li>
</ul>
<p>The page outlines the goals and possibly contains any notes that are not suitable to be added to the prototype source itself, while the issue should track the sub-task, their progress, and assignees.</p>
<p>The code quality is of lesser importance in prototypes. To put the main focus on the prototype's goals, we don't need to worry much about testing, linting and doc strings.</p>
<h2 id="advancing-a-successful-prototype"><a class="header" href="#advancing-a-successful-prototype">Advancing a successful prototype</a></h2>
<p>Once the goals of the prototype have been completed, we can assess if we'd like to advance the prototype to a development version. </p>
<p>In order to advance a prototype, in general we'll want to:</p>
<ul>
<li>review &amp; clean-up the code for lint, format and best practices</li>
<li>enable common Rust lints</li>
<li>review any new dependencies</li>
<li>add docs for any public interface (internally public too)</li>
<li>add automated tests</li>
<li>if the prototype has diverged from the original design, update these pages </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-ledger-prototype"><a class="header" href="#base-ledger-prototype">Base ledger prototype</a></h1>
<h2 id="version-3"><a class="header" href="#version-3">Version 3</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/125">https://github.com/anoma/anoma/issues/125</a></p>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>various shell and protocol fixes, improvements and additions</li>
<li>add more crypto support</li>
<li>WASM improvements</li>
<li>implement new validity predicates</li>
<li>storage improvements</li>
<li>gas &amp; fees</li>
<li>fixes for issues found in the Feigenbaum testnet</li>
<li>IBC integration</li>
<li>Ferveo/ABCI++ integration</li>
<li>PoS improvements and new features
<ul>
<li>testing (unit + integration + e2e)</li>
<li>storage values refactoring</li>
<li>use checked arithmetics</li>
<li>validator VP</li>
<li>staking rewards</li>
<li>staking reward VP</li>
<li>re-delegation</li>
<li>validator
<ul>
<li>deactivation/reactivation</li>
<li>change consensus key</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="version-2"><a class="header" href="#version-2">Version 2</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/62">https://github.com/anoma/anoma/issues/62</a></p>
<h3 id="goals-1"><a class="header" href="#goals-1">Goals</a></h3>
<ul>
<li>storage
<ul>
<li>build key schema for access</li>
<li>implement dynamic account sub-spaces</li>
</ul>
</li>
<li>implement more complete support for WASM transactions and validity predicates
<ul>
<li>transactions can read/write all storage</li>
<li>validity predicates receive the set of changes (changed keys or complete write log) and can read their pre/post state</li>
</ul>
</li>
<li>add basic transaction gas metering</li>
<li>various other improvements</li>
</ul>
<h2 id="version-1"><a class="header" href="#version-1">Version 1</a></h2>
<p>tracking issue <a href="https://github.com/heliaxdev/rd-pm/issues/5">https://github.com/heliaxdev/rd-pm/issues/5</a></p>
<h3 id="goals-2"><a class="header" href="#goals-2">Goals</a></h3>
<ul>
<li>get some hands-on experience with Rust and Tendermint</li>
<li>initial usable node + client (+ validator?) setup</li>
<li>provide a base layer for other prototypes that need to build on top of a ledger</li>
</ul>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>The main components are built in a single Cargo project with <a href="explore/prototypes/base-ledger.html#shared">shared library code</a> and multiple binaries:</p>
<ul>
<li><code>anoma</code> - main executable with commands for both the node and the client (<code>anoma node</code> and <code>anoma client</code>)</li>
<li><code>anoman</code> - the <a href="explore/prototypes/base-ledger.html#node">node</a></li>
<li><code>anomac</code> - the <a href="explore/prototypes/base-ledger.html#client">client</a></li>
</ul>
<h4 id="node"><a class="header" href="#node">Node</a></h4>
<p>The node is built into <code>anoman</code>.</p>
<h5 id="shell"><a class="header" href="#shell">Shell</a></h5>
<p>The shell is what currently pulls together all the other components in the node.</p>
<p>When it's ran:</p>
<ul>
<li>establish a channel (e.g.<code>mpsc::channel</code> - Multi-producer, single-consumer FIFO queue) for communication from tendermint to the shell</li>
<li>launch tendermint node in another thread with the channel sender
<ul>
<li>send tendermint ABCI requests via the channel together with a new channel sender to receive a response</li>
</ul>
</li>
<li>run shell loop with the channel receiver, which handles ABIC requests:
<ul>
<li><a href="explore/prototypes/../design/ledger/tx.html">transaction execution</a> which includes <a href="explore/prototypes/../design/ledger/wasm-vm.html">wasm VM calls</a></li>
</ul>
</li>
</ul>
<h6 id="tendermint"><a class="header" href="#tendermint">Tendermint</a></h6>
<p>This module handles initializing and running <code>tendermint</code> and forwards messages for the ABCI requests via its channel sender.</p>
<h5 id="storage-2"><a class="header" href="#storage-2">Storage</a></h5>
<p>Key-value storage. More details are specified on <a href="explore/prototypes/../design/ledger/storage.html">Storage page</a>.</p>
<h5 id="cli"><a class="header" href="#cli">CLI</a></h5>
<ul>
<li><code>anoma run</code> to start the node (will initialize (if needed) and launch tendermint under the hood)</li>
<li><code>anoma reset</code> to delete all the node's state from DB and tendermint's state</li>
</ul>
<h4 id="client"><a class="header" href="#client">Client</a></h4>
<p>Allows to submit a transaction with an attached wasm code to the node with:</p>
<p><code>anoma tx --code tx.wasm</code></p>
<p>It presents back the received response on stdout. Currently, it waits for both the mempool validation and application in a block.</p>
<h4 id="shared"><a class="header" href="#shared">Shared</a></h4>
<h5 id="config"><a class="header" href="#config">Config</a></h5>
<p>Configuration settings:</p>
<ul>
<li>home directory (db storage and tendermint config and data)</li>
</ul>
<h5 id="genesis"><a class="header" href="#genesis">Genesis</a></h5>
<p>The genesis parameters, such as the initial validator set, are used to initialize a chain's genesis block.</p>
<h5 id="rpc-types"><a class="header" href="#rpc-types">RPC types</a></h5>
<p>The types for data that can be submitted to the node via the client's RPC commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-system-prototype"><a class="header" href="#intent-gossip-system-prototype">Intent Gossip system prototype</a></h1>
<h2 id="version-2-1"><a class="header" href="#version-2-1">Version 2</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/620">https://github.com/anoma/anoma/issues/620</a></p>
<ul>
<li>Separate matchmakers from intent gossiper nodes</li>
<li>Various fixes and improvements</li>
<li>fixes for issues found in the Feigenbaum testnet</li>
<li>Persistent storage</li>
<li>Intent gossip and matching of complex txs</li>
<li>multi-party trades (e.g. 10)</li>
<li>multi-asset trades (FT, NFT)</li>
<li>NFT swaps</li>
<li>Benchmarking base load for the entire network</li>
<li>Incentives</li>
<li>Docs</li>
</ul>
<h2 id="version-1-1"><a class="header" href="#version-1-1">Version 1</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/35">https://github.com/anoma/anoma/issues/35</a></p>
<h3 id="goals-3"><a class="header" href="#goals-3">Goals</a></h3>
<ul>
<li>learning rust</li>
<li>usable node + client setup :
<ul>
<li>intent</li>
<li>incentive function</li>
<li>mempool and white list</li>
</ul>
</li>
<li>basic matchmaker</li>
</ul>
<h3 id="components-1"><a class="header" href="#components-1">components</a></h3>
<p>The intent gossip is build conjointly to the ledger and share the same binary.</p>
<h4 id="node-1"><a class="header" href="#node-1">Node</a></h4>
<p>The node is built into <code>anoman</code>, it runs all the necesarry part, rpc server,
libp2p, intent gossip app.</p>
<h5 id="intent-gossip-application"><a class="header" href="#intent-gossip-application">Intent gossip application</a></h5>
<p>The intent gossip application</p>
<h6 id="mempool"><a class="header" href="#mempool">Mempool</a></h6>
<h6 id="filter"><a class="header" href="#filter">Filter</a></h6>
<h5 id="network-behaviour"><a class="header" href="#network-behaviour">Network behaviour</a></h5>
<p>The network behaviour is the part that react on network event. It creates a
channel (e.g. <code>tokio::mpsc::channel</code>) with the intent gossip to communicate all
intent it receive.</p>
<h5 id="rpc-server"><a class="header" href="#rpc-server">Rpc server</a></h5>
<p>If the rpc command line option is set it creates a tonic server that receive
command from a client and send theses through a channel
(e.g. <code>tokio::mpsc::channel</code>) to the the intent gossip.</p>
<h4 id="client-1"><a class="header" href="#client-1">Client</a></h4>
<p>Allow to submit a intent :
<code>anoma gossip --data &quot;data&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries--tools"><a class="header" href="#libraries--tools">Libraries &amp; Tools</a></h1>
<p>The aim of this section is to document possible choices for certain components. For components where many choices are available, such as a database backend, an overview of the important differences of the considered libraries may be given.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">network</a></h1>
<h2 id="libp2p--peer-to-peer-network"><a class="header" href="#libp2p--peer-to-peer-network">Libp2p : Peer To Peer network</a></h2>
<p><a href="https://github.com/libp2p/rust-libp2p">https://github.com/libp2p/rust-libp2p</a></p>
<p>peer-to-peer framework that takes care of the transport/identity and message
encryption for us.</p>
<h2 id="tonic--clientserver-with-protobuf-prost"><a class="header" href="#tonic--clientserver-with-protobuf-prost">tonic : Client/Server with protobuf (prost)</a></h2>
<p><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a></p>
<p>Generates a client/server from protobuf file. This can be used for a rpc server.</p>
<h1 id="network-behaviour-1"><a class="header" href="#network-behaviour-1">network behaviour</a></h1>
<h2 id="gossipsub"><a class="header" href="#gossipsub">Gossipsub</a></h2>
<p><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">https://github.com/libp2p/specs/tree/master/pubsub/gossipsub</a></p>
<p>Publish/Subscribe protocol, improvement over floodsub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h1>
<p>Important factors:</p>
<ul>
<li>UX</li>
<li>ease of use</li>
<li>cross-platform</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>clap</li>
</ul>
<h2 id="clap"><a class="header" href="#clap">Clap</a></h2>
<p><a href="https://github.com/clap-rs/clap">https://github.com/clap-rs/clap</a></p>
<p>Probably the most widely used CLI library in Rust.</p>
<p>With version 2.x, we'd probably want to use it with <a href="https://github.com/TeXitoi/structopt">Structops</a> for deriving.</p>
<p>But we can probably use 3.0, which is not yet stable, but is pretty close <a href="https://github.com/clap-rs/clap/issues/1037">https://github.com/clap-rs/clap/issues/1037</a>. This version comes with deriving attributes and also other new ways to build CLI commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>Important factors:</p>
<ul>
<li>persistent key/value storage</li>
<li>reliability and efficiency (runtime performance and disk usage)</li>
<li>thread safety</li>
<li>ease of use</li>
</ul>
<p>The considered DBs:</p>
<ul>
<li>LMDB</li>
<li>LevelDB</li>
<li>RocksDB</li>
<li>sled - Rust native</li>
</ul>
<p>To watch:</p>
<ul>
<li><a href="https://docs.rs/sanakirja">sanakirja</a> - too new to be considered for now, but has some <a href="https://pijul.org/posts/2021-02-06-rethinking-sanakirja/">promising initial results</a> - TLDR. it can <em>fork tables</em> efficiently, it beats LMDB in benchmarks and usability</li>
</ul>
<p>The current preference is for RocksDB as it's tried and tested. Eventually, we might want to benchmark against other backends for our specific use case.</p>
<h2 id="lmdb"><a class="header" href="#lmdb">LMDB</a></h2>
<p><a href="https://symas.com/lmdb/">https://symas.com/lmdb/</a></p>
<p>A compact and efficient, persistent in-memory (i.e. mmap-based) B+trees database. Reportedly has a great read performance, but not as good at writing.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/mozilla/rkv">https://github.com/mozilla/rkv</a></li>
<li><a href="https://github.com/AltSysrq/lmdb-zero">https://github.com/AltSysrq/lmdb-zero</a></li>
<li><a href="https://github.com/vhbit/lmdb-rs">https://github.com/vhbit/lmdb-rs</a> - some <a href="https://github.com/vhbit/lmdb-rs/issues/32#issuecomment-310906601">comparison notes</a> with danburkert/lmdb-rs</li>
<li><a href="https://github.com/danburkert/lmdb-rs">https://github.com/danburkert/lmdb-rs</a></li>
</ul>
<h2 id="leveldb"><a class="header" href="#leveldb">LevelDB</a></h2>
<p>Log Structured Merge Tree db. Uses one global lock. Better write performance than LMDB and lower DB size.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/skade/leveldb">https://github.com/skade/leveldb</a></li>
</ul>
<h2 id="rocksdb-1"><a class="header" href="#rocksdb-1">RocksDB</a></h2>
<p>A fork of LevelDB with different optimizations (supposedly for RAM and flash storage).</p>
<p>Used in <a href="https://github.com/simplestaking/tezedge">https://github.com/simplestaking/tezedge</a> and <a href="https://github.com/near/nearcore">https://github.com/near/nearcore</a>.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/rust-rocksdb/rust-rocksdb">https://github.com/rust-rocksdb/rust-rocksdb</a></li>
</ul>
<h2 id="sled"><a class="header" href="#sled">Sled</a></h2>
<p>Repo: <a href="https://github.com/spacejam/sled">https://github.com/spacejam/sled</a>
Homepage: <a href="https://sled.rs/">https://sled.rs/</a></p>
<p>Modern, zero-copy reads, lock-free and many more features.</p>
<hr />
<h1 id="merkle-tree-data-structure"><a class="header" href="#merkle-tree-data-structure">Merkle tree data structure</a></h1>
<p>Some popular choices for merkle tree in the industry are AVL(+) tree, Patricia Trie and Sparse Merkle Tree, each with different trade-offs.</p>
<p>AVL(+) tree is used in e.g. <a href="https://github.com/cosmos/iavl">Cosmos</a>. The advantage of this structure is that key don't need to be hashed prior to insertion/look-up.</p>
<p>Patricia trie used in e.g. <a href="https://eth.wiki/en/fundamentals/patricia-tree">Ethereum</a> and <a href="https://www.dailambda.jp/blog/2020-05-11-plebeia/">Plebeia for Tezos</a> are designed to be more space efficient.</p>
<p>Sparse Merle tree as described in <a href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751">Optimizing sparse Merkle trees</a> used in e.g. <a href="https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers/2006">Plasma Cash</a> are somewhat similar to Patricia trees, but perhaps conceptually simpler.</p>
<ul>
<li>Compact Sparse Merkle Trees <a href="https://eprint.iacr.org/2018/955.pdf">https://eprint.iacr.org/2018/955.pdf</a></li>
<li>Efficient Sparse Merkle Trees (caching) <a href="https://eprint.iacr.org/2016/683.pdf">https://eprint.iacr.org/2016/683.pdf</a></li>
</ul>
<p>Considered libraries:</p>
<ul>
<li>merk</li>
<li>sparse-merkle-tree</li>
<li>patricia_tree</li>
</ul>
<h2 id="merk"><a class="header" href="#merk">merk</a></h2>
<p><a href="https://github.com/nomic-io/merk">https://github.com/nomic-io/merk</a></p>
<p>Using AVL tree built on top of RocksDB. It makes it easy to setup Merkle tree storage, but:</p>
<ul>
<li>is not yet fully implemented as described (e.g. <a href="https://github.com/nomic-io/merk/issues/26">concurrent ops</a>)</li>
<li>benchmarks seem to differ from results in README</li>
<li>doesn't have past states of the tree, instead <a href="https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md#database-representation">relies on RocksDB snapshot/checkpoint features</a>, which means that it's <a href="https://github.com/nomic-io/merk/issues/11">strongly coupled</a></li>
<li>uses a custom <a href="https://github.com/nomic-io/ed">encoding lib</a> which is zero-copy, but big-endian everywhere</li>
<li>there are a <code>unsafe</code> usages that are not well described/justified</li>
<li>uses some experimental dep such as <a href="https://github.com/rust-lang-nursery/failure">https://github.com/rust-lang-nursery/failure</a> (now deprecated)</li>
</ul>
<h2 id="sparse-merkle-tree"><a class="header" href="#sparse-merkle-tree">sparse-merkle-tree</a></h2>
<p><a href="https://github.com/jjyr/sparse-merkle-tree">https://github.com/jjyr/sparse-merkle-tree</a></p>
<p>A nice abstraction, albeit not yet declared stable. It allows to plug-in a custom hasher function (which is important for <a href="https://github.com/heliaxdev/rd-pm/issues/11">circuit friendliness</a>) and storage backend. Has minimal dependencies and support Rust <code>no_std</code>.</p>
<h2 id="patricia_tree"><a class="header" href="#patricia_tree">patricia_tree</a></h2>
<p><a href="https://github.com/sile/patricia_tree">https://github.com/sile/patricia_tree</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Options to consider:</p>
<ul>
<li>env_logger</li>
<li>slog</li>
<li>tracing</li>
</ul>
<p>The current preference is for tracing in combination with tracing-subscriber (to log collected events and traces), because we have some async and parallelized code. In future, we should also add tracing-appender for rolling file logging.</p>
<h2 id="env_logger"><a class="header" href="#env_logger">Env_logger</a></h2>
<p><a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></p>
<p>A simple logger used by many Rust tools, configurable by env vars. Usually combined with <a href="https://github.com/seanmonstar/pretty-env-logger">pretty-env-logger</a>.</p>
<h2 id="slog"><a class="header" href="#slog">Slog</a></h2>
<p><a href="https://github.com/slog-rs/slog">https://github.com/slog-rs/slog</a></p>
<p>Composable, structured logger. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/slog-rs/envlogger">https://github.com/slog-rs/envlogger</a> port of env_logger as a slog-rs drain </li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p><a href="https://github.com/tokio-rs/tracing">https://github.com/tokio-rs/tracing</a></p>
<p>Tracing &amp; logging better suited for concurrent processes and async code. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-appender">https://github.com/tokio-rs/tracing/tree/master/tracing-appender</a> non-blocking log appender</li>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-log">https://github.com/tokio-rs/tracing/tree/master/tracing-log</a> allows to forward library log statements and to use this in combination with env_logger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packaging"><a class="header" href="#packaging">Packaging</a></h1>
<p>For Rust native code, cargo works great, but we'll need to package stuff from outside of Rust too (e.g. tendermint). The goal is to have a repo that can always build as is (reproducible) and easily portable (having a single command to install all the deps).</p>
<p>Options to consider:</p>
<ul>
<li><a href="https://github.com/NixOS/nixpkgs">nix packages</a></li>
<li><a href="https://guix.gnu.org/manual/en/html_node/Package-Management.html">guix</a></li>
<li>docker</li>
</ul>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>For Rust dependencies, it would be nice to integrate and use:</p>
<ul>
<li><a href="https://github.com/crev-dev/cargo-crev">https://github.com/crev-dev/cargo-crev</a></li>
<li><a href="https://github.com/rust-secure-code/cargo-geiger">https://github.com/rust-secure-code/cargo-geiger</a></li>
<li><a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></li>
</ul>
<h2 id="nix"><a class="header" href="#nix">Nix</a></h2>
<p>Purely functional package management for reproducible environment. The big drawback is its language.</p>
<h2 id="guix"><a class="header" href="#guix">Guix</a></h2>
<p>Similar package management capability to nix, but using scheme language.</p>
<h2 id="docker-1"><a class="header" href="#docker-1">Docker</a></h2>
<p>Not ideal for development, but we'll probably want to provide docker images for users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-libraries"><a class="header" href="#serialization-libraries">Serialization libraries</a></h1>
<p>Because the serialization for the RPC and storage have different priorities, it might be beneficial to use a different library for each.</p>
<h2 id="rpc"><a class="header" href="#rpc">RPC</a></h2>
<p>Important factors:</p>
<ul>
<li>security, e.g.:
<ul>
<li>handling of malicious input (buffers should not be trusted)</li>
<li>secure RPC, if included (e.g. DoS or memory exhaustion vulnerabilities)</li>
</ul>
</li>
<li>native and cross-language adoption for easy interop</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>protobuf</li>
<li>cap'n'proto</li>
<li>flatbuffers</li>
<li>serde</li>
</ul>
<p>The current preference is for protobuf using the prost library.</p>
<h2 id="storage-3"><a class="header" href="#storage-3">Storage</a></h2>
<p>Important factors:</p>
<ul>
<li>consistent binary representation for hashing</li>
<li>preserve ordering (for DB keys)</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>bincode</li>
<li>borsh</li>
</ul>
<h2 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h2>
<p>The most mature and widely adopted option. Usually combined with gRPC framework. The <a href="https://github.com/tendermint/rust-abci">Tendermint Rust ABCI</a> provides protobuf definitions.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/danburkert/prost">https://github.com/danburkert/prost</a> - Rust native</li>
<li><a href="https://github.com/stepancheg/rust-protobuf">https://github.com/stepancheg/rust-protobuf</a> - Rust native</li>
<li><a href="https://github.com/tafia/quick-protobuf">https://github.com/tafia/quick-protobuf</a> - <a href="https://github.com/tafia/quick-protobuf/issues/12">missing features</a></li>
</ul>
<p><a href="https://www.reddit.com/r/rust/comments/czxny2/which_protocol_buffers_crates_to_invest_in/">A comparison of the two</a> main competing Rust implementations seems to favor Prost. Prost reportedly generates cleaner (more idiomatic) Rust code (<a href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671">https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671</a>). Prost also has better performance (<a href="https://github.com/danburkert/prost/issues/398#issuecomment-751600653">https://github.com/danburkert/prost/issues/398#issuecomment-751600653</a>). It is possible to also add serde derive attributes for e.g. <a href="https://github.com/danburkert/prost/issues/75">JSON support</a>. JSON can be useful for development, requests inspection and web integration. However, to reduce attack surface, we might want to disallow JSON for write requests on mainnet by default.</p>
<p>gRPC implementations:</p>
<ul>
<li><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a> - Rust native, using Prost and Tokio</li>
<li><a href="https://github.com/tikv/grpc-rs">https://github.com/tikv/grpc-rs</a> - build on C core library</li>
<li><a href="https://github.com/stepancheg/grpc-rust">https://github.com/stepancheg/grpc-rust</a> - not production ready</li>
</ul>
<h2 id="capnproto"><a class="header" href="#capnproto">Cap'n'proto</a></h2>
<p>It avoids serialization altogether, you use the data natively in a representation that is efficient for interchange (&quot;zero-copy&quot;). The other cool feature is its <a href="https://capnproto.org/rpc.html">&quot;time-traveling RPC&quot;</a>. On the other hand concern for this lib is a much lower adoption rate, especially the Rust port which is not as complete. The format is designed to be safe against malicious input (on the both sides of a communication channel), but according to <a href="https://capnproto.org/faq.html">FAQ</a> the reference impl (C++) has not yet undergone security review.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/capnproto/capnproto-rust">https://github.com/capnproto/capnproto-rust</a></li>
</ul>
<h2 id="flatbuffers"><a class="header" href="#flatbuffers">Flatbuffers</a></h2>
<p>Similar to protobuf, but zero-copy like Cap'n'proto, hence a lot faster.</p>
<p>Unfortunately, the Rust implementation is <a href="https://google.github.io/flatbuffers/flatbuffers_support.html">lacking buffer verifiers</a>, which is crucial for handling malicious requests gracefully. There is only draft implementation <a href="https://github.com/google/flatbuffers/pull/6269">https://github.com/google/flatbuffers/pull/6269</a>. This most likely rules out this option.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/google/flatbuffers/tree/master/rust/flatbuffers">https://github.com/google/flatbuffers/tree/master/rust/flatbuffers</a></li>
</ul>
<h2 id="serde"><a class="header" href="#serde">Serde</a></h2>
<p>Serde is Rust native framework with great ergonomics. It supports many <a href="https://serde.rs/#data-formats">different formats</a> implemented as libraries. It's used in some DBs too. Serde itself gives <a href="https://github.com/serde-rs/serde/issues/1087">no security guarantees</a>, handling of malicious input depends heavily on the used format. Serde can be used in combination with many other formats, like protobuf.</p>
<h2 id="bincode"><a class="header" href="#bincode">Bincode</a></h2>
<p><a href="https://github.com/servo/bincode">https://github.com/servo/bincode</a></p>
<p>Built on top of serde. Easy to use.</p>
<h2 id="borsh"><a class="header" href="#borsh">Borsh</a></h2>
<p><a href="https://github.com/near/borsh-rs">https://github.com/near/borsh-rs</a></p>
<p>Used in the Near protocol, it guarantees consistent representations and has a specification. It is also faster than bincode and is being <a href="https://github.com/near/borsh#implementations">implemented in other languages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-runtime"><a class="header" href="#wasm-runtime">WASM runtime</a></h1>
<p>Considered runtimes:</p>
<ul>
<li>wasmer</li>
<li>wasmi</li>
</ul>
<p>A good comparison overview is given in this <a href="https://forum.holochain.org/t/wasmi-vs-wasmer/1929">thread that discusses replacing wasmi with wasmer</a> and its links. In summary:</p>
<ul>
<li>wasmer has native rust closures (simpler code)</li>
<li>wasmer uses lexical scoping to import functions, wasmi is based on structs and trait impls</li>
<li>the wasmer org maintains wasmer packages in many languages</li>
<li>wasmer may be vulnerable to compiler bombs
<ul>
<li>this can be mitigated by using <a href="https://lib.rs/crates/wasmer-compiler-singlepass-near">a singlepass wasm compiler</a></li>
</ul>
</li>
<li>gas metering
<ul>
<li>wasmi inject calls to the host gas meter from Wasm modules</li>
<li>wasmer 
<ul>
<li>uses Middleware which injects the instructions at the parsing stage of the compiler (with inlining) - reduced overhead</li>
<li>must also consider compiler gas cost and how to handle compiler performance changes</li>
</ul>
</li>
<li>it's hard to implement gas rules for precompiles</li>
</ul>
</li>
<li><a href="https://github.com/WebAssembly/design/blob/c9db0ebdee28d2f92726314c05cb8ff382701f8e/Nondeterminism.md">nondeterminism concerns</a>
<ul>
<li>different wasm versions (e.g. newly added features) have to be handled in both the compiled and interpreted versions</li>
<li>non-determinism in the source language cannot be made deterministic in complied/interpreted wasm either</li>
<li>threading - look like it has a long way to go before being usable</li>
<li>floats/NaN - can be avoided <a href="https://github.com/WebAssembly/design/issues/582#issuecomment-191318866">https://github.com/WebAssembly/design/issues/582#issuecomment-191318866</a></li>
<li>SIMD</li>
<li>environment resources exhaustion</li>
</ul>
</li>
<li>both are using the same spec, in wasmi words &quot;there shouldn't be a problem migrating to another spec compliant execution engine.&quot; and &quot;wasmi should be a good option for initial prototyping&quot;
<ul>
<li>of course this is only true if we don't use features that are not yet in the spec</li>
</ul>
</li>
</ul>
<h2 id="wasmer"><a class="header" href="#wasmer">wasmer</a></h2>
<p>Repo: <a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></p>
<p>Compiled with multiple backends (Singlepass, Cranelift and LLVM). It <a href="https://github.com/wasmerio/wasmer/blob/3dc537cc49b8034047c3b142a66b3b6180f4447c/examples/metering.rs">support metering</a> via a <a href="https://github.com/wasmerio/wasmer/tree/3dc537cc49b8034047c3b142a66b3b6180f4447c/lib/middlewares">Middleware</a>.</p>
<h2 id="wasmi"><a class="header" href="#wasmi">wasmi</a></h2>
<p>Repo: <a href="https://github.com/paritytech/wasmi">https://github.com/paritytech/wasmi</a></p>
<p>Built for blockchain to ensure high degree of correctness (security, determinism). Interpreted, hence slower.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>The current preference is to use <code>thiserror</code> for most code and <code>eyre</code> for reporting errors at the CLI level and the client.</p>
<p>To make the code robust, we should avoid using code that may panic for errors that recoverable and handle all possible errors explicitly. Two exceptions to this rule are:</p>
<ul>
<li>prototyping, where it's fine to use <code>unwrap</code>, <code>expect</code>, etc.</li>
<li>in code paths with conditional compilation <strong>only</strong> for development build, where it's preferable to use <code>expect</code> in place of <code>unwrap</code> to help with debugging</li>
</ul>
<p>In case of panics, we should provide an error trace that is helpful for trouble-shooting and debugging.</p>
<p>A great post on error handling library/application distinction: <a href="https://nick.groenen.me/posts/rust-error-handling/">https://nick.groenen.me/posts/rust-error-handling/</a>.</p>
<p>The considered DBs:</p>
<ul>
<li>thiserror</li>
<li>anyhow</li>
<li>eyre</li>
</ul>
<p>The current preference is to use eyre at the outermost modules to print any encountered errors nicely back to the user and thiserror elsewhere.</p>
<h2 id="thiserror"><a class="header" href="#thiserror">Thiserror</a></h2>
<ul>
<li><a href="https://crates.io/crates/thiserror">https://crates.io/crates/thiserror</a></li>
</ul>
<p>Macros for user-derived error types. Commonly used for library code.</p>
<h2 id="anyhow"><a class="header" href="#anyhow">Anyhow</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">https://crates.io/crates/anyhow</a></li>
</ul>
<p>Easy error handling helpers. Commonly used for application code.</p>
<h2 id="eyre"><a class="header" href="#eyre">Eyre</a></h2>
<ul>
<li><a href="https://crates.io/crates/eyre">https://crates.io/crates/eyre</a></li>
</ul>
<p>Fork of <code>anyhow</code> with custom error reporting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li><strong>intent gossip</strong>
The intent gossip network must maintain a mempool of intents and gossips them
via a p2p layer. Each intent gossip node maintains a list of interests that
describe what intents it is interested in.</li>
<li><strong>intent</strong>
An expression of intent describes a particular trade an account agrees to.</li>
<li><strong>matchmaker</strong>
The matchmaker tries to match intents together. For each match it crafts a valid
transaction and submits it to the base ledger.</li>
<li><strong>validity predicate (VP)</strong>
A <a href="explore/design/ledger/vp.html">validity predicate</a> is a piece of code
attached to an account that can accept or reject any state changes performed by
a transaction in its sub-space.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-1"><a class="header" href="#resources-1">Resources</a></h1>
<p>Please add anything relevant to the project that you'd like to share with others, such as research papers, blog posts or tutorials. If it's not obvious from the title, please add some description.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li><a href="https://github.com/rust-in-blockchain/awesome-blockchain-rust">https://github.com/rust-in-blockchain/awesome-blockchain-rust</a></li>
</ul>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<ul>
<li><a href="https://github.com/mre/idiomatic-rust">https://github.com/mre/idiomatic-rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<h2 id="vscode"><a class="header" href="#vscode">VsCode</a></h2>
<p>Some handy extensions (output of <code>code --list-extensions</code>):</p>
<pre><code class="language-shell">aaron-bond.better-comments
be5invis.toml
bodil.file-browser
bungcip.better-toml
DavidAnson.vscode-markdownlint
jacobdufault.fuzzy-search
kahole.magit
matklad.rust-analyzer
oderwat.indent-rainbow
# easy to see if crates are up-to-date and update if not
serayuzgur.crates
streetsidesoftware.code-spell-checker
vscodevim.vim
# this is like https://www.spacemacs.org/ but in VsCode
VSpaceCode.vspacecode
VSpaceCode.whichkey
# org-mode
vscode-org-mode.org-mode
publicus.org-checkbox
</code></pre>
<p>Add these to your settings.json to get rustfmt and clippy with the nightly version that we use:</p>
<pre><code class="language-json">&quot;rust-analyzer.checkOnSave.overrideCommand&quot;: [
    &quot;cargo&quot;,
    &quot;+nightly-2021-08-04&quot;,
    &quot;clippy&quot;,
    &quot;--workspace&quot;,
    &quot;--message-format=json&quot;,
    &quot;--all-targets&quot;
],
&quot;rust-analyzer.rustfmt.overrideCommand&quot;: [
    &quot;rustup&quot;,
    &quot;run&quot;,
    &quot;nightly-2021-08-04&quot;,
    &quot;--&quot;,
    &quot;rustfmt&quot;,
    &quot;--edition&quot;,
    &quot;2018&quot;,
    &quot;--&quot;
],
</code></pre>
<p>When editing the wasms source (i.e. <code>wasm/wasm_source/src/..</code>), open the <code>wasm/wasm_source</code> as a workspace to get rust-analyzer working (because the crate is excluded from the root cargo workspace) and then active <code>--all-features</code> for it in the preferences.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>two main mode:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-mode">rust-mode</a>
official mode supported by rust dev</li>
<li><a href="https://github.com/brotzeit/rustic">rustic-mode</a>
forked with more option and better integration/default value</li>
</ul>
<h2 id="config-example-with-rustic-and-use-package"><a class="header" href="#config-example-with-rustic-and-use-package">config example with rustic and use-package</a></h2>
<pre><code class="language-elisp">    ;; all flycheck not mandatory not mandatory
  (use-package flycheck
    :commands flycheck-mode
    :init (global-flycheck-mode))

  (use-package flycheck-color-mode-line
    :after flycheck
    :hook
    (flycheck-mode . flycheck-color-mode-line-mode))

  (use-package flycheck-pos-tip
    :after flycheck)
  (use-package lsp-mode
    :after flycheck
    :bind-keymap
    (&quot;C-c i&quot; .  lsp-command-map)
    :hook
    (lsp-mode . lsp-enable-which-key-integration) ;; if wichkey installed
    :commands (lsp lsp-deferred)
    :custom
    (lsp-eldoc-render-all t)
    (lsp-idle-delay 0.3)
    )

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :custom
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-max-height 30)
    :hook (lsp-mode . lsp-ui-mode))

    ;; if ivy installed installed
  (use-package lsp-ivy
    :after lsp-mode ivy
    :commands lsp-ivy-workspace-symbol)

    ;; if company installed
  (use-package company-lsp
    :after lsp-mode company
    :init
    (push 'company-lsp company-backend))

  (use-package rustic
    :bind (:map rustic-mode-map
                (&quot;M-j&quot; . lsp-ui-imenu)
                (&quot;M-?&quot; . lsp-find-references)
                (&quot;C-c C-c ?&quot; . lsp-describe-thing-at-point)
                (&quot;C-c C-c !&quot; . lsp-execute-code-action)
                (&quot;C-c C-c r&quot; . lsp-rename)
                (&quot;C-c C-c TAB&quot; . lsp-rust-analyzer-expand-macro)
                (&quot;C-c C-c q&quot; . lsp-workspace-restart)
                (&quot;C-c C-c Q&quot; . lsp-workspace-shutdown)
                (&quot;C-c C-c s&quot; . lsp-rust-analyzer-status)
                (&quot;C-c C-c C-a&quot; . rustic-cargo-add)
                (&quot;C-c C-c C-d&quot; . rustic-cargo-rm)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-upgrade)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-outdated))
    :hook
    (rustic-mode . lsp-deferred)
    :custom
    (lsp-rust-analyzer-cargo-watch-command &quot;clippy&quot;)
    :config
    (rustic-doc-mode t)
  )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifications"><a class="header" href="#specifications">Specifications</a></h1>
<p><a href="https://anoma.network/papers/whitepaper.pdf">Anoma</a> is a sovereign, proof-of-stake blockchain protocol that enables private, asset-agnostic cash and private bartering among any number of parties.</p>
<p>This specification defines the Anoma ledger's protocol and its components and the intent gossip and matchmaking system.</p>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/rfc/rfc2119">RFC-2119</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>At a high level, Anoma is composed of two main components: the distributed ledger and the intent gossip / matchmaking system. While they are designed to complement each other, they can be operated separately.</p>
<h2 id="the-ledger-1"><a class="header" href="#the-ledger-1">The ledger</a></h2>
<p>The ledger is a distributed state machine, relying on functionality provided by <a href="https://docs.tendermint.com/master/spec/">Tendermint</a> such as its BFT consensus algorithm with instant finality, P2P networking capabilities, transaction mempool and more. The ledger state machine is built on top the <a href="https://docs.tendermint.com/master/spec/abci/">ABCI</a>.</p>
<p>For block validator voting power assignment, the ledger employs a proof-of-stake system.</p>
<p>The ledger's key-value storage is organized into blocks and user specific state is organized into accounts. The state machine executes transactions, which can apply arbitrary changes to the state that are validated by validity predicates associated with the accounts involved in the transaction.</p>
<p>To prevent transaction front-running, the ledger employs a DKG scheme as implemented in <a href="https://github.com/anoma/ferveo">Ferveo</a>. Using this scheme, transactions are encrypted before being submitted to the ledger. The encrypted transactions are committed by a block proposer to a specific order in which they must be executed once decrypted.</p>
<ul>
<li>TODO add fractal scaling &amp; protocol upgrade system overview</li>
</ul>
<h2 id="the-intent-gossip-with-matchmaking-system"><a class="header" href="#the-intent-gossip-with-matchmaking-system">The intent gossip with matchmaking system</a></h2>
<ul>
<li>TODO add an overview</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger-2"><a class="header" href="#the-ledger-2">The ledger</a></h1>
<h2 id="the-protocol"><a class="header" href="#the-protocol">The protocol</a></h2>
<ul>
<li>TODO describe DKG transactions</li>
<li>TODO DKG transactions will include replay protection (this is because we can simply check a counter against the source (i.e. gas payer) of the transaction before the transactions order is committed to by the DKG protocol, which could affect the expected counter order for sources with multiple queued transactions)</li>
</ul>
<h3 id="transactions-2"><a class="header" href="#transactions-2">Transactions</a></h3>
<p>A transaction <a href="specs/./encoding.html#transactions">encoded with proto3</a> received from ABCI <code>DeliverTx</code> method is executed in two main steps:</p>
<ol>
<li><a href="specs/ledger.html#transaction-execution">Transaction execution</a></li>
<li><a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a></li>
</ol>
<h4 id="transaction-execution"><a class="header" href="#transaction-execution">Transaction execution</a></h4>
<p>For any error encountered in any of the following steps of transaction execution, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<ol>
<li>Charge a base transaction <a href="specs/ledger.html#gas">gas</a>:
\( \verb|BASE_TRANSACTION_FEE| \)</li>
<li>Decode the transaction bytes and validate the data. The field <code>timestamp</code> is required.</li>
<li>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the <code>code</code> field of the transaction (this is because the WASM code is compiled with a single-pass compiler):
\( \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \)</li>
<li><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> from the <code>code</code> field of the transaction.</li>
<li>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</li>
<li>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</li>
<li>Compile the transaction <code>code</code> with a single-pass compiler (for example, <a href="https://medium.com/wasmer/a-webassembly-compiler-tale-9ef37aa3b537">the Wasmer runtime single-pass compiler</a>). The compilation computational complexity MUST be linear in proportion to the <code>code</code> size.</li>
<li>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_MAX_PAGES</code></a>.</li>
<li>Instantiate the WASM module with imported <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a> and the instantiated WASM memory.</li>
<li>Write the transaction's <code>data</code> into the memory exported from the WASM module instance.</li>
<li>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:
<pre><code class="language-wat">func (param i64 i64)
</code></pre>
The first argument is the offset to the <code>data</code> input written into the memory and the second argument is its bytes length.</li>
</ol>
<p>If the transaction executed successfully, it is followed <a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a>.</p>
<h4 id="validity-predicates-check"><a class="header" href="#validity-predicates-check">Validity predicates check</a></h4>
<p>For the transaction to be valid, all the triggered validity predicates must accept it.</p>
<p>First, the addresses whose validity predicates should be triggered by the transaction are determined. In this process, the addresses get associated with a set of modified storage keys that are relevant to the address:</p>
<ol>
<li>
<p>The addresses set by the transaction (see <code>insert_verifier</code> in <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a>) are associated with <em>all</em> the modified storage keys.</p>
<p>TODO - <a href="https://github.com/anoma/anoma/issues/292">https://github.com/anoma/anoma/issues/292</a></p>
</li>
<li>
<p>The storage keys that were modified by the transaction are associated with the addresses included in the storage keys. Note that a storage key may contain more than one address, in which case all its addresses are associated with this key. </p>
</li>
<li>
<p>All these addresses are additionally associated with the storage key to the validity predicates of any newly initialized accounts' by the transaction (see <code>init_account</code> in <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a>).</p>
</li>
</ol>
<p>For all these addresses, attempt to read their validity predicate WASM code from the storage. For each validity predicate look-up, charge storage read gas and WASM compilation gas, proportional to the bytes length of the validity predicate. If any of the validity predicates look-ups fails, or any validity rejects the transaction or fails anywhere in the execution, the whole transaction is rejected. If the transaction is rejected, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<p>Execute all validity predicates in parallel as follows:</p>
<ol>
<li>Charge WASM compilation gas, proportional to the bytes length of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler).</li>
<li>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler): \( \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \).</li>
<li><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> of the validity predicate.</li>
<li>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</li>
<li>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</li>
<li>Compile the validity predicate with single-pass compiler. The compilation computational complexity MUST be linear in proportion to its bytes size.</li>
<li>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_MAX_PAGES</code></a>.</li>
<li>Instantiate the WASM module with imported <a href="specs/ledger.html#validity-predicate-host-environment-functions">validity predicate host environment functions</a> and the instantiated WASM memory.</li>
<li>Write the address of the validity predicate‚Äôs owner, the transaction <code>data</code>, the modified storage keys encoded with Borsh, and all the triggered validity predicates owners' addresses encoded with Borsh into the memory exported from the WASM module instance.</li>
<li>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:
<pre><code class="language-wat">func (param i64 i64 i64 i64 i64 i64 i64 i64) (result i64))
</code></pre>
<ul>
<li>The first argument is the offset to the owner‚Äôs address written into the memory, the second argument is its bytes length</li>
<li>The third is the offset of the transaction‚Äôs <code>data</code> and fourth is it‚Äôs bytes length</li>
<li>The fifth is the offset of the modified storage keys and sixth is its bytes length</li>
<li>The seventh is the offset of the triggered validity predicates owners' addresses and eighth is its bytes length</li>
</ul>
</li>
</ol>
<h4 id="gas"><a class="header" href="#gas">Gas</a></h4>
<h5 id="gas-constants"><a class="header" href="#gas-constants">Gas constants</a></h5>
<p>The gas constants are currently chosen arbitrarily and are subject to change following gas accounting estimations.</p>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td><code>COMPILE_GAS_PER_BYTE</code></td><td>1</td></tr>
<tr><td><code>BASE_TRANSACTION_FEE</code></td><td>2</td></tr>
<tr><td><code>PARALLEL_GAS_DIVIDER</code></td><td>10</td></tr>
<tr><td><code>MIN_STORAGE_GAS</code></td><td>1</td></tr>
</tbody></table>
<ul>
<li>TODO describe gas accounting, wasm gas counter, limits, what happens if we go over limits and how gas relates to fees</li>
</ul>
<h4 id="webassembly-wasm"><a class="header" href="#webassembly-wasm">WebAssembly (WASM)</a></h4>
<h5 id="wasm-constants"><a class="header" href="#wasm-constants">WASM constants</a></h5>
<table><thead><tr><th>Name</th><th>Unit</th><th>Value</th></tr></thead><tbody>
<tr><td><code>PAGE</code> (as defined in the WASM spec)</td><td>kiB</td><td>64</td></tr>
<tr><td><code>TX_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>TX_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>VP_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>VP_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>WASM_STACK_LIMIT</code></td><td>stack depth</td><td>65535</td></tr>
</tbody></table>
<p>The WASM instantiation, the types, instructions, validation and execution of WASM modules MUST conform to the <a href="https://webassembly.github.io/spec/core/intro/index.html">WebAssembly specification</a>.</p>
<h5 id="wasm-validation"><a class="header" href="#wasm-validation">WASM validation</a></h5>
<p>The WebAssembly code is REQUIRED to only use deterministic instructions. Furthermore, it MUST NOT use features from any of the following WebAssembly proposals:</p>
<ul>
<li>The reference types proposal</li>
<li>The multi-value proposal</li>
<li>The bulk memory operations proposal</li>
<li>The module linking proposal</li>
<li>The SIMD proposal</li>
<li>The threads proposal</li>
<li>The tail-call proposal</li>
<li>The multi memory proposal</li>
<li>The exception handling proposal</li>
<li>The memory64 proposal</li>
</ul>
<h5 id="stack-height-limiter"><a class="header" href="#stack-height-limiter">Stack height limiter</a></h5>
<p>To make stack overflows deterministic, set the upper bound of the stack size to <a href="specs/ledger.html#wasm-constants"><code>WASM_STACK_LIMIT</code></a>. If the stack height exceeds the limit then execution MUST abort.</p>
<!--
cargo test test_tx_stack_limiter
cargo test test_vp_stack_limiter
-->
<h5 id="wasm-memory-1"><a class="header" href="#wasm-memory-1">WASM memory</a></h5>
<ul>
<li>TODO memory read/write gas costs</li>
</ul>
<h5 id="transaction-host-environment-functions"><a class="header" href="#transaction-host-environment-functions">Transaction host environment functions</a></h5>
<p>The following functions from the host ledger are made available in transaction's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime:</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_tx_read&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_has_key&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_write&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_delete&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_insert_verifier&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_update_validity_predicate&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_init_account&quot; (func (param i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_log_string&quot; (func (param i64 i64)))
</code></pre>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<ul>
<li><code>anoma_tx_init_account</code> TODO newly created accounts' validity predicates aren't used until the block is committed (i.e. only the transaction that created the account may write into its storage in the block in which its being applied).</li>
<li>TODO describe functions in detail</li>
</ul>
<h5 id="validity-predicate-host-environment-functions"><a class="header" href="#validity-predicate-host-environment-functions">Validity predicate host environment functions</a></h5>
<p>The following functions from the host ledger are made available in validity predicate's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime.</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_vp_read_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_read_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_pre_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_post_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_verify_tx_signature&quot; (func (param i64 i64 i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_eval&quot; (func (param i64 i64 i64 i64) (result i64)))
</code></pre>
<ul>
<li>TODO describe functions in detail</li>
</ul>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<h3 id="storage-4"><a class="header" href="#storage-4">Storage</a></h3>
<ul>
<li>TODO</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding"><a class="header" href="#encoding">Encoding</a></h1>
<p>All the data fields are REQUIRED, unless specified otherwise.</p>
<h2 id="the-ledger-3"><a class="header" href="#the-ledger-3">The ledger</a></h2>
<h3 id="transactions-3"><a class="header" href="#transactions-3">Transactions</a></h3>
<p>Transactions MUST be encoded using <a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec">proto3</a> in the format as defined for <a href="specs/encoding.html#proto-definitions"><code>message Tx</code></a>.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Field Number</th></tr></thead><tbody>
<tr><td>code</td><td>bytes</td><td>Transaction WASM code.</td><td>1</td></tr>
<tr><td>data</td><td>optional bytes</td><td>Transaction data (OPTIONAL).</td><td>2</td></tr>
<tr><td>timestamp</td><td>google.protobuf.Timestamp</td><td>Timestamp of when the transaction was created.</td><td>3</td></tr>
</tbody></table>
<h2 id="proto-definitions"><a class="header" href="#proto-definitions">Proto definitions</a></h2>
<pre><code>syntax = &quot;proto3&quot;;

import &quot;google/protobuf/timestamp.proto&quot;;

package types;

message Tx {
  bytes code = 1;
  // TODO this optional is useless because it's default on proto3
  optional bytes data = 2;
  google.protobuf.Timestamp timestamp = 3;
}

message Intent {
  bytes data = 1;
  google.protobuf.Timestamp timestamp = 2;
}

message IntentGossipMessage{
  // TODO remove oneof because it's not used so far
  oneof msg {
    Intent intent = 1;
  }
}

message Dkg {
  string data = 1;
}

message DkgGossipMessage{
  oneof dkg_message {
    Dkg dkg = 1;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>Deprecated pages archived for possible later re-use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-name-addresses"><a class="header" href="#domain-name-addresses">Domain name addresses</a></h1>
<p>The transparent addresses are similar to domain names and the ones used in e.g. <a href="https://eips.ethereum.org/EIPS/eip-137">ENS as specified in EIP-137</a> and <a href="https://nomicon.io/DataStructures/Account.html">account IDs in Near protocol</a>. These are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>A transparent address is a human-readable string very similar to a domain name, containing only alpha-numeric ASCII characters, hyphen (<code>-</code>) and full stop (<code>.</code>) as a separator between the &quot;labels&quot; of the address. The letter case is not significant and any upper case letters are converted to lower case. The last label of an address is said to be the top-level name and each predecessor segment is the sub-name of its successor.</p>
<p>The length of an address must be at least 3 characters. For compatibility with a legacy DNS TXT record, we'll use syntax as defined in <a href="https://www.ietf.org/rfc/rfc1034.txt">RFC-1034 - section 3.5 DNS preferred name syntax</a>. That is, the upper limit is 255 characters and 63 for each label in an address (which should be sufficient anyway); and the label must not begin or end with hyphen (<code>-</code>) and must not begin with a digit.</p>
<p>These addresses can be chosen by users who wish to <a href="archive/domain-name-addresses.html#initializing-a-new-account">initialize a new account</a>, following these rules:</p>
<ul>
<li>a new address must be initialized on-chain
<ul>
<li>each sub-label must be authorized by the predecessor level address (e.g. initializing address <code>free.eth</code> must be authorized by <code>eth</code>, or <code>gives.free.eth</code> by <code>free.eth</code>, etc.) </li>
<li>note that besides the address creation, each address level is considered to be a distinct address with its own dynamic storage sub-space and validity predicate.</li>
</ul>
</li>
<li>the top-level names under certain length (to be specified) cannot be initialized directly, they may be <a href="https://eips.ethereum.org/EIPS/eip-162">auctioned like in ENS registrar as described in EIP-162</a>.
<ul>
<li>some top-level names may be reserved</li>
</ul>
</li>
</ul>
<p>For convenience, the <code>anoma</code> top-level address is initially setup to allow initialization of any previously unused second-level address, e.g. <code>bob.anoma</code> (we may want to revise this before launch to e.g. auction the short ones, like with top-level names to make the process fairer).</p>
<p>Like in ENS, the addresses are stored on chain by their hash, encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a> (<a href="https://github.com/zcash/zips/issues/484">not yet adopted in Zcash</a>), which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>. Likewise, this is for two reasons:</p>
<ul>
<li>help preserve privacy of addresses that were not revealed publicly and to prevent trivial enumeration of registered names (of course, you can still try to enumerate by hashes)</li>
<li>using fixed-length string in the ledger simplifies gas accounting</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/mermaid.min.js"></script>
        <script type="text/javascript" src="assets/mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
